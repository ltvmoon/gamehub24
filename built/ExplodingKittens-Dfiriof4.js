import{B as t}from"./BaseGame--ikFMc2v.js";const e=3e4,s={EXPLODING_KITTEN:0,DEFUSE:1,ATTACK:2,SKIP:3,FAVOR:4,SHUFFLE:5,SEE_THE_FUTURE:6,NOPE:7,CAT_1:8,CAT_2:9,CAT_3:10,CAT_4:11,CAT_5:12,REVERSE:13,TARGETED_ATTACK:14,ALTER_THE_FUTURE_3:15,ALTER_THE_FUTURE_5:16,PERSONAL_ATTACK:17,CATOMIC_BOMB:18,DRAW_BOTTOM:19,BURY:20,SUPER_SKIP:21},a={WAITING:0,PLAYING:1,DEFUSING:2,INSERTING_KITTEN:3,FAVOR_GIVING:5,NOPE_WINDOW:7,ALTER_THE_FUTURE:8,BURYING_CARD:10,ENDED:9},i=Object.values(s).reduce((t,e)=>({...t,[e]:!0}),{});class r extends t{static DECK_CONFIG_KEY="ek_deck_config";deckConfig;botActionPending=!1;constructor(t,e,s,a){super(t,e,s,a);let n={};try{if("undefined"!=typeof localStorage){const t=localStorage.getItem(r.DECK_CONFIG_KEY);t&&(n=JSON.parse(t))}}catch(h){console.warn("Failed to load deck config",h)}this.deckConfig=i,Object.entries(n).forEach(([t,e])=>{t in this.deckConfig&&(this.deckConfig[t]=e)})}isGameOver(t){return t.gamePhase===a.ENDED}getInitState(){return{players:Array(5).fill(null).map((t,e)=>{const s=this.players[e];return{id:s?.id||null,username:s?.username||`Slot ${e+1}`,hand:[],isExploded:!1,isBot:!1,isHost:s?.id===this.userId}}),drawPile:[],discardPile:[],discardHistory:[],privateLogs:[],currentTurnIndex:0,attackStack:1,direction:1,gamePhase:a.WAITING,winner:null,alterCards:null,alterCount:0,buryCard:null,favorFrom:null,favorTo:null,comboFrom:null,comboTo:null,comboCount:0,lastAction:null,newGameRequest:null,pendingAction:null}}onSocketGameAction(t){const e=t.action;if(this.isHost)switch(e.type){case"START_GAME":this.handleStartGame();break;case"DRAW_CARD":this.handleDrawCard(e.playerId);break;case"PLAY_CARD":this.handlePlayCard(e.playerId,e.cardIndex,e.targetPlayerId);break;case"PLAY_COMBO":this.handlePlayCombo(e.playerId,e.cardIndices,e.targetPlayerId,e.requestedCardType);break;case"DEFUSE":this.handleDefuse(e.playerId);break;case"INSERT_KITTEN":this.handleInsertCard(e.playerId,e.index);break;case"GIVE_FAVOR":this.handleGiveFavor(e.playerId,e.cardIndex);break;case"ADD_BOT":this.handleAddBot(e.slotIndex);break;case"JOIN_SLOT":this.handleJoinSlot(e.slotIndex,e.playerId,e.playerName);break;case"REMOVE_PLAYER":this.handleRemovePlayer(e.slotIndex);break;case"NEW_GAME":case"ACCEPT_NEW_GAME":this.reset();break;case"REQUEST_NEW_GAME":this.handleNewGameRequest(e.playerId,e.playerName);break;case"DECLINE_NEW_GAME":this.state.newGameRequest=null;break;case"RESPOND_NOPE":this.handleRespondNope(e.playerId,e.response);break;case"REORDER_FUTURE":this.handleReorderFuture(e.playerId,e.newOrder)}}getDeckConfig(){return{...this.deckConfig}}setDeckConfig(t){this.deckConfig={...t};try{"undefined"!=typeof localStorage&&localStorage.setItem(r.DECK_CONFIG_KEY,JSON.stringify(this.deckConfig))}catch(e){console.warn("Failed to save deck config",e)}}getCardCountForType(t,e){if(t===s.EXPLODING_KITTEN)return e-1;if(t===s.DEFUSE){return e+(2===e?1:2)}const a=(t,s=2)=>e>=4?t:3===e?Math.max(s,Math.ceil(.75*t)):Math.max(s,Math.ceil(.6*t));switch(t){case s.ATTACK:case s.SKIP:return a(4);case s.FAVOR:case s.SHUFFLE:return a(3);case s.SEE_THE_FUTURE:return a(4);case s.NOPE:return a(5);case s.CAT_1:case s.CAT_2:case s.CAT_3:case s.CAT_4:case s.CAT_5:return a(5,4);case s.REVERSE:return a(3,2);case s.TARGETED_ATTACK:return a(2,1);case s.ALTER_THE_FUTURE_3:return a(3,2);case s.ALTER_THE_FUTURE_5:return a(1,1);case s.PERSONAL_ATTACK:return a(2,1);case s.CATOMIC_BOMB:return 1;case s.DRAW_BOTTOM:case s.BURY:return a(3,2);case s.SUPER_SKIP:return a(2,1);default:return 0}}createDeck(t){const e=[];let a=1;const i=(t,s)=>{if(this.deckConfig[t])for(let i=0;i<s;i++)e.push([t,a++])};i(s.ATTACK,this.getCardCountForType(s.ATTACK,t)),i(s.SKIP,this.getCardCountForType(s.SKIP,t)),i(s.FAVOR,this.getCardCountForType(s.FAVOR,t)),i(s.SHUFFLE,this.getCardCountForType(s.SHUFFLE,t)),i(s.SEE_THE_FUTURE,this.getCardCountForType(s.SEE_THE_FUTURE,t)),i(s.NOPE,this.getCardCountForType(s.NOPE,t)),i(s.CAT_1,this.getCardCountForType(s.CAT_1,t)),i(s.CAT_2,this.getCardCountForType(s.CAT_2,t)),i(s.CAT_3,this.getCardCountForType(s.CAT_3,t)),i(s.CAT_4,this.getCardCountForType(s.CAT_4,t)),i(s.CAT_5,this.getCardCountForType(s.CAT_5,t)),i(s.REVERSE,this.getCardCountForType(s.REVERSE,t)),i(s.TARGETED_ATTACK,this.getCardCountForType(s.TARGETED_ATTACK,t)),i(s.ALTER_THE_FUTURE_3,this.getCardCountForType(s.ALTER_THE_FUTURE_3,t)),i(s.ALTER_THE_FUTURE_5,this.getCardCountForType(s.ALTER_THE_FUTURE_5,t)),i(s.PERSONAL_ATTACK,this.getCardCountForType(s.PERSONAL_ATTACK,t)),i(s.CATOMIC_BOMB,this.getCardCountForType(s.CATOMIC_BOMB,t)),i(s.DRAW_BOTTOM,this.getCardCountForType(s.DRAW_BOTTOM,t)),i(s.BURY,this.getCardCountForType(s.BURY,t)),i(s.SUPER_SKIP,this.getCardCountForType(s.SUPER_SKIP,t));const r=10*t;if(e.length<r){const t=Object.entries(this.deckConfig).filter(([t,e])=>e).map(([t])=>Number(t));0===t.length&&t.push(s.CAT_1,s.CAT_2,s.CAT_3,s.CAT_4,s.CAT_5);let i=0;for(;e.length<r;){const r=t[i%t.length];r!==s.DEFUSE&&r!==s.EXPLODING_KITTEN&&r!==s.CATOMIC_BOMB&&e.push([r,a++]),i++}}return this.shuffle(e)}shuffle(t){const e=[...t];for(let s=e.length-1;s>0;s--){const t=Math.floor(Math.random()*(s+1));[e[s],e[t]]=[e[t],e[s]]}return e}handleStartGame(){if(this.state.gamePhase!==a.WAITING)return;const t=this.state.players.filter(t=>null!==t.id);if(t.length<2)return;let e=this.createDeck(t.length),i=1e3;for(const a of t)a.hand=[[s.DEFUSE,i++],...e.splice(0,6)];const r=2===t.length?1:2;for(let a=0;a<r;a++)e.push([s.DEFUSE,i++]);for(let a=0;a<t.length-1;a++)e.push([s.EXPLODING_KITTEN,i++]);this.state.drawPile=this.shuffle(e),this.state.gamePhase=a.PLAYING,this.state.direction=1,this.state.currentTurnIndex=this.state.players.findIndex(t=>null!==t.id),this.state.attackStack=1,this.state.discardPile=[],this.checkBotTurn()}handleDrawCard(t){if(this.state.gamePhase!==a.PLAYING)return;const e=this.state.players.findIndex(e=>e.id===t);if(e!==this.state.currentTurnIndex)return;if(0===this.state.drawPile.length)return;const i=this.state.drawPile.pop();if(i[0]===s.EXPLODING_KITTEN)this.handleExplode(t);else{this.state.players[e].hand.push(i);const s=Date.now();this.state.discardHistory.push({playerId:t,cards:[],timestamp:s}),this.state.lastAction={action:{type:"DRAW_CARD",playerId:t},playerId:t,timestamp:s,isNoped:!1},this.finishTurnAction()}}handlePlayCard(t,e,i){if(this.state.gamePhase!==a.PLAYING)return;const r=this.state.players.findIndex(e=>e.id===t);if(r!==this.state.currentTurnIndex)return;const n=this.state.players[r];if(e<0||e>=n.hand.length)return;const h=n.hand[e];if(h[0]===s.NOPE||h[0]===s.DEFUSE||h[0]===s.EXPLODING_KITTEN||h[0]>=s.CAT_1&&h[0]<=s.CAT_5)return;n.hand.splice(e,1),this.state.discardPile.push(h);const d=Date.now();let o=i;h[0]===s.ATTACK&&(o=this.getNextPlayerId(r)),this.state.discardHistory.push({playerId:t,cards:[h],timestamp:d,targetPlayerId:o}),this.startNopeWindow({type:"PLAY_CARD",playerId:t,cardIndex:e,targetPlayerId:o},t,d)}handlePlayCombo(t,e,i,r){if(this.state.gamePhase!==a.PLAYING)return;const n=this.state.players.findIndex(e=>e.id===t);if(n!==this.state.currentTurnIndex)return;const h=this.state.players[n];if(e.length<2)return;const d=Array.from(new Set(e)).filter(t=>t>=0&&t<h.hand.length).sort((t,e)=>e-t);if(d.length<2)return;const o=d.map(t=>h.hand[t]);if(o.some(t=>!t))return;const l=o[0][0];if(l===s.NOPE)return;if(!o.every(t=>t[0]===l))return;const c=[];for(const s of d)c.push(h.hand.splice(s,1)[0]);this.state.discardPile.push(...c);const T=Date.now();this.state.discardHistory.push({playerId:t,cards:c,timestamp:T,targetPlayerId:i}),this.startNopeWindow({type:"PLAY_COMBO",playerId:t,cardIndices:e,targetPlayerId:i,requestedCardType:r},t,T)}startNopeWindow(t,i,r){const n=this.state.discardPile[this.state.discardPile.length-1];this.state.pendingAction={action:t,playerId:i,timerStart:Date.now(),nopeCount:0,responses:{},nopeChain:[{playerId:i,cardType:n[0]}],entryTimestamp:r,originalCard:n},this.state.players.forEach(t=>{t.id&&(!t.isExploded&&t.hand.some(t=>t[0]===s.NOPE)&&t.id!==i||(this.state.pendingAction.responses[t.id]="ALLOW"))});if(this.state.players.filter(t=>t.id&&!t.isExploded).every(t=>"ALLOW"===this.state.pendingAction.responses[t.id]))return void this.executePendingAction();this.state.gamePhase=a.NOPE_WINDOW;const h=this.state.pendingAction.timerStart;setTimeout(()=>{this.state.pendingAction&&this.state.pendingAction.timerStart===h&&this.executePendingAction()},e),this.checkBotTurn()}handleRespondNope(t,i){if(this.state.gamePhase===a.NOPE_WINDOW&&this.state.pendingAction)if("NOPE"===i){const a=this.state.players.findIndex(e=>e.id===t);if(-1===a)return;const i=this.state.players[a],r=i.hand.findIndex(t=>t[0]===s.NOPE);if(-1===r)return;const n=i.hand.splice(r,1)[0];this.state.discardPile.push(n),this.state.pendingAction.nopeCount++,this.state.pendingAction.nopeChain.push({playerId:t,cardType:s.NOPE}),this.state.pendingAction.timerStart=Date.now(),this.state.pendingAction.responses={[t]:"ALLOW"},this.state.players.forEach(e=>{e.id&&e.id!==t&&(!e.isExploded&&e.hand.some(t=>t[0]===s.NOPE)||(this.state.pendingAction.responses[e.id]="ALLOW"))});if(this.state.players.filter(t=>t.id&&!t.isExploded).every(t=>"ALLOW"===this.state.pendingAction.responses[t.id]))return void this.executePendingAction();const h=this.state.pendingAction.timerStart;setTimeout(()=>{this.state.pendingAction&&this.state.pendingAction.timerStart===h&&this.executePendingAction()},e),this.checkBotTurn()}else{this.state.pendingAction.responses[t]="ALLOW";this.state.players.filter(t=>t.id&&!t.isExploded).every(t=>"ALLOW"===this.state.pendingAction.responses[t.id])&&this.executePendingAction()}}executePendingAction(){if(!this.state.pendingAction)return;const{action:t,nopeCount:e,playerId:s,nopeChain:i,entryTimestamp:r,originalCard:n}=this.state.pendingAction,h=e%2==1;if(this.state.gamePhase=a.PLAYING,this.state.pendingAction=null,r){const t=this.state.discardHistory.find(t=>t.timestamp===r);t&&(t.nopeChain=i,t.isNoped=h)}let d;if("PLAY_CARD"===t.type&&i.length>0&&(d=i[0].cardType),this.state.lastAction={action:t,playerId:s,timestamp:Date.now(),isNoped:h,cardType:d},!h)if("PLAY_CARD"===t.type){const e=n??this.state.discardPile[this.state.discardPile.length-1];this.executeCardAction(e,t.playerId,t.targetPlayerId)}else"PLAY_COMBO"===t.type&&this.executeComboAction(t.playerId,t.cardIndices.length,t.targetPlayerId,t.requestedCardType,r);this.checkBotTurn()}executeCardAction(t,e,i){const r=this.state.players.findIndex(t=>t.id===e);switch(t[0]){case s.ATTACK:this.state.attackStack=(this.state.attackStack>1?this.state.attackStack:0)+2,this.advanceTurn(!0);break;case s.SKIP:this.finishTurnAction();break;case s.SHUFFLE:this.state.drawPile=this.shuffle(this.state.drawPile);break;case s.SEE_THE_FUTURE:break;case s.FAVOR:if(i){const t=this.state.players.findIndex(t=>t.id===i);-1===t||t===r||this.state.players[t].isExploded||(this.state.gamePhase=a.FAVOR_GIVING,this.state.favorFrom=i,this.state.favorTo=e)}break;case s.REVERSE:this.state.direction*=-1,this.finishTurnAction();break;case s.TARGETED_ATTACK:if(i){const t=this.state.players.findIndex(t=>t.id===i);-1===t||t===r||this.state.players[t].isExploded||(this.state.attackStack=(this.state.attackStack>1?this.state.attackStack:0)+2,this.state.currentTurnIndex=t,this.checkBotTurn())}break;case s.ALTER_THE_FUTURE_3:this.state.alterCards=this.state.drawPile.slice(-3).reverse(),this.state.alterCount=this.state.alterCards.length,this.state.gamePhase=a.ALTER_THE_FUTURE,this.checkBotTurn();break;case s.ALTER_THE_FUTURE_5:this.state.alterCards=this.state.drawPile.slice(-5).reverse(),this.state.alterCount=this.state.alterCards.length,this.state.gamePhase=a.ALTER_THE_FUTURE,this.checkBotTurn();break;case s.PERSONAL_ATTACK:this.state.attackStack+=4,this.finishTurnAction();break;case s.CATOMIC_BOMB:const t=this.state.drawPile.filter(t=>t[0]===s.EXPLODING_KITTEN),n=this.state.drawPile.filter(t=>t[0]!==s.EXPLODING_KITTEN),h=this.shuffle(n);this.state.drawPile=[...h,...t],this.finishTurnAction();break;case s.DRAW_BOTTOM:if(this.state.drawPile.length>0){const t=this.state.drawPile.shift();if(t[0]===s.EXPLODING_KITTEN)this.handleExplode(e);else{const s=this.state.players.find(t=>t.id===e);s&&(s.hand.push(t),this.finishTurnAction())}}else this.finishTurnAction();break;case s.BURY:if(this.state.drawPile.length>0){const t=this.state.drawPile.pop();this.state.buryCard=t,this.state.gamePhase=a.BURYING_CARD,this.checkBotTurn()}else this.finishTurnAction();break;case s.SUPER_SKIP:this.state.attackStack=0,this.advanceTurn()}}executeComboAction(t,e,s,a,i){const r=this.state.players.findIndex(e=>e.id===t),n=this.state.players[r],h=this.state.players.findIndex(t=>t.id===s);if(-1===h||h===r||this.state.players[h].isExploded)return;const d=this.state.players[h];let o;if(2===e){if(d.hand.length>0){const t=Math.floor(Math.random()*d.hand.length);o=d.hand.splice(t,1)[0],o&&n.hand.push(o)}}else if(3===e&&void 0!==a){const t=d.hand.findIndex(t=>t[0]===a);-1!==t&&(o=d.hand.splice(t,1)[0],o&&n.hand.push(o))}o&&i&&this.state.privateLogs.push({id:Date.now(),timestamp:Date.now(),discardEntryTimestamp:i,visibleTo:[t,s],stolenCard:o,fromPlayerId:s,toPlayerId:t})}handleExplode(t){const e=this.state.players.findIndex(e=>e.id===t);if(-1===e)return;this.state.gamePhase=a.DEFUSING;-1===this.state.players[e].hand.findIndex(t=>t[0]===s.DEFUSE)?this.explodePlayer(e):this.checkBotTurn()}handleDefuse(t){if(this.state.gamePhase!==a.DEFUSING)return;const e=this.state.players.findIndex(e=>e.id===t);if(e!==this.state.currentTurnIndex)return;const i=this.state.players[e],r=i.hand.findIndex(t=>t[0]===s.DEFUSE);if(-1===r)return;const n=i.hand.splice(r,1)[0];this.state.discardPile.push(n);const h=Date.now();this.state.discardHistory.push({playerId:t,cards:[n],timestamp:h}),this.state.lastAction={action:{type:"DEFUSE",playerId:t},playerId:t,timestamp:h,isNoped:!1,cardType:s.DEFUSE},this.state.gamePhase=a.INSERTING_KITTEN,this.checkBotTurn()}handleInsertCard(t,e){if(this.state.gamePhase!==a.INSERTING_KITTEN&&this.state.gamePhase!==a.BURYING_CARD)return;if(this.state.players.findIndex(e=>e.id===t)!==this.state.currentTurnIndex)return;let i=null;if(this.state.gamePhase===a.INSERTING_KITTEN?i=[s.EXPLODING_KITTEN,Date.now()]:this.state.gamePhase===a.BURYING_CARD&&(i=this.state.buryCard,this.state.buryCard=null),!i)return;const r=Math.max(0,Math.min(e,this.state.drawPile.length)),n=this.state.drawPile.length-r;this.state.drawPile.splice(n,0,i),this.state.gamePhase=a.PLAYING,this.finishTurnAction()}handleGiveFavor(t,e){if(this.state.gamePhase!==a.FAVOR_GIVING)return;if(t!==this.state.favorFrom)return;const i=this.state.players.find(t=>t.id===this.state.favorFrom),r=this.state.players.find(t=>t.id===this.state.favorTo);if(i&&r&&e>=0&&e<i.hand.length){const t=i.hand.splice(e,1)[0];if(t&&(r.hand.push(t),this.state.favorFrom&&this.state.favorTo)){const e=this.state.discardHistory.find(t=>t.playerId===this.state.favorTo&&t.targetPlayerId===this.state.favorFrom&&t.cards.some(t=>t[0]===s.FAVOR));e&&this.state.privateLogs.push({id:Date.now(),timestamp:Date.now(),discardEntryTimestamp:e.timestamp,visibleTo:[this.state.favorFrom,this.state.favorTo],stolenCard:t,fromPlayerId:this.state.favorFrom,toPlayerId:this.state.favorTo})}this.state.gamePhase=a.PLAYING,this.state.favorFrom=null,this.state.favorTo=null,this.checkBotTurn()}}handleReorderFuture(t,e){if(this.state.gamePhase!==a.ALTER_THE_FUTURE)return;if(this.state.players.findIndex(e=>e.id===t)!==this.state.currentTurnIndex)return;if(!this.state.alterCards)return;const s=this.state.alterCount;if(e.length!==s||!e.every((t,e,a)=>t>=0&&t<s&&a.indexOf(t)===e))return;const i=e.map(t=>this.state.alterCards[t]);this.state.drawPile.splice(this.state.drawPile.length-s,s);for(let a=i.length-1;a>=0;a--)this.state.drawPile.push(i[a]);this.state.alterCards=null,this.state.alterCount=0,this.state.gamePhase=a.PLAYING,this.checkBotTurn()}finishTurnAction(){this.state.attackStack--,this.state.attackStack<=0?this.advanceTurn():this.checkBotTurn()}advanceTurn(t=!1){const e=this.getNextPlayerIndex(this.state.currentTurnIndex);this.state.currentTurnIndex=e,t||(this.state.attackStack=1),this.checkBotTurn()}getNextPlayerIndex(t){const e=this.state.players.length;let s=t;do{s=(s+this.state.direction+e)%e}while(null===this.state.players[s].id||this.state.players[s].isExploded);return s}getNextPlayerId(t){const e=this.getNextPlayerIndex(t);return this.state.players[e].id}explodePlayer(t){const e=this.state.players[t];this.state.discardHistory.push({playerId:e.id,cards:[[s.EXPLODING_KITTEN,0]],timestamp:Date.now(),isNoped:!1}),this.state.lastAction={action:{type:"EXPLODE",playerId:e.id},playerId:e.id,timestamp:Date.now(),isNoped:!1,cardType:s.EXPLODING_KITTEN},this.state.players[t].isExploded=!0;const i=this.state.players.filter(t=>null!==t.id&&!t.isExploded);1===i.length?(this.state.winner=i[0].id,this.state.gamePhase=a.ENDED,this.clearSavedState()):(this.state.gamePhase=a.PLAYING,this.advanceTurn())}checkBotTurn(){if(!this.isHost||this.state.gamePhase===a.ENDED)return;if(this.state.gamePhase===a.FAVOR_GIVING){const t=this.state.players.find(t=>t.id===this.state.favorFrom);return void(t?.isBot&&setTimeout(()=>this.makeBotFavor(t),1e3))}if(this.state.gamePhase===a.ALTER_THE_FUTURE){const t=this.state.players[this.state.currentTurnIndex];return void(t?.isBot&&this.state.alterCards&&setTimeout(()=>{if(this.state.gamePhase===a.ALTER_THE_FUTURE){const e=Array.from({length:this.state.alterCount},(t,e)=>e);this.handleReorderFuture(t.id,e)}},1500))}if(this.state.gamePhase===a.NOPE_WINDOW){if(!this.state.pendingAction)return;return void this.state.players.forEach(t=>{if(t.isBot&&!t.isExploded&&void 0===this.state.pendingAction.responses[t.id]){t.hand.some(t=>t[0]===s.NOPE)?setTimeout(()=>{this.state.gamePhase===a.NOPE_WINDOW&&(Math.random()<.2?this.handleRespondNope(t.id,"NOPE"):this.handleRespondNope(t.id,"ALLOW"))},1e3+2e3*Math.random()):setTimeout(()=>{this.state.gamePhase===a.NOPE_WINDOW&&this.handleRespondNope(t.id,"ALLOW")},500+1e3*Math.random())}})}const t=this.state.players[this.state.currentTurnIndex];if(t?.isBot&&!t.isExploded){if(this.botActionPending)return;this.botActionPending=!0,setTimeout(()=>{this.botActionPending=!1,this.makeBotMove(t)},1500)}}makeBotMove(t){if(!this.isHost||this.state.currentTurnIndex!==this.state.players.indexOf(t))return;if(this.state.gamePhase===a.DEFUSING)return void this.handleDefuse(t.id);if(this.state.gamePhase===a.INSERTING_KITTEN||this.state.gamePhase===a.BURYING_CARD){const e=Math.floor(Math.random()*(this.state.drawPile.length+1));return void this.handleInsertCard(t.id,e)}if(this.state.gamePhase===a.ALTER_THE_FUTURE){if(this.state.alterCards){const e=this.state.alterCount,s=Array.from({length:e},(t,e)=>e);this.handleReorderFuture(t.id,s)}return}if(this.state.gamePhase!==a.PLAYING)return;const e=new Map;t.hand.forEach((t,a)=>{t[0]>=s.CAT_1&&t[0]<=s.CAT_5&&(e.has(t[0])||e.set(t[0],[]),e.get(t[0]).push(a))});for(const[a,r]of e.entries())if(r.length>=2&&Math.random()<.4){const e=r.length>=3&&Math.random()<.5?3:2,a=this.state.players.filter(e=>null!==e.id&&e.id!==t.id&&!e.isExploded);if(a.length>0){const i=a[Math.floor(Math.random()*a.length)].id,n=r.slice(0,e),h=3===e?[s.ATTACK,s.SKIP,s.FAVOR,s.SHUFFLE,s.SEE_THE_FUTURE,s.REVERSE,s.TARGETED_ATTACK,s.ALTER_THE_FUTURE_3][Math.floor(8*Math.random())]:void 0;return void this.handlePlayCombo(t.id,n,i,h)}}const i=t.hand.map((t,e)=>e).filter(e=>{const a=t.hand[e][0];return a!==s.DEFUSE&&(a!==s.EXPLODING_KITTEN&&(a!==s.NOPE&&!(a>=s.CAT_1&&a<=s.CAT_5)))});if(i.length>0&&Math.random()<.3){const e=i[Math.floor(Math.random()*i.length)],a=t.hand[e][0];let r;if(a===s.FAVOR||a===s.TARGETED_ATTACK){const e=this.state.players.filter(e=>null!==e.id&&e.id!==t.id&&!e.isExploded);if(e.length>0)r=e[Math.floor(Math.random()*e.length)].id;else if(a===s.TARGETED_ATTACK)return void this.handleDrawCard(t.id)}this.handlePlayCard(t.id,e,r)}else this.handleDrawCard(t.id)}makeBotFavor(t){if(t.hand.length>0){const e=t.hand.map((e,s)=>({index:s,value:this.getCardFavorPriority(e,t.hand),card:e}));e.sort((t,e)=>t.value-e.value);const s=e[0].value,a=e.filter(t=>t.value<=s+5),i=a[Math.floor(Math.random()*a.length)];this.handleGiveFavor(t.id,i.index)}}getCardFavorPriority(t,e){const a=t[0];let i=0;switch(a){case s.DEFUSE:i=100;break;case s.NOPE:i=90;break;case s.ATTACK:case s.TARGETED_ATTACK:i=80;break;case s.SKIP:case s.SUPER_SKIP:i=75;break;case s.ALTER_THE_FUTURE_3:case s.ALTER_THE_FUTURE_5:i=70;break;case s.SEE_THE_FUTURE:i=60;break;case s.SHUFFLE:case s.DRAW_BOTTOM:i=50;break;case s.FAVOR:i=40;break;default:i=10}return e.filter(t=>t[0]===a).length>=2&&(i+=60),i}handleAddBot(t){t<0||t>=5||this.state.gamePhase!==a.WAITING||null===this.state.players[t].id&&(this.state.players[t]={id:`BOT_${t}_${Date.now()}`,username:`Bot ${t+1}`,hand:[],isExploded:!1,isBot:!0,isHost:!1})}handleJoinSlot(t,e,s){t<0||t>=5||this.state.gamePhase!==a.WAITING||null===this.state.players[t].id&&(this.state.players.some(t=>t.id===e)||(this.state.players[t]={id:e,username:s,hand:[],isExploded:!1,isBot:!1,isHost:!1}))}handleRemovePlayer(t){t<0||t>=5||this.state.gamePhase!==a.WAITING||(this.state.players[t]={id:null,username:`Slot ${t+1}`,hand:[],isExploded:!1,isBot:!1,isHost:!1})}requestDrawCard(){this.makeAction({type:"DRAW_CARD",playerId:this.userId})}requestPlayCard(t,e){this.makeAction({type:"PLAY_CARD",playerId:this.userId,cardIndex:t,targetPlayerId:e})}requestDefuse(){this.makeAction({type:"DEFUSE",playerId:this.userId})}requestInsertKitten(t){this.makeAction({type:"INSERT_KITTEN",playerId:this.userId,index:t})}requestGiveFavor(t){this.makeAction({type:"GIVE_FAVOR",playerId:this.userId,cardIndex:t})}requestPlayCombo(t,e,s){this.makeAction({type:"PLAY_COMBO",playerId:this.userId,cardIndices:t,targetPlayerId:e,requestedCardType:s})}requestAddBot(t){this.makeAction({type:"ADD_BOT",slotIndex:t})}requestJoinSlot(t,e){this.makeAction({type:"JOIN_SLOT",slotIndex:t,playerId:this.userId,playerName:e})}requestRemovePlayer(t){this.makeAction({type:"REMOVE_PLAYER",slotIndex:t})}requestStartGame(){this.makeAction({type:"START_GAME"})}requestRespondNope(t){this.makeAction({type:"RESPOND_NOPE",playerId:this.userId,response:t})}requestReorderFuture(t){this.makeAction({type:"REORDER_FUTURE",playerId:this.userId,newOrder:t})}requestNewGame(){this.isHost?this.onSocketGameAction({action:{type:"NEW_GAME"}}):this.sendSocketGameAction({type:"REQUEST_NEW_GAME",playerId:this.userId,playerName:this.state.players.find(t=>t.id===this.userId)?.username||"Player"})}acceptNewGame(){this.onSocketGameAction({action:{type:"ACCEPT_NEW_GAME"}})}declineNewGame(){this.onSocketGameAction({action:{type:"DECLINE_NEW_GAME"}})}handleNewGameRequest(t,e){this.state.newGameRequest={fromId:t,fromName:e}}reset(){const t=this.state.players.map(t=>({...t,hand:[],isExploded:!1}));this.state={...this.getInitState(),players:t}}}const n=Object.freeze(Object.defineProperty({__proto__:null,DEFAULT_DECK_CONFIG:i,default:r},Symbol.toStringTag,{value:"Module"}));export{i as D,s as E,e as P,a,n as b};
