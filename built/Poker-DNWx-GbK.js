import{B as t}from"./BaseGame-k9e2yoZm.js";import{d as e,R as s,H as i,S as a,e as n}from"./types-qIwhz3td.js";import"./socket-DRbsQkF5.js";import"./index-DXRPlG-o.js";import"./react-vendor-CUFzUArh.js";import"./zustand-D7bLx3wD.js";class r extends t{isGameOver(t){return"ended"===t.gamePhase}deck=[];getMyPlayerIndex(){return this.state.players.findIndex(t=>t.id===this.userId)}getUserId(){return this.userId}getInitState(){const t=Array(6).fill(null).map((t,e)=>({id:null,username:`Seat ${e+1}`,hand:[],chips:1e3,currentBet:0,isBot:!1,isGuest:!1,isHost:!1,hasFolded:!1,isAllIn:!1,isDealer:!1,isSmallBlind:!1,isBigBlind:!1,isActive:!1,hasActed:!1}));return this.players&&this.players.length>0&&this.players.forEach(e=>{const s=t.findIndex(t=>null===t.id);-1!==s&&(t[s]={...t[s],id:e.id,username:e.username||`Player ${e.id.substr(0,4)}`,isHost:e.id===this.userId,chips:1e3})}),{players:t,communityCards:[],pot:0,currentBet:0,dealerIndex:0,currentTurnIndex:0,smallBlindAmount:10,bigBlindAmount:20,gamePhase:"waiting",winnerIds:[],minRaise:20}}onSocketGameAction(t){if(!this.isHost)return;const e=t.action;switch(e.type){case"START_GAME":this.startGame();break;case"ADD_BOT":this.addBot(e.slotIndex);break;case"RESET_GAME":this.resetGame();break;case"JOIN_SLOT":this.joinSlot(e.slotIndex,e.playerId,e.playerName);break;case"REMOVE_PLAYER":this.removePlayer(e.slotIndex);break;case"FOLD":this.handleFold(e.playerId);break;case"CHECK":this.handleCheck(e.playerId);break;case"CALL":this.handleCall(e.playerId);break;case"RAISE":this.handleRaise(e.playerId,e.amount);break;case"ALL_IN":this.handleAllIn(e.playerId)}}updatePlayers(t){super.updatePlayers(t),this.isHost&&(this.state.players.forEach((e,s)=>{if(e.id&&!e.isBot){t.find(t=>t.id===e.id)||this.removePlayer(s)}}),t.forEach(t=>{if(!this.state.players.some(e=>e.id===t.id)){const e=this.state.players.findIndex(t=>null===t.id);-1!==e&&(this.joinSlot(e,t.id,t.username||"Player"),t.id===this.userId&&this.isHost&&(this.state.players[e].isHost=!0))}}))}startGame(){if(this.state.players.filter(t=>null!==t.id).length<2)return;this.deck=this.createDeck(),this.shuffleDeck(this.deck),this.state.communityCards=[],this.state.pot=0,this.state.winnerIds=[],this.state.winningHand=void 0,this.state.gamePhase="pre_flop",this.state.lastAction=void 0,this.state.players.forEach(t=>{null!==t.id?(t.isActive=!0,t.hand=[],t.hasFolded=!1,t.isAllIn=!1,t.currentBet=0,t.isSmallBlind=!1,t.isBigBlind=!1,t.hasActed=!1,t.chips<=0&&(t.chips=1e3)):t.isActive=!1}),this.moveButton(),this.postBlinds(),this.dealHoleCards();const t=this.getActivePlayerIndices(),e=t.indexOf(this.state.dealerIndex);let s;s=2===t.length?e:(e+3)%t.length,this.state.currentTurnIndex=t[s],this.state.minRaise=this.state.bigBlindAmount,this.checkBotTurn()}moveButton(){const t=this.getActivePlayerIndices();if(0===t.length)return;let e=t.indexOf(this.state.dealerIndex);-1===e&&(e=0);const s=(e+1)%t.length;this.state.dealerIndex=t[s],this.state.players.forEach(t=>t.isDealer=!1),this.state.players[this.state.dealerIndex].isDealer=!0}postBlinds(){const t=this.getActivePlayerIndices(),e=t.indexOf(this.state.dealerIndex);let s,i;2===t.length?(s=e,i=(e+1)%2):(s=(e+1)%t.length,i=(e+2)%t.length);const a=t[s],n=this.state.players[a],r=Math.min(n.chips,this.state.smallBlindAmount);n.chips-=r,n.currentBet=r,n.isSmallBlind=!0,this.state.pot+=r;const h=t[i],l=this.state.players[h],d=Math.min(l.chips,this.state.bigBlindAmount);l.chips-=d,l.currentBet=d,l.isBigBlind=!0,this.state.pot+=d,this.state.currentBet=this.state.bigBlindAmount}dealHoleCards(){this.state.players.forEach(t=>{t.isActive&&(t.hand=[this.deck.pop(),this.deck.pop()])})}nextPhase(){switch(this.state.players.forEach(t=>{t.currentBet=0,t.hasActed=!1}),this.state.currentBet=0,this.state.minRaise=this.state.bigBlindAmount,this.state.lastAction=void 0,this.state.gamePhase){case"pre_flop":this.dealCommunityCards(3),this.state.gamePhase="flop";break;case"flop":this.dealCommunityCards(1),this.state.gamePhase="turn";break;case"turn":this.dealCommunityCards(1),this.state.gamePhase="river";break;case"river":return void this.showdown()}if(0===this.getActivePlayerIndices().filter(t=>!this.state.players[t].hasFolded&&!this.state.players[t].isAllIn).length)return void this.runRemainingPhases();let t=(this.state.dealerIndex+1)%6;for(;(!this.state.players[t].isActive||this.state.players[t].hasFolded||this.state.players[t].isAllIn)&&(t=(t+1)%6,t!==this.state.dealerIndex););this.state.currentTurnIndex=t,this.checkBotTurn()}runRemainingPhases(){for(;"ended"!==this.state.gamePhase;)if("pre_flop"===this.state.gamePhase)this.dealCommunityCards(3),this.state.gamePhase="flop";else if("flop"===this.state.gamePhase)this.dealCommunityCards(1),this.state.gamePhase="turn";else if("turn"===this.state.gamePhase)this.dealCommunityCards(1),this.state.gamePhase="river";else if("river"===this.state.gamePhase)return void this.showdown()}dealCommunityCards(t){for(let e=0;e<t;e++)this.deck.length>0&&this.state.communityCards.push(this.deck.pop())}showdown(){this.state.gamePhase="showdown";const t=this.state.players.filter(t=>t.isActive&&!t.hasFolded);if(0===t.length)return;if(1===t.length){const e=t[0];return this.state.winnerIds=[e.id],e.chips+=this.state.pot,this.state.pot=0,void(this.state.gamePhase="ended")}let e,s=-1,i=[];for(const r of t){const t=this.evaluateHand(r.hand,this.state.communityCards),a=this.getHandValue(t);a>s?(s=a,i=[r],e=t):a===s&&i.push(r)}this.state.winnerIds=i.map(t=>t.id),this.state.winningHand=e;const a=Math.floor(this.state.pot/i.length);i.forEach(t=>t.chips+=a);const n=this.state.pot%i.length;n>0&&i.length>0&&(i[0].chips+=n),this.state.pot=0,this.state.gamePhase="ended"}evaluateHand(t,a){const n=[...t,...a];n.sort((t,s)=>e(s).rank-e(t).rank);const r={};n.forEach(t=>{const{suit:s}=e(t);r[s]||(r[s]=[]),r[s].push(t)});let h=-1;Object.keys(r).forEach(t=>{r[Number(t)].length>=5&&(h=Number(t))});const l=Array.from(new Set(n.map(t=>e(t).rank))).sort((t,e)=>e-t);let d=-1;for(let e=0;e<=l.length-5;e++)if(l[e]-l[e+4]===4){d=l[e];break}if(-1===d&&l.includes(s.ACE)&&l.includes(s.TWO)&&l.includes(s.THREE)&&l.includes(s.FOUR)&&l.includes(s.FIVE)&&(d=5),-1!==h){const t=r[h],a=Array.from(new Set(t.map(t=>e(t).rank))).sort((t,e)=>e-t);for(let e=0;e<=a.length-5;e++)if(a[e]-a[e+4]===4)return a[e]===s.ACE?{rank:i.ROYAL_FLUSH,cards:t.slice(e,e+5),kickers:[],name:"Royal Flush"}:{rank:i.STRAIGHT_FLUSH,cards:t.slice(e,e+5),kickers:[],name:"Straight Flush"};if(a.includes(s.ACE)&&a.includes(s.TWO)&&a.includes(s.THREE)&&a.includes(s.FOUR)&&a.includes(s.FIVE)){const s=t.filter(t=>[14,2,3,4,5].includes(e(t).rank)).slice(0,5);return{rank:i.STRAIGHT_FLUSH,cards:s,kickers:[],name:"Straight Flush (Low)"}}}const c={};n.forEach(t=>{const{rank:s}=e(t);c[s]||(c[s]=[]),c[s].push(t)});const o=Object.keys(c).map(Number).sort((t,e)=>e-t),u=o.filter(t=>4===c[t].length),p=o.filter(t=>3===c[t].length),m=o.filter(t=>2===c[t].length);if(u.length>0){const t=u[0],s=c[t],a=n.find(s=>e(s).rank!==t);return{rank:i.FOUR_OF_A_KIND,cards:[...s,a],kickers:[a],name:"Four of a Kind"}}if(p.length>0&&m.length>0||p.length>1){const t=p[0],e=p.length>1?p[1]:m[0];return{rank:i.FULL_HOUSE,cards:[...c[t],...c[e].slice(0,2)],kickers:[],name:"Full House"}}if(-1!==h){const t=r[h];return{rank:i.FLUSH,cards:t.slice(0,5),kickers:[],name:"Flush"}}if(-1!==d){let t=[];if(5===d){t=[5,4,3,2,s.ACE].map(t=>n.find(s=>e(s).rank===t))}else for(let s=0;s<5;s++)t.push(n.find(t=>e(t).rank===d-s));return{rank:i.STRAIGHT,cards:t,kickers:[],name:"Straight"}}if(p.length>0){const t=p[0],s=n.filter(s=>e(s).rank!==t).slice(0,2);return{rank:i.THREE_OF_A_KIND,cards:[...c[t],...s],kickers:s,name:"Three of a Kind"}}if(m.length>0){if(m.length>=2){const t=m[0],s=m[1],a=n.find(i=>e(i).rank!==t&&e(i).rank!==s);return{rank:i.TWO_PAIR,cards:[...c[t],...c[s],a],kickers:[a],name:"Two Pair"}}{const t=m[0],s=n.filter(s=>e(s).rank!==t).slice(0,3);return{rank:i.PAIR,cards:[...c[t],...s],kickers:s,name:"Pair"}}}return{rank:i.HIGH_CARD,cards:n.slice(0,5),kickers:n.slice(1,5),name:"High Card"}}getHandValue(t){let s=1e10*t.rank;return t.cards.forEach((t,i)=>{s+=e(t).rank*Math.pow(15,4-i)}),s}createDeck(){const t=[];for(const e of[a.SPADE,a.CLUB,a.DIAMOND,a.HEART])for(let i=s.TWO;i<=s.ACE;i++)t.push(n(i,e));return t}shuffleDeck(t){for(let e=t.length-1;e>0;e--){const s=Math.floor(Math.random()*(e+1));[t[e],t[s]]=[t[s],t[e]]}return t}addBot(t){const e=this.state.players[t];null===e.id&&(e.id=`BOT_${Date.now()}_${t}`,e.username=`Bot ${t+1}`,e.isBot=!0,e.chips=1e3)}resetGame(){this.state.gamePhase="waiting",this.state.communityCards=[],this.state.pot=0,this.state.currentBet=0,this.state.winnerIds=[],this.state.winningHand=void 0,this.state.lastAction=void 0,this.state.players.forEach(t=>{t.hand=[],t.isActive=!1,t.hasFolded=!1,t.isAllIn=!1,t.currentBet=0,t.hasActed=!1,t.isDealer=!1,t.isSmallBlind=!1,t.isBigBlind=!1,null!==t.id&&(t.chips=1e3)})}joinSlot(t,e,s){if(null!==this.state.players[t].id)return;const i=this.state.players.findIndex(t=>t.id===e);-1!==i&&this.removePlayer(i);const a=this.state.players[t];a.id=e,a.username=s,a.isBot=!1,a.isGuest=!1,a.chips=1e3}removePlayer(t){const e=this.state.players[t];e.id=null,e.username=`Seat ${t+1}`,e.hand=[],e.chips=1e3,e.currentBet=0,e.isBot=!1,e.isGuest=!1,e.isHost=!1,e.hasFolded=!1,e.isAllIn=!1,e.isDealer=!1,e.isSmallBlind=!1,e.isBigBlind=!1,e.isActive=!1,e.hasActed=!1}requestStartGame(){this.makeAction({type:"START_GAME"})}requestResetGame(){this.makeAction({type:"RESET_GAME"})}requestAddBot(t){this.makeAction({type:"ADD_BOT",slotIndex:t})}requestJoinSlot(t,e){this.makeAction({type:"JOIN_SLOT",slotIndex:t,playerId:this.userId,playerName:e})}requestRemovePlayer(t){this.makeAction({type:"REMOVE_PLAYER",slotIndex:t})}requestFold(){this.makeAction({type:"FOLD",playerId:this.userId})}requestCheck(){this.makeAction({type:"CHECK",playerId:this.userId})}requestCall(){this.makeAction({type:"CALL",playerId:this.userId})}requestRaise(t){this.makeAction({type:"RAISE",playerId:this.userId,amount:t})}requestAllIn(){this.makeAction({type:"ALL_IN",playerId:this.userId})}handleFold(t){if(!this.isPlayerTurn(t))return;const e=this.state.players[this.state.currentTurnIndex];e.hasFolded=!0,e.hasActed=!0,e.isActive=!1;const s=this.state.players.filter(t=>t.isActive&&!t.hasFolded);1===s.length?this.endHandWithWinner(s[0]):this.advanceTurn()}handleCheck(t){if(!this.isPlayerTurn(t))return;const e=this.state.players[this.state.currentTurnIndex];this.state.currentBet>e.currentBet||(e.hasActed=!0,this.advanceTurn())}handleCall(t){if(!this.isPlayerTurn(t))return;const e=this.state.players[this.state.currentTurnIndex],s=this.state.currentBet-e.currentBet;s>e.chips?this.handleAllIn(t):(e.chips-=s,e.currentBet+=s,this.state.pot+=s,e.hasActed=!0,this.advanceTurn())}handleRaise(t,e){if(!this.isPlayerTurn(t))return;const s=this.state.players[this.state.currentTurnIndex];if(e<this.state.currentBet+this.state.minRaise)return;if(e>s.chips+s.currentBet)return;const i=e-s.currentBet;s.chips-=i,s.currentBet=e,this.state.pot+=i;const a=e-this.state.currentBet;a>=this.state.minRaise&&(this.state.minRaise=a),this.state.currentBet=e,this.state.lastAction={playerId:t,action:"Raise",amount:e},s.hasActed=!0,this.advanceTurn()}handleAllIn(t){if(!this.isPlayerTurn(t))return;const e=this.state.players[this.state.currentTurnIndex],s=e.chips;if(e.chips=0,e.currentBet+=s,this.state.pot+=s,e.isAllIn=!0,e.currentBet>this.state.currentBet){const s=e.currentBet-this.state.currentBet;s>this.state.minRaise&&(this.state.minRaise=s),this.state.currentBet=e.currentBet,this.state.lastAction={playerId:t,action:"All In",amount:e.currentBet}}e.hasActed=!0,this.advanceTurn()}advanceTurn(){if(this.checkBettingRoundComplete())return void this.nextPhase();let t=(this.state.currentTurnIndex+1)%6,e=0;for(;(null===this.state.players[t].id||this.state.players[t].hasFolded||this.state.players[t].isAllIn)&&e<6;)t=(t+1)%6,e++;this.state.currentTurnIndex=t,this.checkBotTurn()}checkBettingRoundComplete(){const t=this.state.players.filter(t=>t.isActive&&!t.hasFolded);return!!t.every(t=>t.currentBet===this.state.currentBet||t.isAllIn)&&t.every(t=>(t.currentBet===this.state.currentBet||t.isAllIn)&&this.hasPlayerActed(t))}hasPlayerActed(t){return t.isActive&&(t.hasFolded||t.isAllIn||t.hasActed)}isPlayerTurn(t){const e=this.state.players[this.state.currentTurnIndex];return e&&e.id===t}getActivePlayerIndices(){return this.state.players.map((t,e)=>({p:t,i:e})).filter(t=>null!==t.p.id).map(t=>t.i)}endHandWithWinner(t){this.state.winnerIds=[t.id],t.chips+=this.state.pot,this.state.pot=0,this.state.gamePhase="ended"}checkBotTurn(){if(!this.isHost)return;const t=this.state.players[this.state.currentTurnIndex];t&&t.isBot&&t.isActive&&!t.hasFolded&&!t.isAllIn&&setTimeout(()=>{this.handleBotMove(t)},1e3)}handleBotMove(t){if("ended"===this.state.gamePhase)return;const s=this.evaluateHand(t.hand,this.state.communityCards),a=this.state.currentBet-t.currentBet;if(0===a)return void this.handleCheck(t.id);const n=a/t.chips;if(s.rank>=i.TWO_PAIR){if(t.chips>2*a){const e=this.state.currentBet+Math.min(t.chips,this.state.minRaise);return void this.handleRaise(t.id,e)}this.handleAllIn(t.id)}else s.rank>=i.PAIR||"pre_flop"===this.state.gamePhase&&e(t.hand[0]).rank+e(t.hand[1]).rank>20?this.handleCall(t.id):n>.02?this.handleFold(t.id):this.handleCall(t.id)}}export{r as default};
