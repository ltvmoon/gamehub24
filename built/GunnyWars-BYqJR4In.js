import{B as e}from"./BaseGame-C5gQy5jq.js";import{W as t,a as n,T as i,b as o,B as a,S as r,c as s,D as l,P as d,M as h,d as c,G as u,e as f,F as m,f as p,g,h as y,i as v,j as x,k as T,l as S,I as M,m as C,n as k}from"./constants-hPz3V5GY.js";import"./socket-DRbsQkF5.js";import"./index-C2uk-7Ac.js";import"./react-vendor-oAIxreiG.js";import"./zustand-BCVlJ__8.js";function b(e,t){let n=.1031*e+.3117*t;return n-=Math.floor(n),n*=n+33.33,n*=n+n,n-Math.floor(n)}function R(e,t){const n=Math.floor(e),i=e-n,o=i*i*(3-2*i);return b(n,t)*(1-o)+b(n+1,t)*o}function w(e,t){const n=function(e,t,n=4){let i=0,o=.5,a=1;for(let r=0;r<n;r++)i+=o*R(e*a,t+100*r),o*=.5,a*=2;return i}(e*a,t,2);return n<.1?2:n<.2?0:n<.3?1:n<.4?3:n<.5?5:n<.6?6:4}function _(e,t,n,o){const a=o.nx,r=o.ny;if(void 0===a||void 0===r)return!1;const s=i.getX(n),l=i.getY(n),d=i.getLength(n)||100,h=o.radiusSq,c=a*d,u=r*d,f=d*d;if(0===f){return(e-s)**2+(t-l)**2<=h}let m=((e-s)*c+(t-l)*u)/f;m=Math.max(0,Math.min(1,m));return(e-(s+m*c))**2+(t-(l+m*u))**2<=h}class I{bounds;entries=[];children=null;depth;static MAX_ENTRIES=8;static MAX_DEPTH=12;constructor(e,t=0){this.bounds=e,this.depth=t}insert(e){if(this.intersectsBounds(e.bounds))if(this.children)for(const t of this.children)t.intersectsBounds(e.bounds)&&t.insert(e);else this.entries.push(e),this.entries.length>I.MAX_ENTRIES&&this.depth<I.MAX_DEPTH&&this.split()}queryPoint(e,t){if(!this.containsPoint(e,t))return[];const n=[];for(const i of this.entries)this.pointInModification(e,t,i)&&n.push(i);if(this.children)for(const i of this.children)n.push(...i.queryPoint(e,t));return n}queryCircle(e,t,n){const i={x:e-n,y:t-n,width:2*n,height:2*n};if(!this.intersectsBounds(i))return[];const o=[];for(const a of this.entries)o.push(a);if(this.children)for(const a of this.children)o.push(...a.queryCircle(e,t,n));return o}clear(){this.entries=[],this.children=null}split(){const{x:e,y:t,width:n,height:i}=this.bounds,o=n/2,a=i/2;this.children=[new I({x:e,y:t,width:o,height:a},this.depth+1),new I({x:e+o,y:t,width:o,height:a},this.depth+1),new I({x:e,y:t+a,width:o,height:a},this.depth+1),new I({x:e+o,y:t+a,width:o,height:a},this.depth+1)];for(const r of this.entries)for(const e of this.children)e.intersectsBounds(r.bounds)&&e.insert(r)}containsPoint(e,t){return e>=this.bounds.x&&e<this.bounds.x+this.bounds.width&&t>=this.bounds.y&&t<this.bounds.y+this.bounds.height}intersectsBounds(e){return!(e.x>this.bounds.x+this.bounds.width||e.x+e.width<this.bounds.x||e.y>this.bounds.y+this.bounds.height||e.y+e.height<this.bounds.y)}pointInModification(e,t,n){const a=n.modification,r=i.getType(a),s=i.getX(a),l=i.getY(a),d=n.derived;if(r===o.CARVE)return _(e,t,a,d);const h=e-s,c=t-l;return h*h+c*c<=d.radiusSq}}class A{seed;quadtree;modificationCounter=0;modifications=[];bounds;static CACHE_SIZE=4096;static CACHE_MASK=4095;baseHeightCache=new Float32Array(A.CACHE_SIZE);baseHeightKeys=new Int32Array(A.CACHE_SIZE).fill(-999999);constructor(e,i=2*t,o=2*n){this.seed=e,this.bounds={x:-i/2,y:-o/2,width:2*i,height:2*o},this.quadtree=new I(this.bounds)}getBaseHeight(e){const i=Math.round(e),o=i&A.CACHE_MASK;if(this.baseHeightKeys[o]===i)return this.baseHeightCache[o];const a=function(e,i){const o=t,a=n;let r=a/1.6+(300*Math.sin(.001*(e+i))+80*Math.sin(.005*(e+2*i))+20*Math.sin(.02*(e+3*i)))+-200*Math.sin(e/o*Math.PI*5+i);return r=Math.max(200,Math.min(a-100,r)),r}(e,this.seed);return this.baseHeightKeys[o]=i,this.baseHeightCache[o]=a,a}getTerrainHeight(e){const t=this.getBaseHeight(e),a=this.quadtree.queryCircle(e,t/2,t/2+100);if(0===a.length)return t;let r=t;for(const n of a)if(i.getType(n.modification)===o.ADD){const e=i.getY(n.modification)-i.getRadius(n.modification);e<r&&(r=e)}for(let i=Math.max(0,Math.floor(r));i<n;i+=4)if(this.isSolidFast(e,i,t)){for(let n=Math.max(0,i-4);n<=i;n++)if(this.isSolidFast(e,n,t))return n;return i}return t}isSolid(e,t){if(t>=n||t<0)return!1;const i=this.getBaseHeight(e);return this.isSolidFast(e,t,i)}isSolidFast(e,t,a){if(t>=n||t<0)return!1;let r=t>=a;const s=this.quadtree.queryPoint(e,t);if(0===s.length)return r;s.length>1&&s.sort((e,t)=>e.timestamp-t.timestamp);for(let n=0;n<s.length;n++){const a=s[n],l=a.modification,d=i.getType(l),h=e-i.getX(l),c=t-i.getY(l),u=h*h+c*c,f=a.derived;d===o.DESTROY?u<=f.radiusSq&&(r=!1):d===o.ADD?u<=f.radiusSq&&(r=!0):d===o.CARVE&&_(e,t,l,f)&&(r=!1)}return r}destroyCircle(e,t,n){const a=i.create(o.DESTROY,e,t,n);this.addModification(a)}addCircle(e,t,n){const a=i.create(o.ADD,e,t,n);this.addModification(a)}carveTunnel(e,t,n,a,r,s=100){const l=i.create(o.CARVE,e,t,r,n,a,s);this.addModification(l)}getModifications(){return[...this.modifications]}applyModifications(e,t=!0){t&&(this.quadtree.clear(),this.modifications=[],this.modificationCounter=0,this.baseHeightKeys.fill(-999999));for(const n of e)this.addModification(n)}reset(e){this.seed=e,this.quadtree.clear(),this.modifications=[],this.modificationCounter=0,this.baseHeightKeys.fill(-999999)}addModification(e){const t={modification:e,bounds:this.getModificationBounds(e),timestamp:this.modificationCounter++,derived:this.computeDerivedData(e)};this.quadtree.insert(t),this.modifications.push(e)}computeDerivedData(e){const t=i.getRadius(e),n=i.getVx(e),o=i.getVy(e),a={radiusSq:t*t};if(void 0!==n&&void 0!==o){const e=Math.hypot(n,o);e>0&&(a.nx=n/e,a.ny=o/e)}return a}getModificationBounds(e){const t=i.getType(e),n=i.getX(e),a=i.getY(e),r=i.getRadius(e);if(t===o.CARVE){const t=i.getVx(e),o=i.getVy(e);if(void 0!==t&&void 0!==o){const s=Math.sqrt(t*t+o*o);if(s>0){const l=t/s,d=o/s,h=i.getLength(e)||100,c=n+l*h,u=a+d*h,f=Math.min(n,c)-r,m=Math.max(n,c)+r,p=Math.min(a,u)-r;return{x:f,y:p,width:m-f,height:Math.max(a,u)+r-p}}}}return{x:n-r,y:a-r,width:2*r,height:2*r}}getSeed(){return this.seed}}const P=256;class E{chunks=new Map;dirtyChunks=new Set;chunkAccessOrder=[];skyChunks=new Set;clearCache(){this.chunks.clear(),this.dirtyChunks.clear(),this.chunkAccessOrder=[],this.skyChunks.clear()}isChunkSkyOnly(e,t,n){const a=e*P,r=(t+1)*P;for(let i=0;i<=P;i+=32){const e=a+i;if(n.getBaseHeight(e)<r)return!1}const s=n.getModifications();for(const l of s)if(i.getType(l)===o.ADD){const e=i.getX(l),n=i.getY(l),o=i.getRadius(l);if(e+o>=a&&e-o<=a+P&&n+o>=t*P&&n-o<=r)return!1}return!0}renderVisibleChunks(e,t,n,i,o,a,r){const s=i/a,l=o/a,d=Math.floor(t/P),h=Math.ceil((t+s)/P),c=Math.floor(n/P),u=Math.ceil((n+l)/P);let f=0;const m=t+s/2,p=n+l/2,g=[];for(let y=d;y<=h;y++)for(let t=c;t<=u;t++){const n=`${y},${t}`;if(!this.skyChunks.has(n)||this.dirtyChunks.has(n))if(this.chunks.has(n)||this.dirtyChunks.has(n)||!this.isChunkSkyOnly(y,t,r))if(!this.chunks.has(n)||this.dirtyChunks.has(n)){const e=(y+.5)*P,i=(t+.5)*P,o=Math.abs(e-m)+Math.abs(i-p);g.push({cx:y,cy:t,key:n,dist:o})}else{const i=this.chunks.get(n);if(i){const o=y*P-.5,a=t*P-.5;e.drawImage(i,o,a,257,257),this.updateLRU(n)}}else this.skyChunks.add(n)}g.sort((e,t)=>e.dist-t.dist);for(const{cx:y,cy:v,key:x}of g){if(f>=4)break;if(this.dirtyChunks.has(x)&&(this.skyChunks.delete(x),this.isChunkSkyOnly(y,v,r))){this.skyChunks.add(x),this.dirtyChunks.delete(x),this.chunks.delete(x);continue}this.generateChunk(y,v,r),this.dirtyChunks.delete(x),f++;const t=this.chunks.get(x);if(t){const n=y*P-.5,i=v*P-.5;e.drawImage(t,n,i,257,257),this.updateLRU(x)}}this.pruneChunks()}invalidateArea(e,t,n){const i=Math.floor((e-n)/P),o=Math.ceil((e+n)/P),a=Math.floor((t-n)/P),r=Math.ceil((t+n)/P);for(let s=i;s<=o;s++)for(let e=a;e<=r;e++)this.dirtyChunks.add(`${s},${e}`)}invalidateTunnel(e,t,n,i,o,a){const r=Math.sqrt(n*n+i*i);if(0===r)return void this.invalidateArea(e,t,o);const s=e+n/r*a,l=t+i/r*a,d=Math.min(e,s)-o,h=Math.max(e,s)+o,c=Math.min(t,l)-o,u=Math.max(t,l)+o,f=Math.floor(d/P),m=Math.ceil(h/P),p=Math.floor(c/P),g=Math.ceil(u/P);for(let y=f;y<=m;y++)for(let e=p;e<=g;e++)this.dirtyChunks.add(`${y},${e}`)}clear(){this.chunks.clear(),this.dirtyChunks.clear(),this.chunkAccessOrder=[],this.skyChunks.clear()}generateChunk(e,t,i){const o=`${e},${t}`;let a=this.chunks.get(o);a||(a=document.createElement("canvas"),a.width=P,a.height=P,this.chunks.set(o,a));const r=a.getContext("2d");r.clearRect(0,0,P,P);const s=e*P,l=t*P,d=new Float32Array(257);for(let n=0;n<=P;n++)d[n]=i.getBaseHeight(s+n);const h={0:["#475569","#0f172a","#22c55e","#86efac"],1:["#737373","#262626","#a3a3a3","#e5e5e5"],2:["#2e4f36","#1a2e22","#166534","#4ade80"],3:["#d4a574","#8b4513","#d4a574","#f4d08a"],4:["#d1d5db","#5b6e80","#e5e7eb","#f9fafb"]},c=h[w(s+128,i.getSeed())]||h[0];r.beginPath();let u=!1;for(let n=0;n<=P;n++){const e=d[n]-l;e<=P&&(u?r.lineTo(n,Math.max(0,e)):(r.moveTo(n,Math.max(0,e)),u=!0))}r.lineTo(P,P),r.lineTo(0,P),r.closePath();const f=-l,m=n-l,p=r.createLinearGradient(0,f,0,m);p.addColorStop(0,c[0]),p.addColorStop(1,c[1]),r.fillStyle=p,r.fill(),r.globalCompositeOperation="source-atop";for(let n=0;n<15;n++){const e=4*Math.random()+1,t=Math.random()*P,n=Math.random()*P;r.fillStyle=Math.random()>.5?"rgba(0,0,0,0.2)":"rgba(255,255,255,0.05)",r.beginPath(),r.arc(t,n,e,0,2*Math.PI),r.fill()}r.globalCompositeOperation="source-over",r.beginPath();for(let n=0;n<=P;n++){const e=d[n]-l;0===n?r.moveTo(n,e):r.lineTo(n,e)}r.strokeStyle=c[2],r.lineWidth=15,r.lineCap="round",r.stroke(),r.strokeStyle=c[3],r.lineWidth=4,r.stroke(),this.applyModifications(r,s,l,i)}applyModifications(e,t,n,a){const r=a.getModifications();for(const s of r){const a=i.getType(s),r=i.getX(s),l=i.getY(s),d=i.getRadius(s),h=r-t,c=l-n,u=d+20;if(h<-u||h>P+u||c<-u||c>P+u){const e=i.getVx(s),t=i.getVy(s);if(a!==o.CARVE||void 0===e||void 0===t)continue;{const n=Math.sqrt(e*e+t*t);if(n>0){const o=e/n,a=t/n,r=i.getLength(s)||100,l=h+o*r,u=c+a*r,f=Math.min(h,l)-d,m=Math.max(h,l)+d,p=Math.min(c,u)-d,g=Math.max(c,u)+d;if(m<0||f>P||g<0||p>P)continue}}}if(a===o.DESTROY){e.save(),e.globalCompositeOperation="destination-out",e.beginPath();for(let t=0;t<2*Math.PI;t+=.2){const n=d*(.9+.2*Math.random()),i=h+Math.cos(t)*n,o=c+Math.sin(t)*n;0===t?e.moveTo(i,o):e.lineTo(i,o)}e.closePath(),e.fillStyle="#000",e.fill(),e.restore(),e.save(),e.globalCompositeOperation="source-atop",e.beginPath(),e.arc(h,c,d+10,0,2*Math.PI),e.fillStyle="rgba(0, 0, 0, 0.5)",e.fill(),e.restore()}else if(a===o.ADD)e.save(),e.globalCompositeOperation="source-over",e.beginPath(),e.arc(h,c,d,0,2*Math.PI),e.fillStyle="#64748b",e.fill(),e.lineWidth=2,e.strokeStyle="#94a3b8",e.stroke(),e.restore();else if(a===o.CARVE){const t=i.getVx(s),n=i.getVy(s);if(void 0!==t&&void 0!==n){const o=Math.sqrt(t*t+n*n);if(0===o)continue;const a=t/o,r=n/o,l=i.getLength(s)||100;e.save(),e.globalCompositeOperation="destination-out",e.lineWidth=2*d,e.lineCap="round",e.beginPath(),e.moveTo(h,c),e.lineTo(h+a*l,c+r*l),e.stroke(),e.restore(),e.save(),e.globalCompositeOperation="source-atop",e.lineWidth=2*d+10,e.lineCap="round",e.strokeStyle="rgba(0,0,0,0.5)",e.beginPath(),e.moveTo(h,c),e.lineTo(h+a*l,c+r*l),e.stroke(),e.restore()}}}}updateLRU(e){const t=this.chunkAccessOrder.indexOf(e);t>=0&&this.chunkAccessOrder.splice(t,1),this.chunkAccessOrder.push(e)}pruneChunks(){for(;this.chunks.size>64&&this.chunkAccessOrder.length>0;){const e=this.chunkAccessOrder.shift();this.chunks.delete(e),console.log("Pruned chunk",e)}}}const D=`#version 300 es\nprecision highp float;\n\nuniform float u_seed;\nuniform vec2 u_cameraPos;\nuniform vec2 u_viewSize;\nuniform float u_zoom;\nuniform vec2 u_worldSize;\nuniform sampler2D u_modTexture;\nuniform int u_modCount;\nuniform float u_time;\nuniform sampler2D u_biomeTexture;\n\nout vec4 fragColor;\n\n// === Biome constants (must match CPU) ===\nconst float BIOME_SCALE = ${a.toFixed(10)};\nconst float SNOW_THRESHOLD = ${r.toFixed(1)};\n\n// Biome indices: 0=plains, 1=mountains, 2=valley, 3=desert, 4=tundra\n\n// === Noise functions ===\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat hash1D(float x, float seed) {\n  float p = x * 0.1031 + seed * 0.3117;\n  p = fract(p);\n  p *= p + 33.33;\n  p *= p + p;\n  return fract(p);\n}\n\nfloat noise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  f = f * f * (3.0 - 2.0 * f);\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nfloat noise1D(float x, float seed) {\n  float i = floor(x);\n  float f = fract(x);\n  float u = f * f * (3.0 - 2.0 * f);\n  return hash1D(i, seed) * (1.0 - u) + hash1D(i + 1.0, seed) * u;\n}\n\nfloat fbm(vec2 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * noise(p);\n    p *= 2.0;\n    amplitude *= 0.5;\n  }\n  return value;\n}\n\nfloat fbm1D(float x, float seed, int octaves) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n  for (int i = 0; i < octaves; i++) {\n    value += amplitude * noise1D(x * frequency, seed + float(i) * 100.0);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\n// === Biome detection (OPTIMIZED: Uses pre-calculated texture) ===\nint getBiomeIndex(float x) {\n  int chunkIdx = int(floor(x / 256.0));\n  // Limit to available chunks in texture (e.g. 1024)\n  chunkIdx = clamp(chunkIdx, 0, 1023);\n  float biomeNoise = texelFetch(u_biomeTexture, ivec2(chunkIdx, 0), 0).r;\n\n  if (biomeNoise < 0.1) return 2; // Valley\n  if (biomeNoise < 0.2) return 0; // Plains\n  if (biomeNoise < 0.3) return 1; // Mountains\n  if (biomeNoise < 0.4) return 3; // Desert\n  if (biomeNoise < 0.5) return 5; // Swamp\n  if (biomeNoise < 0.6) return 6; // Volcanic\n  return 4; // Tundra\n}\n\n// === Simple terrain height (MUST MATCH CPU exactly!) ===\nfloat computeBaseHeight(float x) {\n  // Frequencies\n  float f1 = 0.001;\n  float f2 = 0.005;\n  float f3 = 0.02;\n\n  // Amplitudes\n  float a1 = 300.0;\n  float a2 = 80.0;\n  float a3 = 20.0;\n\n  // Noise from sine waves\n  float terrainNoise =\n    sin((x + u_seed) * f1) * a1 +\n    sin((x + u_seed * 2.0) * f2) * a2 +\n    sin((x + u_seed * 3.0) * f3) * a3;\n\n  // Mountain features\n  float mountain = sin((x / u_worldSize.x) * 3.14159265 * 5.0 + u_seed) * -200.0;\n\n  float y = u_worldSize.y / 1.6 + terrainNoise + mountain;\n\n  // Clamp to ensure playable area\n  return clamp(y, 200.0, u_worldSize.y - 100.0);\n}\n\n// === Modification Noise (for organic edges) ===\nfloat getModificationRadius(float modX, float modY, float modRadius, float px, float py) {\n  float dx = px - modX;\n  float dy = py - modY;\n  float angle = atan(dy, dx);\n  vec2 noisePos = vec2(modX + modY * 0.37, angle * 3.0 + modRadius * 0.1);\n  float edgeNoise = fbm(noisePos * 0.5) * 0.3 + 0.85;\n  float detailNoise = noise(vec2(angle * 8.0 + modX, modY * 0.1)) * 0.15;\n  return modRadius * (edgeNoise + detailNoise);\n}\n\n// === Tunnel check ===\nbool isInTunnel(float px, float py, float sx, float sy, float nx, float ny, float radius, float tLen) {\n  float dx = nx * tLen;\n  float dy = ny * tLen;\n  float len2 = tLen * tLen;\n\n  if (len2 == 0.0) {\n    float d = length(vec2(px - sx, py - sy));\n    return d <= getModificationRadius(sx, sy, radius, px, py);\n  }\n\n  float t = clamp(((px - sx) * dx + (py - sy) * dy) / len2, 0.0, 1.0);\n  float closestX = sx + t * dx;\n  float closestY = sy + t * dy;\n\n  // For the segment ends (caps), use the end points for noise to avoid stretching\n  // For the middle of the tunnel, use the start point for consistent noise seed\n  float d = length(vec2(px - closestX, py - closestY));\n  return d <= getModificationRadius(sx, sy, radius, px, py);\n}\n\n// === Crater check ===\nbool isInCrater(float worldX, float worldY, float modX, float modY, float modRadius, out float edgeDist) {\n  float dx = worldX - modX;\n  float dy = worldY - modY;\n  float distSq = dx * dx + dy * dy;\n\n  // Fast path for central solid area\n  if (distSq < modRadius * modRadius * 0.49) {\n    edgeDist = sqrt(distSq) - modRadius;\n    return true;\n  }\n\n  float dist = sqrt(distSq);\n  float irregularRadius = getModificationRadius(modX, modY, modRadius, worldX, worldY);\n  edgeDist = dist - irregularRadius;\n  return dist <= irregularRadius;\n}\n\n// === Star field ===\nfloat star(vec2 uv, float layer) {\n  vec2 id = floor(uv);\n  vec2 gridUV = fract(uv);\n  float starLight = 0.0;\n  for (int y = -1; y <= 1; y++) {\n    for (int x = -1; x <= 1; x++) {\n      vec2 neighbor = vec2(float(x), float(y));\n      vec2 cellId = id + neighbor;\n      vec2 starPos = neighbor + vec2(hash(cellId + layer * 17.0), hash(cellId + layer * 31.0 + 50.0)) * 0.8 + 0.1;\n      float starPresent = step(0.92, hash(cellId + layer * 47.0));\n      if (starPresent < 0.5) continue;\n      float d = length(gridUV - starPos);\n      // Increased size to match CPU (0.5 to 2.5px)\n      // UV is screenPos/40.0, so 0.02 is 0.8px, 0.06 is 2.4px\n      float size = hash(cellId + layer * 63.0) * 0.04 + 0.012;\n      float glow = exp(-d * d / (size * size * 2.0));\n      float brightness = hash(cellId + layer * 79.0) * 0.7 + 0.3;\n      starLight += glow * brightness;\n    }\n  }\n  return clamp(starLight, 0.0, 1.0);\n}\n\n// === Procedural Clouds ===\nfloat cloudNoise(vec2 uv) {\n  float n = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n  for (int i = 0; i < 5; i++) {\n    n += amplitude * noise(uv * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return n;\n}\n\nvec4 getCloud(vec2 uv, float layer) {\n  // Cloud shape using layered noise\n  float cloudShape = cloudNoise(uv * 0.15 + layer * 50.0);\n  cloudShape += cloudNoise(uv * 0.4 + layer * 30.0) * 0.4;\n  cloudShape += cloudNoise(uv * 0.8 + layer * 10.0) * 0.2;\n\n  // Higher threshold = fewer, more distinct clouds\n  float cloudDensity = smoothstep(0.55, 0.75, cloudShape);\n\n  // Only render where there's actually a cloud (sparse)\n  if (cloudDensity < 0.01) {\n    return vec4(0.0);\n  }\n\n  // Cloud brightness variation\n  float brightness = 0.85 + cloudNoise(uv * 2.0 + layer * 5.0) * 0.15;\n\n  // Fluffy edges for defined cloud shapes\n  float edge = smoothstep(0.5, 0.7, cloudShape);\n  float alpha = cloudDensity * edge * 0.7;\n\n  vec3 cloudColor = vec3(brightness);\n  return vec4(cloudColor, alpha);\n}\n\n// === Weather Particles (snow, sand) ===\nfloat weatherParticle(vec2 worldPos, float particleSize, float fallSpeed, float drift) {\n  vec2 uv = worldPos / particleSize;\n  vec2 cellId = floor(uv);\n  vec2 cellUV = fract(uv);\n\n  float particles = 0.0;\n\n  for (int dy = -1; dy <= 1; dy++) {\n    for (int dx = -1; dx <= 1; dx++) {\n      vec2 neighbor = vec2(float(dx), float(dy));\n      vec2 id = cellId + neighbor;\n\n      // Random offset within cell\n      float randX = hash1D(id.x * 0.1, id.y * 0.2);\n      float randY = hash1D(id.y * 0.3, id.x * 0.4);\n      float randPresent = hash1D(id.x, id.y + 200.0);\n\n      // Reduced density from 0.25 to 0.15\n      if (randPresent < 0.15) {\n        vec2 particlePos = neighbor + vec2(randX * 0.8 + 0.1, randY * 0.8 + 0.1);\n\n        // Time-based motion with CPU-side modulo for precision\n        // Corrected for World Y-down system: + u_time moves it down\n        float timeScale = u_time * 0.0006;\n        float progress = fract(randY * 10.0 + timeScale * fallSpeed * 10.0);\n        particlePos.y += progress;\n        particlePos.x += sin(u_time * 0.0005 * drift * 5.0 + randX * 6.28) * 0.4;\n\n        // Vertical fade to avoid "jumping" or "jitter" at cell boundaries\n        float verticalFade = smoothstep(0.0, 0.2, progress) * smoothstep(1.0, 0.7, progress);\n\n        float d = length(cellUV - particlePos);\n        float size = 0.04 + randX * 0.08;\n        particles += smoothstep(size, size * 0.5, d) * verticalFade;\n      }\n    }\n  }\n\n  return clamp(particles, 0.0, 1.0);\n}\n\n// === Rain Particles (thin streaks) ===\nfloat rainParticle(vec2 worldPos) {\n  // Elongated grid for streaks\n  vec2 uv = worldPos / vec2(8.0, 80.0);\n  vec2 cellId = floor(uv);\n  vec2 cellUV = fract(uv);\n\n  float rain = 0.0;\n  for (int dy = -1; dy <= 0; dy++) {\n    vec2 id = cellId + vec2(0.0, float(dy));\n    float randX = hash1D(id.x, id.y + 500.0);\n    float randY = hash1D(id.y, id.x + 600.0);\n\n    if (randX < 0.2) {\n      float timeScale = u_time * 0.005;\n      // Corrected for World Y-down system: + u_time moves it down\n      float progress = fract(randY + timeScale * (1.2 + randX));\n\n      float xOffset = randX * 5.0; // Random horizontal placement in cell\n      float dX = abs(cellUV.x - xOffset);\n      float dY = abs(cellUV.y - (float(dy) + progress));\n\n      // Thin vertical streak\n      if (dX < 0.1 && dY < 0.4) {\n        rain += (1.0 - dY * 2.5) * (1.0 - dX * 10.0);\n      }\n    }\n  }\n  return clamp(rain, 0.0, 1.0);\n}\n\n// === Point Light Calculation ===\n#define MAX_LIGHTS 10 // Define max number of lights\nuniform vec2 u_lightPos[MAX_LIGHTS];\nuniform vec3 u_lightColor[MAX_LIGHTS];\nuniform float u_lightRadius[MAX_LIGHTS];\nuniform int u_lightCount;\n\nvec3 calculateLighting(vec2 worldPos, vec3 baseColor) {\n  vec3 totalLight = vec3(0.0);\n  for (int i = 0; i < u_lightCount; i++) {\n    float dx = worldPos.x - u_lightPos[i].x;\n    float dy = worldPos.y - u_lightPos[i].y;\n    float distSq = dx*dx + dy*dy;\n    float radius = u_lightRadius[i];\n    float radiusSq = radius * radius;\n\n    if (distSq < radiusSq) {\n      // Linear falloff using sqrt only when inside radius\n      float dist = sqrt(distSq);\n      float atten = 1.0 - dist / radius;\n      // Square the attenuation for a more natural falloff\n      totalLight += u_lightColor[i] * (atten * atten);\n    }\n  }\n\n  // Apply light to the base color (additive for a "glow" feel)\n  return baseColor + totalLight * 0.8;\n}\n\n// === Biome color palettes ===\nvec3 getPlainsColor(float depth, float yRel, float baseH) {\n  vec3 dirtColor = vec3(0.278, 0.333, 0.412);\n  vec3 deepColor = vec3(0.059, 0.090, 0.165);\n  vec3 grassColor = vec3(0.133, 0.773, 0.369);\n  vec3 grassLight = vec3(0.525, 0.937, 0.675);\n\n  vec3 color = mix(dirtColor, deepColor, yRel);\n  if (depth >= 0.0 && depth < 15.0) {\n    color = depth < 4.0 ? grassLight : grassColor;\n  }\n  return color;\n}\n\nvec3 getMountainsColor(float depth, float yRel, float baseH) {\n  vec3 rockDark = vec3(0.25, 0.25, 0.28);\n  vec3 rockLight = vec3(0.45, 0.45, 0.5);\n  vec3 snowColor = vec3(0.95, 0.97, 1.0);\n  vec3 snowShadow = vec3(0.75, 0.82, 0.9);\n\n  vec3 color = mix(rockLight, rockDark, yRel);\n\n  // Snow on high peaks\n  if (baseH < SNOW_THRESHOLD) {\n    float snowBlend = smoothstep(SNOW_THRESHOLD, SNOW_THRESHOLD - 50.0, baseH);\n    vec3 snow = depth < 5.0 ? snowColor : snowShadow;\n    color = mix(color, snow, snowBlend);\n  }\n  return color;\n}\n\nvec3 getValleyColor(float depth, float yRel, float baseH) {\n  vec3 grassDark = vec3(0.08, 0.45, 0.22);\n  vec3 grassLight = vec3(0.15, 0.65, 0.35);\n  vec3 dirtColor = vec3(0.35, 0.25, 0.18);\n\n  vec3 color = mix(grassLight, dirtColor, yRel);\n  if (depth >= 0.0 && depth < 12.0) {\n    color = depth < 3.0 ? grassLight : grassDark;\n  }\n  return color;\n}\n\nvec3 getDesertColor(float depth, float yRel, float baseH) {\n  vec3 sandLight = vec3(0.93, 0.85, 0.65);\n  vec3 sandDark = vec3(0.75, 0.60, 0.40);\n  vec3 rockColor = vec3(0.55, 0.45, 0.35);\n\n  vec3 color = mix(sandLight, rockColor, yRel);\n  if (depth >= 0.0 && depth < 8.0) {\n    color = depth < 3.0 ? sandLight : sandDark;\n  }\n  return color;\n}\n\nvec3 getTundraColor(float depth, float yRel, float baseH) {\n  vec3 snowWhite = vec3(0.92, 0.95, 0.98);\n  vec3 iceBluePale = vec3(0.80, 0.88, 0.95);\n  vec3 iceBlue = vec3(0.55, 0.70, 0.85);\n  vec3 frozenGround = vec3(0.45, 0.50, 0.55);\n\n  vec3 color = mix(iceBluePale, frozenGround, yRel);\n  if (depth >= 0.0 && depth < 10.0) {\n    color = depth < 3.0 ? snowWhite : iceBlue;\n  }\n  return color;\n}\n\nvec3 getSwampColor(float worldX, float depth, float yRel, float baseH) {\n  vec3 muckColor = vec3(0.15, 0.18, 0.12);\n  vec3 waterColor = vec3(0.1, 0.25, 0.15);\n  vec3 mossColor = vec3(0.2, 0.4, 0.1);\n  vec3 grassColor = vec3(0.1, 0.3, 0.05);\n\n  vec3 color = mix(muckColor, vec3(0.05, 0.08, 0.05), yRel);\n  if (depth >= 0.0 && depth < 15.0) {\n    color = depth < 4.0 ? mossColor : grassColor;\n    if (noise(vec2(worldX * 0.1, (baseH + depth) * 0.5)) > 0.6) color = waterColor;\n  }\n  return color;\n}\n\nvec3 getVolcanicColor(float worldX, float depth, float yRel, float baseH) {\n  vec3 basaltColor = vec3(0.12, 0.12, 0.15);\n  vec3 ashColor = vec3(0.25, 0.25, 0.28);\n  vec3 lavaGlow = vec3(0.8, 0.2, 0.0);\n\n  vec3 color = mix(basaltColor, vec3(0.05, 0.05, 0.08), yRel);\n  if (depth >= 0.0 && depth < 10.0) {\n    float lavaNoise = noise(vec2(worldX * 0.05, (baseH + depth) * 0.1 + u_time * 0.001));\n    color = depth < 3.0 ? ashColor : basaltColor;\n    if (lavaNoise > 0.8) color = mix(color, lavaGlow, (lavaNoise - 0.8) * 5.0);\n  }\n  return color;\n}\n\n// === Terrain Decorations (Trees, Rocks) ===\nvec4 getDecorationColor(float worldX, float worldY, float baseH, int biomeIdx) {\n  float dy_ground = worldY - baseH;\n\n  // Grid-based Large Decorations\n  float decoGrid = 200.0;\n  float cellId = floor(worldX / decoGrid);\n  float cellRand = hash1D(cellId, u_seed * 1.5);\n\n  if (cellRand > 0.4) {\n    float decoX = (cellId + 0.3 + cellRand * 0.4) * decoGrid;\n    float decoH = computeBaseHeight(decoX);\n    float dx = worldX - decoX;\n    float dy = worldY - decoH;\n\n    // Trees (Plains/Valley/Tundra)\n    if (biomeIdx == 0 || biomeIdx == 2 || biomeIdx == 4) {\n      float trunkW = 4.0;\n      float trunkH = 40.0 + cellRand * 30.0;\n      if (biomeIdx == 4) trunkH *= 1.5; // Increased from 0.7 to 1.5\n\n      // Trunk\n      if (abs(dx) < trunkW && dy < 0.0 && dy > -trunkH) {\n        return vec4(0.25, 0.15, 0.08, 1.0);\n      }\n\n      // Foliage\n      float leafY = dy + trunkH * 0.9;\n      if (biomeIdx == 4) { // Pine shape for Tundra\n        float pineW = (dy + trunkH) * 0.5; // Increased width factor to 0.5\n        if (abs(dx) < pineW && dy < 0.0 && dy > -trunkH * 1.1) {\n          float noiseVal = noise(vec2(worldX * 0.2, worldY * 0.2));\n          vec3 leafColor = mix(vec3(0.1, 0.2, 0.15), vec3(0.8, 0.85, 0.9), step(0.6, noiseVal));\n          return vec4(leafColor, 1.0);\n        }\n      } else { // Fluffy trees for Plains/Valley\n        float dLeaf = length(vec2(dx, leafY));\n        float leafRadius = 30.0 + cellRand * 20.0;\n        float leafNoise = noise(vec2(worldX * 0.08, worldY * 0.08 + cellId)) * 12.0;\n        if (dLeaf < leafRadius + leafNoise) {\n          vec3 leafBase = (biomeIdx == 2) ? vec3(0.05, 0.3, 0.1) : vec3(0.15, 0.5, 0.1);\n          vec3 leafTop = leafBase + 0.2;\n          vec3 leafColor = mix(leafBase, leafTop, clamp(-dy/trunkH, 0.0, 1.0));\n          return vec4(leafColor, 1.0);\n        }\n      }\n    }\n    // Swamp Trees\n    else if (biomeIdx == 5) {\n      float trunkW = 6.0;\n      float trunkH = 50.0 + cellRand * 40.0;\n      if (abs(dx) < trunkW && dy < 0.0 && dy > -trunkH) {\n        return vec4(0.18, 0.12, 0.05, 1.0); // Darker trunk\n      }\n      // Drooping foliage\n      float leafY = dy + trunkH * 0.8;\n      float dLeaf = length(vec2(dx * 0.7, leafY));\n      float leafRadius = 40.0 + cellRand * 25.0;\n      if (dLeaf < leafRadius) {\n        float noiseVal = noise(vec2(worldX * 0.1, worldY * 0.1));\n        vec3 leafColor = mix(vec3(0.05, 0.15, 0.05), vec3(0.1, 0.25, 0.1), noiseVal);\n        return vec4(leafColor, 1.0);\n      }\n    }\n    // Volcanic Pillars/Rocks\n    else if (biomeIdx == 6) {\n      float pillarW = 15.0 + cellRand * 20.0;\n      float pillarH = 30.0 + cellRand * 60.0;\n      // Sharp, jagged shapes\n      float jagged = noise(vec2(worldX * 0.2, worldY * 0.1)) * 10.0;\n      if (abs(dx) < (pillarW - dy * 0.2) + jagged && dy < 0.0 && dy > -pillarH) {\n        float glow = step(0.8, noise(vec2(worldX * 0.1, worldY * 0.1 + u_time * 0.002)));\n        vec3 color = mix(vec3(0.1, 0.1, 0.12), vec3(0.6, 0.2, 0.0), glow * 0.5);\n        return vec4(color, 1.0);\n      }\n    }\n    // Smooth Boulders (Mountains/Desert)\n    else {\n      // Use elliptical shape and low-frequency noise for smoothness\n      float rockSize = 25.0 + cellRand * 25.0;\n      vec2 stretch = vec2(1.2 + cellRand * 0.4, 0.8 + cellRand * 0.2); // Elliptical distortion\n\n      // Sink rock into the ground by a random amount (0.2 to 0.7 of its size)\n      float sinkDepth = rockSize * (0.2 + cellRand * 0.5);\n      vec2 rockUV = vec2(dx / stretch.x, (dy + sinkDepth) / stretch.y);\n      float dRock = length(rockUV);\n\n      // Smooth, low-frequency noise instead of jagged detail\n      float rockNoise = noise(vec2(worldX * 0.05, worldY * 0.05 + cellId)) * (rockSize * 0.3);\n      rockNoise += noise(vec2(worldX * 0.1, worldY * 0.1)) * (rockSize * 0.1);\n\n      if (dRock < rockSize + rockNoise) {\n        vec3 rockBase = (biomeIdx == 3) ? vec3(0.7, 0.55, 0.35) : vec3(0.4, 0.4, 0.45);\n        vec3 rockHighlight = rockBase + 0.15;\n        // Smooth shading\n        float shading = dot(normalize(rockUV), normalize(vec2(-1.0, -1.0)));\n        vec3 rockColor = mix(rockBase, rockHighlight, shading * 0.4 + 0.6);\n        return vec4(rockColor, 1.0);\n      }\n    }\n  }\n\n  // Small Surface Details (Grass/Pebbles) - only rendered if solid is true in main\n  return vec4(0.0);\n}\n\n// Get biome color with smooth blending at boundaries\nvec3 getBiomeColorBlended(float worldX, float depth, float yRel, float baseH) {\n  // BIOME_SCALE is very small, so we use a reasonable transition width\n  float blendWidth = ${s.toFixed(1)};\n\n  // Find current and neighbor biomes for blending\n  int currentBiome = getBiomeIndex(worldX);\n\n  float chunkX = floor(worldX / 256.0) * 256.0 + 128.0;\n  float nextChunkX = chunkX + 256.0;\n  float prevChunkX = chunkX - 256.0;\n\n  int nextBiome = getBiomeIndex(nextChunkX);\n  int prevBiome = getBiomeIndex(prevChunkX);\n\n  vec3 color;\n  if (currentBiome == 0) color = getPlainsColor(depth, yRel, baseH);\n  else if (currentBiome == 1) color = getMountainsColor(depth, yRel, baseH);\n  else if (currentBiome == 2) color = getValleyColor(depth, yRel, baseH);\n  else if (currentBiome == 3) color = getDesertColor(depth, yRel, baseH);\n  else if (currentBiome == 4) color = getTundraColor(depth, yRel, baseH);\n  else if (currentBiome == 5) color = getSwampColor(worldX, depth, yRel, baseH);\n  else color = getVolcanicColor(worldX, depth, yRel, baseH);\n\n  // Smoothly blend with neighbors\n  float distToNext = nextChunkX - 128.0 - worldX;\n  float distToPrev = worldX - (prevChunkX + 128.0);\n\n  if (distToNext < 128.0 && nextBiome != currentBiome) {\n    float t = smoothstep(128.0, 0.0, distToNext);\n    vec3 nextColor;\n    if (nextBiome == 0) nextColor = getPlainsColor(depth, yRel, baseH);\n    else if (nextBiome == 1) nextColor = getMountainsColor(depth, yRel, baseH);\n    else if (nextBiome == 2) nextColor = getValleyColor(depth, yRel, baseH);\n    else if (nextBiome == 3) nextColor = getDesertColor(depth, yRel, baseH);\n    else if (nextBiome == 4) nextColor = getTundraColor(depth, yRel, baseH);\n    else if (nextBiome == 5) nextColor = getSwampColor(worldX, depth, yRel, baseH);\n    else nextColor = getVolcanicColor(worldX, depth, yRel, baseH);\n    color = mix(color, nextColor, t * 0.5);\n  }\n\n  if (distToPrev < 128.0 && prevBiome != currentBiome) {\n    float t = smoothstep(128.0, 0.0, distToPrev);\n    vec3 prevColor;\n    if (prevBiome == 0) prevColor = getPlainsColor(depth, yRel, baseH);\n    else if (prevBiome == 1) prevColor = getMountainsColor(depth, yRel, baseH);\n    else if (prevBiome == 2) prevColor = getValleyColor(depth, yRel, baseH);\n    else if (prevBiome == 3) prevColor = getDesertColor(depth, yRel, baseH);\n    else if (prevBiome == 4) prevColor = getTundraColor(depth, yRel, baseH);\n    else if (prevBiome == 5) prevColor = getSwampColor(worldX, depth, yRel, baseH);\n    else prevColor = getVolcanicColor(worldX, depth, yRel, baseH);\n    color = mix(color, prevColor, t * 0.5);\n  }\n\n  return color;\n}\n\nvoid main() {\n  vec2 screenPos = gl_FragCoord.xy;\n  float worldX = u_cameraPos.x + screenPos.x / u_zoom;\n  float worldY = u_cameraPos.y + (u_viewSize.y - screenPos.y) / u_zoom;\n\n  float baseH = computeBaseHeight(worldX);\n  bool solid = worldY >= baseH;\n  int biomeIdx = getBiomeIndex(worldX);\n\n  float nearestCraterDistSq = 1000000.0;\n  float nearestCraterRadius = 0.0;\n\n  // Track terrain modification masking\n  bool masked = false;\n\n  // Apply modifications\n  for (int i = 0; i < u_modCount; i++) {\n    vec4 data0 = texelFetch(u_modTexture, ivec2(i, 0), 0);\n    float modType = data0.r;\n    float modX = data0.g;\n    float modY = data0.b;\n    float modRadius = data0.a;\n\n    float dx = worldX - modX;\n    float dy = worldY - modY;\n    float distSq = dx * dx + dy * dy;\n\n    // Early exit for distant modifications (including scorch mark margin)\n    float activeRadius = modRadius * 1.5;\n    if (modType > 1.5) { // CARVE\n      vec4 data1 = texelFetch(u_modTexture, ivec2(i, 1), 0);\n      activeRadius = (data1.b + modRadius) * 1.5;\n    }\n\n    if (distSq > activeRadius * activeRadius) {\n      // Still update nearest crater for scorch marks if applicable\n      if (modType < 0.5 || modType > 1.5) {\n        if (distSq < nearestCraterDistSq) {\n          nearestCraterDistSq = distSq;\n          nearestCraterRadius = modRadius;\n        }\n      }\n      continue;\n    }\n\n    if (modType < 0.5) { // Crater\n      float edgeDist;\n      if (isInCrater(worldX, worldY, modX, modY, modRadius, edgeDist)) {\n        solid = false;\n        masked = true;\n      }\n      if (distSq < nearestCraterDistSq) {\n        nearestCraterDistSq = distSq;\n        nearestCraterRadius = modRadius;\n      }\n    } else if (modType < 1.5) { // Add\n      if (distSq <= modRadius * modRadius) solid = true;\n    } else { // Tunnel\n      vec4 data1 = texelFetch(u_modTexture, ivec2(i, 1), 0);\n      if (isInTunnel(worldX, worldY, modX, modY, data1.r, data1.g, modRadius, data1.b)) {\n        solid = false;\n        masked = true;\n      }\n      if (distSq < nearestCraterDistSq) {\n        nearestCraterDistSq = distSq;\n        nearestCraterRadius = modRadius;\n      }\n    }\n  }\n\n  // Common calculations for lighting and time\n  float skyT = screenPos.y / u_viewSize.y;\n  float timeOfDay = fract(u_time / ${l.toFixed(1)});\n  float lightFactor = smoothstep(-0.5, 0.5, cos((timeOfDay - 0.25) * 6.283185));\n  float horizonFactor = smoothstep(0.3, 0.0, abs(timeOfDay - 0.0)) +\n                        smoothstep(0.3, 0.0, abs(timeOfDay - 0.5)) +\n                        smoothstep(0.3, 0.0, abs(timeOfDay - 1.0));\n  horizonFactor = clamp(horizonFactor, 0.0, 1.0);\n\n  // === Popup Decorations check ===\n  if (!masked) {\n    vec4 deco = getDecorationColor(worldX, worldY, baseH, biomeIdx);\n    if (deco.a > 0.0) {\n      fragColor = vec4(deco.rgb, 1.0);\n      return;\n    }\n  }\n\n  // === Sky rendering ===\n  if (!solid) {\n    vec3 skyTopNight = vec3(0.008, 0.02, 0.08);\n    vec3 skyBotNight = vec3(0.05, 0.08, 0.2);\n    vec3 skyTopDay = vec3(0.2, 0.4, 0.8);\n    vec3 skyBotDay = vec3(0.5, 0.7, 0.95);\n    vec3 horizonColor = vec3(1.0, 0.4, 0.2);\n\n    vec3 skyTop = mix(skyTopNight, skyTopDay, lightFactor);\n    vec3 skyBot = mix(skyBotNight, skyBotDay, lightFactor);\n    skyBot = mix(skyBot, horizonColor, horizonFactor * (1.0 - skyT));\n\n    vec3 skyColor = mix(skyBot, skyTop, skyT);\n\n    // Stars\n    float starIntensity = smoothstep(0.4, 0.1, lightFactor);\n    if (starIntensity > 0.0) {\n      vec2 starUV = (screenPos + vec2(u_cameraPos.x, -u_cameraPos.y) * 0.05) / 40.0;\n      float stars = star(starUV, 1.0) * 0.8 + star(starUV * 1.5 + 100.0, 2.0) * 0.5 + star(starUV * 2.0 + 200.0, 3.0) * 0.3;\n      skyColor += vec3(stars) * starIntensity;\n    }\n\n    // Weather\n    float weatherIntensity = noise1D(worldX * 0.0005, u_seed + 1234.0);\n    float weatherThreshold = (biomeIdx == 4) ? 0.15 : 0.3;\n\n    if (weatherIntensity > weatherThreshold) {\n      float intensity = smoothstep(weatherThreshold, weatherThreshold + 0.1, weatherIntensity);\n      vec2 worldPos = vec2(worldX, worldY);\n      if (biomeIdx == 4) {\n        float snow = weatherParticle(worldPos, 20.0, 0.6, 0.2);\n        skyColor = mix(skyColor, vec3(1.0), snow * 0.5 * intensity);\n      } else if (biomeIdx == 3) {\n        float sand = weatherParticle(worldPos, 25.0, 0.3, 0.7);\n        skyColor = mix(skyColor, vec3(0.9, 0.8, 0.6), sand * 0.2 * intensity);\n      } else if (biomeIdx == 0 || biomeIdx == 2 || biomeIdx == 5) {\n        float rain = rainParticle(worldPos);\n        vec3 rainColor = (biomeIdx == 5) ? vec3(0.4, 0.5, 0.4) : vec3(0.6, 0.7, 0.8);\n        skyColor = mix(skyColor, rainColor, rain * 0.5 * intensity);\n      } else if (biomeIdx == 6) {\n        float ash = weatherParticle(worldPos, 15.0, -0.3, 0.5);\n        vec3 emberColor = mix(vec3(0.2, 0.2, 0.2), vec3(1.0, 0.3, 0.0), step(0.7, noise(screenPos * 0.1)));\n        skyColor = mix(skyColor, emberColor, ash * 0.4 * intensity);\n      }\n    }\n\n    fragColor = vec4(calculateLighting(vec2(worldX, worldY), skyColor), 1.0);\n    return;\n  }\n\n  // === Terrain rendering ===\n  float depth = worldY - baseH;\n  float yRel = worldY / u_worldSize.y;\n  vec3 color = getBiomeColorBlended(worldX, depth, yRel, baseH);\n\n  // Texture noise\n  float texNoise = fract(sin(dot(vec2(worldX, worldY), vec2(12.9898, 78.233))) * 43758.5453);\n  color += (texNoise - 0.5) * 0.04;\n\n  // Surface Decorations (Grass)\n  if (depth >= 0.0 && depth < 25.0) {\n    float grassPattern = noise(vec2(worldX * 0.3, worldY * 1.5 + u_seed));\n    float grassHeight = noise(vec2(worldX * 0.2 + u_seed, 0.0)) * 15.0 + 8.0;\n    float grassBlade = smoothstep(grassHeight, 0.0, depth) * step(0.35, grassPattern);\n\n    if (grassBlade > 0.0) {\n      vec3 gColor;\n      if (biomeIdx == 0) gColor = mix(vec3(0.2, 0.7, 0.2), vec3(0.4, 0.9, 0.3), grassPattern);\n      else if (biomeIdx == 1) gColor = mix(vec3(0.3, 0.4, 0.3), vec3(0.4, 0.5, 0.4), grassPattern);\n      else if (biomeIdx == 2) gColor = mix(vec3(0.1, 0.5, 0.2), vec3(0.2, 0.7, 0.3), grassPattern);\n      else if (biomeIdx == 3) gColor = mix(vec3(0.6, 0.5, 0.3), vec3(0.4, 0.6, 0.2), grassPattern);\n      else gColor = mix(vec3(0.8, 0.9, 1.0), vec3(0.6, 0.7, 0.8), grassPattern);\n      color = mix(color, gColor, grassBlade * 0.9);\n    }\n  }\n\n  // Scorch marks\n  if (nearestCraterRadius > 0.0) {\n    float nearestCraterDist = sqrt(nearestCraterDistSq);\n    float scorchOuter = nearestCraterRadius * 1.4;\n    if (nearestCraterDist <= scorchOuter) {\n      float scorchT = 1.0 - (nearestCraterDist - nearestCraterRadius * 0.7) / (scorchOuter - nearestCraterRadius * 0.7);\n      scorchT = clamp(scorchT, 0.0, 1.0);\n      float scorchNoise = noise(vec2(worldX * 0.2, worldY * 0.2)) * 0.3;\n      scorchT = clamp(scorchT + scorchNoise - 0.15, 0.0, 1.0);\n      vec3 scorchColor = mix(vec3(0.15, 0.1, 0.05), vec3(0.02, 0.01, 0.01), scorchT * 0.5);\n      color = mix(color, scorchColor, scorchT * 0.7);\n      if (nearestCraterDist <= nearestCraterRadius * 1.1) {\n        float innerT = 1.0 - (nearestCraterDist / (nearestCraterRadius * 1.1));\n        color = mix(color, vec3(0.0), innerT * 0.6);\n      }\n    }\n  }\n\n  // Day/Night lighting and tint\n  float ambLight = mix(0.25, 1.0, lightFactor);\n  vec3 tint = mix(vec3(1.0), vec3(1.0, 0.8, 0.7), horizonFactor);\n  color *= ambLight * tint;\n\n  // Apply Point Lights\n  color = calculateLighting(vec2(worldX, worldY), color);\n\n  fragColor = vec4(color, 1.0);\n}\n`,B=4096;class H{gl=null;program=null;vao=null;modTexture=null;biomeTexture=null;uniforms={seed:null,cameraPos:null,viewSize:null,zoom:null,worldSize:null,modTexture:null,modCount:null,time:null,lightPos:null,lightColor:null,lightRadius:null,lightCount:null,biomeTexture:null};modTextureData;lastModCount=0;isInitialized=!1;lastUploadParams={camX:-1e9,camY:-1e9,zoom:-1,modArrayRef:null,modCount:-1};constructor(){this.modTextureData=new Float32Array(32768)}init(e){const t=e.getContext("webgl2",{alpha:!0,antialias:!1,premultipliedAlpha:!1});if(!t)return console.warn("WebGL2 not available, falling back to CPU rendering"),!1;this.gl=t;const n=this.compileShader(t,t.VERTEX_SHADER,"#version 300 es\nprecision highp float;\n\n// Fullscreen quad vertices (2 triangles)\nconst vec2 positions[6] = vec2[](\n  vec2(-1.0, -1.0),\n  vec2( 1.0, -1.0),\n  vec2( 1.0,  1.0),\n  vec2(-1.0, -1.0),\n  vec2( 1.0,  1.0),\n  vec2(-1.0,  1.0)\n);\n\nvoid main() {\n  gl_Position = vec4(positions[gl_VertexID], 0.0, 1.0);\n}\n"),i=this.compileShader(t,t.FRAGMENT_SHADER,D);if(!n||!i)return console.error("Failed to compile shaders"),!1;const o=t.createProgram();return!!o&&(t.attachShader(o,n),t.attachShader(o,i),t.linkProgram(o),t.getProgramParameter(o,t.LINK_STATUS)?(this.program=o,this.uniforms={seed:t.getUniformLocation(o,"u_seed"),cameraPos:t.getUniformLocation(o,"u_cameraPos"),viewSize:t.getUniformLocation(o,"u_viewSize"),zoom:t.getUniformLocation(o,"u_zoom"),worldSize:t.getUniformLocation(o,"u_worldSize"),modTexture:t.getUniformLocation(o,"u_modTexture"),modCount:t.getUniformLocation(o,"u_modCount"),time:t.getUniformLocation(o,"u_time"),lightPos:t.getUniformLocation(o,"u_lightPos"),lightColor:t.getUniformLocation(o,"u_lightColor"),lightRadius:t.getUniformLocation(o,"u_lightRadius"),lightCount:t.getUniformLocation(o,"u_lightCount"),biomeTexture:t.getUniformLocation(o,"u_biomeTexture")},this.vao=t.createVertexArray(),this.modTexture=t.createTexture(),t.bindTexture(t.TEXTURE_2D,this.modTexture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),this.biomeTexture=t.createTexture(),t.bindTexture(t.TEXTURE_2D,this.biomeTexture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),this.isInitialized=!0,!0):(console.error("Program link error:",t.getProgramInfoLog(o)),!1))}resize(e,t){this.gl&&this.gl.viewport(0,0,e,t)}uploadModifications(e,t,n,a,r,s){if(!this.gl||!this.modTexture)return;const l=this.lastUploadParams.modArrayRef===e&&this.lastUploadParams.modCount===e.length,d=void 0!==t&&void 0!==n&&void 0!==s&&Math.abs(this.lastUploadParams.camX-t)<10&&Math.abs(this.lastUploadParams.camY-n)<10&&Math.abs(this.lastUploadParams.zoom-s)<.01;if(l&&d)return;void 0!==t&&void 0!==n&&void 0!==s&&(this.lastUploadParams.camX=t,this.lastUploadParams.camY=n,this.lastUploadParams.zoom=s),this.lastUploadParams.modArrayRef=e,this.lastUploadParams.modCount=e.length;let h=e;if(void 0!==t&&void 0!==n&&void 0!==a&&void 0!==r&&void 0!==s){const l=300,d=t-l,c=t+a/s+l,u=n-l,f=n+r/s+l;h=[];for(let t=0;t<e.length;t++){const n=e[t],a=i.getType(n),r=i.getRadius(n),s=i.getX(n),l=i.getY(n);let m=r;if(a===o.CARVE&&(m=(i.getLength(n)||100)+r),!(s+m<d||s-m>c||l+m<u||l-m>f)&&(h.push(n),h.length>=B))break}}const c=Math.min(h.length,B);this.lastModCount=c;for(let f=0;f<c;f++){const e=h[f],t=i.getType(e),n=i.getX(e),a=i.getY(e),r=i.getRadius(e),s=4*f;this.modTextureData[s+0]=t,this.modTextureData[s+1]=n,this.modTextureData[s+2]=a,this.modTextureData[s+3]=r;const l=16384+s;let d=0,c=0;const u=i.getLength(e)||0;if(t===o.CARVE){const t=i.getVx(e)||0,n=i.getVy(e)||0,o=Math.hypot(t,n);o>0&&(d=t/o,c=n/o)}this.modTextureData[l+0]=d,this.modTextureData[l+1]=c,this.modTextureData[l+2]=u,this.modTextureData[l+3]=0}const u=this.gl;u.bindTexture(u.TEXTURE_2D,this.modTexture),u.texImage2D(u.TEXTURE_2D,0,u.RGBA32F,B,2,0,u.RGBA,u.FLOAT,this.modTextureData)}setLights(e,t,n,i){const o=this.gl;o&&this.program&&(o.useProgram(this.program),o.uniform2fv(this.uniforms.lightPos,e),o.uniform3fv(this.uniforms.lightColor,t),o.uniform1fv(this.uniforms.lightRadius,n),o.uniform1i(this.uniforms.lightCount,i))}render(e,i,o,a,r,s,d){const h=this.gl;if(!h||!this.program||!this.vao)return;h.clearColor(0,0,0,0),h.clear(h.COLOR_BUFFER_BIT),h.useProgram(this.program),h.bindVertexArray(this.vao),h.uniform1f(this.uniforms.seed,e),h.uniform2f(this.uniforms.cameraPos,i,o),h.uniform2f(this.uniforms.viewSize,a,r),h.uniform1f(this.uniforms.zoom,s),h.uniform2f(this.uniforms.worldSize,t,n),h.uniform1i(this.uniforms.modCount,this.lastModCount);const c=10*l;h.uniform1f(this.uniforms.time,d%c),h.activeTexture(h.TEXTURE0),h.bindTexture(h.TEXTURE_2D,this.modTexture),h.uniform1i(this.uniforms.modTexture,0),h.activeTexture(h.TEXTURE1),h.bindTexture(h.TEXTURE_2D,this.biomeTexture),h.uniform1i(this.uniforms.biomeTexture,1),h.drawArrays(h.TRIANGLES,0,6)}uploadBiomeData(e){const t=this.gl;if(!t||!this.biomeTexture)return;const n=1024,i=new Float32Array(4096),o=(e,t)=>{let n=.1031*e+.3117*t;return n-=Math.floor(n),n*=n+33.33,n*=n+n,n-Math.floor(n)},r=(e,t)=>{const n=Math.floor(e),i=e-n,a=i*i*(3-2*i);return o(n,t)*(1-a)+o(n+1,t)*a},s=(e,t,n)=>{let i=0,o=.5,a=1;for(let s=0;s<n;s++)i+=o*r(e*a,t+100*s),o*=.5,a*=2;return i};for(let l=0;l<n;l++){const t=s((256*l+128)*a,e,2);i[4*l]=t}t.bindTexture(t.TEXTURE_2D,this.biomeTexture),t.texImage2D(t.TEXTURE_2D,0,t.RGBA32F,n,1,0,t.RGBA,t.FLOAT,i)}isReady(){return this.isInitialized}dispose(){const e=this.gl;e&&(this.program&&e.deleteProgram(this.program),this.vao&&e.deleteVertexArray(this.vao),this.modTexture&&e.deleteTexture(this.modTexture),this.biomeTexture&&e.deleteTexture(this.biomeTexture),this.isInitialized=!1)}compileShader(e,t,n){const i=e.createShader(t);return i?(e.shaderSource(i,n),e.compileShader(i),e.getShaderParameter(i,e.COMPILE_STATUS)?i:(console.error(t===e.VERTEX_SHADER?"Vertex":"Fragment","shader error:",e.getShaderInfoLog(i)),e.deleteShader(i),null)):null}}class O{gl=null;program=null;vao=null;vbo=null;isInitialized=!1;uniforms={cameraPos:null,viewSize:null,zoom:null,worldSize:null,pass:null,time:null};init(e){this.gl=e;const t=this.compileShader(e,e.VERTEX_SHADER,"#version 300 es\nprecision highp float;\n\nlayout(location = 0) in vec2 a_pos;\nlayout(location = 4) in float a_life;\nlayout(location = 6) in float a_size;\nlayout(location = 7) in float a_type;\nlayout(location = 8) in vec3 a_color;\n\nuniform vec2 u_cameraPos;\nuniform vec2 u_viewSize;\nuniform float u_zoom;\nuniform vec2 u_worldSize;\n\nout float v_life;\nout float v_type;\nout vec3 v_color;\n\nvoid main() {\n  // World to screen transformation\n  vec2 screenPos = (a_pos - u_cameraPos) * u_zoom;\n\n  // Convert to clip space\n  vec2 clipSpace = (screenPos / u_viewSize) * 2.0 - 1.0;\n  gl_Position = vec4(clipSpace.x, -clipSpace.y, 0.0, 1.0);\n\n  gl_PointSize = a_size * u_zoom;\n  v_life = a_life;\n  v_type = a_type;\n  v_color = a_color;\n}\n"),n=this.compileShader(e,e.FRAGMENT_SHADER,"#version 300 es\nprecision highp float;\n\nuniform int u_pass; // 0 = Alpha Pass (Smoke/Debris), 1 = Additive Pass (Fire/Sparks)\nuniform float u_time; // For flicker\n\nin float v_life;\nin float v_type;\nin vec3 v_color;\n\nout vec4 fragColor;\n\nvoid main() {\n  float dist = length(gl_PointCoord - 0.5);\n  if (dist > 0.5) discard;\n\n  bool isFire = v_type > 0.5;\n\n  // Filter based on pass\n  if (u_pass == 0 && isFire) discard;\n  if (u_pass == 1 && !isFire) discard;\n\n  if (isFire) { // fire, spark, glow\n    // High intensity center + LARGE soft outer glow for shining effect\n    float core = 1.0 - smoothstep(0.0, 0.2, dist);\n    float glow = 1.0 - smoothstep(0.0, 0.5, dist);\n    float aura = 1.0 - smoothstep(0.2, 0.5, dist); // Extra layer for volume\n\n    // Flicker effect\n    float flicker = 0.8 + 0.2 * sin(u_time * 0.05 + v_life * 100.0);\n\n    // Boost brightness significantly\n    vec3 col = v_color * 1.8 * flicker;\n    col = mix(col, vec3(1.0, 1.0, 0.95), core * 0.8); // Very hot white-yellow core\n\n    // Output with high alpha for additive pass\n    // Multiply by v_life for fade out\n    fragColor = vec4(col * (glow * 0.6 + aura * 0.4) * v_life, 1.0);\n  } else { // smoke\n    // Softer smoke edges\n    float smokeAlpha = 1.0 - smoothstep(0.2, 0.5, dist);\n    fragColor = vec4(v_color, smokeAlpha * v_life * 0.6);\n  }\n}\n");if(!t||!n)return!1;const i=e.createProgram();if(!i)return!1;if(e.attachShader(i,t),e.attachShader(i,n),e.linkProgram(i),!e.getProgramParameter(i,e.LINK_STATUS))return console.error("Particle program link error:",e.getProgramInfoLog(i)),!1;this.program=i,this.uniforms={cameraPos:e.getUniformLocation(i,"u_cameraPos"),viewSize:e.getUniformLocation(i,"u_viewSize"),zoom:e.getUniformLocation(i,"u_zoom"),worldSize:e.getUniformLocation(i,"u_worldSize"),pass:e.getUniformLocation(i,"u_pass"),time:e.getUniformLocation(i,"u_time")},this.vao=e.createVertexArray(),this.vbo=e.createBuffer(),e.bindVertexArray(this.vao),e.bindBuffer(e.ARRAY_BUFFER,this.vbo);const o=4*d;return e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,o,0),e.enableVertexAttribArray(4),e.vertexAttribPointer(4,1,e.FLOAT,!1,o,16),e.enableVertexAttribArray(6),e.vertexAttribPointer(6,1,e.FLOAT,!1,o,24),e.enableVertexAttribArray(7),e.vertexAttribPointer(7,1,e.FLOAT,!1,o,28),e.enableVertexAttribArray(8),e.vertexAttribPointer(8,3,e.FLOAT,!1,o,32),this.isInitialized=!0,!0}render(e,i,o,a,r,s,l){const h=this.gl;h&&this.program&&this.vao&&0!==i&&(h.useProgram(this.program),h.bindVertexArray(this.vao),h.uniform2f(this.uniforms.cameraPos,o,a),h.uniform2f(this.uniforms.viewSize,r,s),h.uniform1f(this.uniforms.zoom,l),h.uniform2f(this.uniforms.worldSize,t,n),h.uniform1f(this.uniforms.time,performance.now()),h.bindBuffer(h.ARRAY_BUFFER,this.vbo),h.bufferData(h.ARRAY_BUFFER,e.subarray(0,i*d),h.DYNAMIC_DRAW),h.enable(h.BLEND),h.blendFunc(h.SRC_ALPHA,h.ONE_MINUS_SRC_ALPHA),h.uniform1i(this.uniforms.pass,0),h.drawArrays(h.POINTS,0,i),h.blendFunc(h.ONE,h.ONE),h.uniform1i(this.uniforms.pass,1),h.drawArrays(h.POINTS,0,i))}isReady(){return this.isInitialized}compileShader(e,t,n){const i=e.createShader(t);return i?(e.shaderSource(i,n),e.compileShader(i),e.getShaderParameter(i,e.COMPILE_STATUS)?i:(console.error(e.getShaderInfoLog(i)),e.deleteShader(i),null)):null}}class L extends e{terrainMap=null;terrainRenderer=null;terrainShaderRenderer=null;lastSyncedModCount=0;_projectiles=[];_particleData=new Float32Array(h*d);_particleCount=0;_particleShaderRenderer=null;get projectiles(){return this._projectiles}get particleData(){return this._particleData}get particleCount(){return this._particleCount}botState={planned:!1,moveTimer:0,moveDir:0,aimTimer:0,targetWeapon:c.BASIC,targetAngle:0,targetPower:0};_botBrains=new Map;getInitState(){return{phase:f.WAITING,tanks:[],currentTurnIndex:0,wind:0,winner:null,turnTimeEnd:0,players:this.players.map(e=>({id:e.id||null,username:e.username||null,tankId:null})),terrainSeed:Math.round(1e4*Math.random()),terrainMods:[],isSimulating:!1,selectedMode:u.TURN_BASED,gameStartTime:Date.now()}}isGameOver(e){return e.phase===f.GAME_OVER}initTerrain(){this.terrainMap&&this.terrainMap.getSeed()===this.state.terrainSeed?this.syncTerrain():(this.terrainMap=new A(this.state.terrainSeed),this.terrainRenderer=new E,this.lastSyncedModCount=0,this.syncTerrain(),this.terrainShaderRenderer?.isReady()&&this.terrainShaderRenderer.uploadBiomeData(this.state.terrainSeed))}onStateUpdate(e){super.onStateUpdate(e),this.syncTerrain()}onSocketGameState(e){super.onSocketGameState(e),this.initTerrain()}syncTerrain(){if(!this.terrainMap)return;const e=this.state.terrainMods.length;if(e===this.lastSyncedModCount)return;e<this.lastSyncedModCount&&(this.terrainMap.reset(this.state.terrainSeed),this.terrainRenderer&&this.terrainRenderer.clearCache(),this.lastSyncedModCount=0);const t=this.state.terrainMods.slice(this.lastSyncedModCount);if(t.length>0){if(this.terrainMap.applyModifications(t,!1),this.terrainRenderer)for(const e of t){const t=i.getType(e),n=i.getRadius(e),a=i.getX(e),r=i.getY(e),s=i.getVx(e),l=i.getVy(e),d=t===o.DESTROY?n*(y[c.BASIC].terrainDamageMultiplier||1.2):n;t===o.CARVE&&void 0!==s&&void 0!==l?this.terrainRenderer.invalidateTunnel(a,r,s,l,n,i.getLength(e)||100):this.terrainRenderer.invalidateArea(a,r,d)}this.terrainShaderRenderer&&this.terrainShaderRenderer.uploadModifications(this.state.terrainMods),this.lastSyncedModCount=e}}checkSolid(e,t){return!!this.terrainMap&&this.terrainMap.isSolid(e,t)}getTerrainHeight(e){return this.terrainMap?this.terrainMap.getTerrainHeight(e):n+100}getTerrainMap(){return this.terrainMap}getTerrainRenderer(){return this.terrainRenderer}getTerrainShaderRenderer(){return this.terrainShaderRenderer}initShaderRenderer(e){this.terrainShaderRenderer||(this.terrainShaderRenderer=new H);const t=this.terrainShaderRenderer.init(e);t&&this.terrainMap&&(this.terrainShaderRenderer.uploadModifications(this.state.terrainMods),this.terrainShaderRenderer.uploadBiomeData(this.state.terrainSeed));const n=e.getContext("webgl2");return n&&(this._particleShaderRenderer||(this._particleShaderRenderer=new O),this._particleShaderRenderer.init(n)),t}getParticleShaderRenderer(){return this._particleShaderRenderer}seededRandom(e){const t=1e4*Math.sin(e);return t-Math.floor(t)}onSocketGameAction(e){const t=e.action;switch(console.log("onSocketGameAction",e),t.type){case"FIRE_SHOT":this.fireTank(t.shot);break;case"COMMIT_ANGLE":this.handleCommitAngle(t.angle,t.playerId);break;case"COMMIT_POWER":this.handleCommitPower(t.power,t.playerId);break;case"SELECT_WEAPON":this.handleSelectWeapon(t.weapon,t.playerId);break;case"MOVE_START":this.handleMoveStart(t.direction,t.x,t.playerId);break;case"MOVE_STOP":this.handleMoveStop(t.x,t.y,t.fuel,t.playerId);break;case"REGENERATE_MAP":this.handleRegenerateMap(t.seed);break;default:if(!this.isHost)return;switch(t.type){case"FIRE":this.handleFire(t.playerId,t.x,t.y);break;case"START_GAME":this.startGame();break;case"RESET_GAME":this.reset();break;case"ADD_BOT":this.addBot();break;case"REMOVE_BOT":this.removeBot();break;case"SELECT_MODE":this.handleSelectMode(t.mode)}}}handleCommitAngle(e,t){const n=this.getTankByPlayerId(t);if(!n)return;if(!this.isPlayerTurn(t)&&this.state.selectedMode!==u.CHAOS)return;if(this.state.phase!==f.AIMING&&this.state.selectedMode!==u.CHAOS)return;n.angle=Math.max(0,Math.min(180,e));const i=this._tankSimulations.get(n.id);i&&(i.angle=n.angle)}handleCommitPower(e,t){const n=this.getTankByPlayerId(t);n&&(this.isPlayerTurn(t)||this.state.selectedMode===u.CHAOS)&&(this.state.phase!==f.AIMING&&this.state.selectedMode!==u.CHAOS||(n.power=Math.max(0,Math.min(100,e))))}handleSelectWeapon(e,t){const n=this.getTankByPlayerId(t);n&&(this.isPlayerTurn(t)||this.state.selectedMode===u.CHAOS)&&(this.state.phase!==f.AIMING&&this.state.selectedMode!==u.CHAOS||(n.weapon=e))}handleMoveStart(e,t,n){const i=this.getTankByPlayerId(n);i&&(this.isPlayerTurn(n)||this.state.selectedMode===u.CHAOS)&&(this.state.phase!==f.AIMING&&this.state.selectedMode!==u.CHAOS||(i.isMoving=!0,i.moveDir=e))}handleMoveStop(e,t,n,i){const o=this.getTankByPlayerId(i);o&&(this.isPlayerTurn(i)||this.state.selectedMode===u.CHAOS)&&(this.state.phase!==f.AIMING&&this.state.selectedMode!==u.CHAOS||(o.isMoving=!1,o.moveDir=void 0,o.x=e,o.y=t,o.fuel=n,this.state.selectedMode!==u.CHAOS&&this._tankSimulations.delete(o.id)))}handleSelectMode(e){this.isHost&&(this.state.selectedMode=e)}handleFire(e,t,n){if(!this.isHost)return;if(this.state.phase!==f.AIMING&&this.state.selectedMode!==u.CHAOS)return;if(!this.isPlayerTurn(e)&&this.state.selectedMode!==u.CHAOS)return;const i=this.getTankByPlayerId(e);if(!i)return;if(this.state.selectedMode===u.CHAOS){const e=Date.now();if(e-i.lastFireTime<m)return;i.lastFireTime=e}const o={tankId:i.id,x:t??i.x,y:n??i.y,angle:i.angle,power:i.power,weapon:i.weapon,wind:this.state.wind,seed:Math.random()};this.makeAction({type:"FIRE_SHOT",shot:o})}_tankSimulations=new Map;update(){if(this.syncTerrain(),this.isHost&&this.updateBots(),!this.terrainMap)return;this.state.phase===f.AIMING&&this.state.tanks.forEach(e=>{if(this.state.selectedMode===u.CHAOS&&this.getSimTank(e),e.isMoving&&e.moveDir){const t=this.getSimTank(e),n={...e,...t},i=this.calculateTankMovement(n,e.moveDir);i&&t?(t.x=i.x,t.y=i.y,t.fuel=i.fuel):(e.playerId===this.userId&&this.moveStop(),e.isMoving=!1,e.moveDir=void 0,this._tankSimulations.delete(e.id))}else this.state.selectedMode!==u.CHAOS&&this._tankSimulations.has(e.id)&&this._tankSimulations.delete(e.id)});const e=this.updateTankPhysics(),t=this.updateProjectilePhysics(),n=this.updateParticlePhysics();this.checkPhaseTransitions(e,t,n)&&this.state.isSimulating&&this.onSimulationEnd()}getVisualTank(e){const t=this._tankSimulations.get(e.id);return t?{...e,x:t.x,y:t.y,fuel:t.fuel,angle:t.angle}:e}gravityTank(e,t,i){const o={x:e,y:t,health:i,moving:!1};if(o.health<=0)return o;if(this.checkSolid(o.x,o.y+1))for(;this.checkSolid(o.x,o.y);)o.y--,o.moving=!0;else o.y+=3,o.moving=!0,o.y>n&&(o.health=0);return o}calculateTankMovement(e,n){if(this.state.selectedMode!==u.CHAOS&&e.fuel<=0)return null;if(!this.terrainMap)return null;let{x:i,y:o,fuel:a,angle:r}=e;const s=Math.max(15,Math.min(t-15,i+n*k));if(this.checkSolid(s,o)){let e=!1;for(let t=1;t<=5;t++)if(!this.checkSolid(s,o-t)){i=s,o-=t,e=!0;break}e&&this.state.selectedMode!==u.CHAOS&&(a-=p)}else{i=s,this.state.selectedMode!==u.CHAOS&&(a-=p);for(let e=1;e<=5;e++)if(this.checkSolid(i,o+e)){o+=e-1;break}}return{x:i,y:o,fuel:Math.max(0,a),angle:r}}getSimTank(e){let t=this._tankSimulations.get(e.id);return t||(t={x:e.x,y:e.y,fuel:e.fuel,angle:e.angle,health:e.health,falling:!1,lastAuthX:e.x,lastAuthY:e.y},this._tankSimulations.set(e.id,t)),t}fireTank(e){this.state.selectedMode!==u.CHAOS&&(this.state.phase=f.FIRING),this.state.isSimulating=!0;const t=e.angle*Math.PI/180,n=e.power/100*g,i=(i=0,o=0)=>{const a=t+i*Math.PI/180,r=e.x+30*Math.cos(a),s=e.y-10-30*Math.sin(a);return{id:(e.seed+o).toString(36),x:r,y:s,vx:Math.cos(a)*n,vy:-Math.sin(a)*n,radius:5,weapon:e.weapon,ownerId:e.tankId,active:!0,bounces:e.weapon===c.BOUNCY?3:void 0}},o=y[e.weapon],a=o.count,r=o.spread||0;for(let s=0;s<a;s++){let e=0;a>1&&(e=-(a-1)*r/2+s*r),this._projectiles.push(i(e,.001*s))}this.state.selectedMode!==u.CHAOS&&(this.state.phase=f.PROJECTILE_MOVING)}updateTankPhysics(){let e=!1;return this.state.tanks.forEach(t=>{if(t.health<=0)return void this._tankSimulations.delete(t.id);const n=this.getSimTank(t),i=Math.abs(t.x-n.lastAuthX)>1||Math.abs(t.y-n.lastAuthY)>1;(!n.falling&&!t.isMoving||i)&&(n.x=t.x,n.y=t.y,n.lastAuthX=t.x,n.lastAuthY=t.y),n.health=t.health;const{x:o,y:a,health:r,moving:s}=this.gravityTank(n.x,n.y,n.health);s?(n.x=o,n.y=a,n.health=r,n.falling=!0,e=!0,n.health<=0&&(this.state.selectedMode===u.CHAOS?(t.health=100,t.y=-1e3):t.health=0)):n.falling&&(n.falling=!1,t.x=n.x,t.y=n.y,t.health=n.health)}),e}updateProjectilePhysics(){let e=!1;return this._projectiles.forEach(i=>{if(i.active){if(e=!0,i.x+=i.vx,i.y+=i.vy,i.vy+=v,i.vx+=this.state.wind,i.weapon===c.METEOR_STRIKE)for(let e=0;e<3;e++)this.createTrailParticle(i);else Math.random()>.3&&this.createTrailParticle(i);if(!this.checkProjectileTankCollision(i))if(i.x<0||i.x>t||i.y>n)i.active=!1;else if(this.checkSolid(i.x,i.y))if(i.weapon===c.BOUNCY&&(i.bounces||0)>0){i.vy=.6*-i.vy,i.vx*=.8,i.bounces=(i.bounces||0)-1;let e=0;for(;this.checkSolid(i.x,i.y)&&e<10;)i.y-=2,e++;this.createParticles(i.x,i.y,5,x.spark,1)}else this.explode(i)}}),this._projectiles=this._projectiles.filter(e=>e.active),e}checkProjectileTankCollision(e){for(const t of this.state.tanks){if(t.health<=0)continue;if(t.id===e.ownerId&&Math.abs(e.x-t.x)<20&&Math.abs(e.y-t.y)<20)continue;const n=t.x-e.x,i=t.y-10-e.y;if(Math.sqrt(n*n+i*i)<15)return this.explode(e),!0}return!1}updateParticlePhysics(){if(0===this._particleCount)return!1;for(let e=0;e<this._particleCount;e++){const t=e*d;this._particleData[t+0]+=this._particleData[t+2],this._particleData[t+1]+=this._particleData[t+3],this._particleData[t+4]-=this._particleData[t+5];if(this._particleData[t+7]===x.smoke&&(this._particleData[t+3]-=.05,this._particleData[t+6]+=.1),this._particleData[t+4]<=0){if(this._particleCount>1){const e=(this._particleCount-1)*d;this._particleData.copyWithin(t,e,e+d)}this._particleCount--,e--}}return this._particleCount>0}checkPhaseTransitions(e,t,n){const i=this.state;return 0===this._projectiles.filter(e=>e.active).length&&i.phase===f.PROJECTILE_MOVING&&(i.phase=f.IMPACT,i.turnTimeEnd=Date.now()+1e3),i.phase===f.IMPACT&&i.turnTimeEnd<=Date.now()&&!e||!(e||t||n||i.tanks.some(e=>e.isMoving)||i.phase===f.IMPACT||i.phase===f.PROJECTILE_MOVING)}explode(e){const t=y[e.weapon]||y[c.BASIC];if(this.isHost)if(t.type===c.BUILDER)this.state.terrainMods.push(i.create(o.ADD,e.x,e.y,t.radius));else if(t.type===c.DRILL)this.state.terrainMods.push(i.create(o.CARVE,e.x,e.y,t.radius,e.vx,e.vy,150));else if(t.type!==c.TELEPORT&&t.type!==c.AIRSTRIKE&&t.type!==c.HEAL){const n=t.radius*t.terrainDamageMultiplier;this.state.terrainMods.push(i.create(o.DESTROY,e.x,e.y,n))}this.syncTerrain(),this.createExplosionParticles(e.x,e.y,t),this.handleSpecialWeapons(e,t),this.isHost&&t.damage>0&&this.state.tanks.forEach(n=>{const i=n.x-e.x,o=n.y-10-e.y,a=Math.sqrt(i*i+o*o);if(a<t.radius+20){const i=Math.floor(t.damage*(1-a/(t.radius+50)));if(i>0)if(t.type===c.HEAL)n.health=Math.min(n.maxHealth,n.health+i);else if(t.type===c.VAMPIRE){n.health=Math.max(0,n.health-i);const t=this.state.tanks.find(t=>t.id===e.ownerId);t&&(t.health=Math.min(t.maxHealth,t.health+i))}else n.health=Math.max(0,n.health-i)}}),t.damage>0&&this.state.tanks.forEach(n=>{const i=n.x-e.x,o=n.y-10-e.y,a=Math.sqrt(i*i+o*o);if(a<t.radius+20){Math.floor(t.damage*(1-a/(t.radius+50)))>0&&(t.type===c.HEAL?this.createParticles(n.x,n.y-10,8,x.glow,1,"#4ade80"):this.createParticles(n.x,n.y-10,10,x.spark,2))}}),e.active=!1}handleSpecialWeapons(e,t){if(t.type===c.TELEPORT){if(!this.isHost)return;const n=this.state.tanks.find(t=>t.id===e.ownerId);if(n){let i=null,o=t.radius+15;for(const t of this.state.tanks){if(t.id===n.id||t.health<=0)continue;const a=Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-10-e.y,2));a<o&&(o=a,i=t)}if(i){const e=i.x,t=i.y;i.x=n.x,i.y=n.y,n.x=e,n.y=t}else{n.x=e.x,n.y=e.y;let t=0;for(;this.checkSolid(n.x,n.y)&&t<50;)n.y--,t++}}}if(t.type===c.AIRSTRIKE){const t=Number(e.id)||0;for(let n=0;n<8;n++){const i=t+.1*n,o=100*(this.seededRandom(i)-.5),a=200*-this.seededRandom(i+.05);this._projectiles.push({id:(t+1+.1*n).toString(),x:e.x+o,y:a,vx:0,vy:5+5*this.seededRandom(i+.07),radius:5,weapon:c.AIRSTRIKE_BOMB,ownerId:e.ownerId,active:!0})}}if(t.type===c.MIRV){const t=Number(e.id)||e.x;for(let n=0;n<5;n++){const i=t+.13*n,o=12*(this.seededRandom(i)-.5),a=-3-8*this.seededRandom(i+.05);this._projectiles.push({id:(t+n+100).toString(36),x:e.x,y:e.y-10,vx:o,vy:a,radius:5,weapon:c.MIRV_MINI,ownerId:e.ownerId,active:!0})}}t.type===c.METEOR&&this._projectiles.push({id:(Number(e.id)+1e3).toString(),x:e.x,y:-1e3,vx:.1*e.vx+10*this.state.wind,vy:6,radius:40,weapon:c.METEOR_STRIKE,ownerId:e.ownerId,active:!0})}createExplosionParticles(e,t,n){n.type===c.NUKE?(this.createParticles(e,t,100,x.smoke,3),this.createParticles(e,t,50,x.smoke,2),this.createParticles(e,t,30,x.glow,4,"#d946ef")):n.type===c.TELEPORT?(this.createParticles(e,t,30,x.glow,2,"#c084fc"),this.createParticles(e,t,20,x.spark,3,"#ffffff")):n.type===c.METEOR_STRIKE?(this.createParticles(e,t,150,x.fire,6,void 0,.3),this.createParticles(e,t,50,x.smoke,3,void 0,.3),this.createParticles(e,t,50,x.glow,8,"#ff4500",.4)):n.type===c.BUILDER?this.createParticles(e,t,20,x.smoke,1,"#64748b"):n.type===c.HEAL?(this.createParticles(e,t,20,x.glow,2,"#4ade80"),this.createParticles(e,t,15,x.spark,1.5,"#ffffff")):(this.createParticles(e,t,20,x.fire,1.5),this.createParticles(e,t,20,x.smoke,1))}createTrailParticle(e){const t={[c.NUKE]:"#d946ef",[c.DRILL]:"#94a3b8",[c.TELEPORT]:"#c084fc",[c.AIRSTRIKE]:"#ef4444",[c.AIRSTRIKE_BOMB]:"#ef4444",[c.BUILDER]:"#60a5fa",[c.HEAL]:"#4ade80",[c.METEOR_STRIKE]:"#fb923c"}[e.weapon];t?this.createParticles(e.x,e.y,1,x.glow,.3,t):this.createParticles(e.x,e.y,1,x.smoke,0,"rgba(255,255,255,0.5)",5)}createParticles(e,t,n,i,o=1,a,r=1){const s=Math.min(n,100);for(let l=0;l<s&&!(this._particleCount>=h);l++){const n=Math.random()*Math.PI*2,s=2*Math.random()*o;let l="#fff",h=.02,c=3*Math.random()+1,u=x.smoke,f=0;i===x.fire?(l=a||(Math.random()>.5?"#fbbf24":"#ef4444"),h=.04*r,c=6*Math.random()+4,u=x.fire,f=1):i===x.smoke?(l=a||"#64748b",h=.02*r,c=8*Math.random()+4,u=x.smoke):i===x.spark?(l=a||"#facc15",h=.08*r,c=2*Math.random()+1,u=x.spark,f=1):i===x.glow&&(l=a||"#22c55e",h=.05*r,c=5*Math.random()+2,u=x.glow,f=1);const m=parseInt(l.slice(1,3),16)/255||1,p=parseInt(l.slice(3,5),16)/255||1,g=parseInt(l.slice(5,7),16)/255||1,y=this._particleCount*d;this._particleData[y+0]=e,this._particleData[y+1]=t,this._particleData[y+2]=Math.cos(n)*s,this._particleData[y+3]=Math.sin(n)*s,this._particleData[y+4]=1,this._particleData[y+5]=h,this._particleData[y+6]=c,this._particleData[y+7]=u,this._particleData[y+8]=m,this._particleData[y+9]=p,this._particleData[y+10]=g,this._particleData[y+11]=f,this._particleCount++}}onSimulationEnd(){if(this.state.isSimulating){if(this.state.isSimulating=!1,this.state.selectedMode!==u.CHAOS){const e=this.state.tanks.filter(e=>e.health>0);if(e.length<=1){if(this.state.phase=f.GAME_OVER,1===e.length){const t=e[0],n=this.state.players.find(e=>e.id===t.playerId);this.state.winner=n?.username||(t.isBot?"Bot":"Player")}else this.state.winner="Draw";return}}this.nextTurn(),this.checkBotTurn()}}nextTurn(){const e=this.state;if(e.selectedMode===u.CHAOS)return e.phase=f.AIMING,void(e.turnTimeEnd=0);for(e.currentTurnIndex=(e.currentTurnIndex+1)%e.tanks.length;e.tanks[e.currentTurnIndex].health<=0;)e.currentTurnIndex=(e.currentTurnIndex+1)%e.tanks.length;e.tanks[e.currentTurnIndex].fuel=T,this.botState.planned=!1,e.phase=f.AIMING,e.wind=.05*Math.random()-.025}updateBots(){if(this.state.phase!==f.WAITING)if(this.state.selectedMode===u.CHAOS)this.state.tanks.forEach(e=>{if(!e.isBot||e.health<=0)return;let t=this._botBrains.get(e.id);if(t||(t={targetId:null,targetAngle:e.angle,targetPower:e.power,targetWeapon:c.BASIC,actionTimer:0,moveTimer:0,moveDir:0,currentAngle:e.angle,currentPower:e.power},this._botBrains.set(e.id,t)),t.actionTimer<=0){const n=this.state.tanks.filter(t=>t.id!==e.id&&t.health>0);if(n.length>0&&(t.targetId=n[Math.floor(Math.random()*n.length)].id),t.targetId){const n=this.state.tanks.find(e=>e.id===t.targetId);if(n){const i=n.x-e.x,o=Math.abs(i),a=i>0?1:-1;t.targetWeapon=o<300?c.SCATTER:o>800?c.BASIC:c.BARRAGE;const r=a>0?45:135;t.targetAngle=r+(20*Math.random()-10);const s=Math.sqrt(o*v)/g*100;t.targetPower=Math.max(20,Math.min(90,s+(10*Math.random()-5))),o<200?(t.moveDir=-a,t.moveTimer=60):o>500?(t.moveDir=a,t.moveTimer=60):(t.moveDir=0,t.moveTimer=0)}}t.actionTimer=120+120*Math.random()}else t.actionTimer--;const n=t.targetAngle-t.currentAngle;Math.abs(n)>.1&&(t.currentAngle+=.05*n);const i=t.targetPower-t.currentPower;Math.abs(i)>.1&&(t.currentPower+=.05*i),t.moveTimer>0?t.moveTimer--:t.moveDir=0;const o=t.moveTimer>0!==e.isMoving,a=e.weapon!==t.targetWeapon;if(o&&(e.isMoving=t.moveTimer>0,e.moveDir=t.moveDir||void 0,!e.isMoving)){const t=this._tankSimulations.get(e.id);t&&(e.x=t.x,e.y=t.y,e.fuel=t.fuel)}a&&(e.weapon=t.targetWeapon);Date.now()-e.lastFireTime>=m+2e3*Math.random()&&Math.abs(t.targetAngle-t.currentAngle)<5&&t.targetId&&(e.angle=t.currentAngle,e.power=t.currentPower,e.weapon=t.targetWeapon,this.handleFire(e.playerId||"BOT"))});else{const e=this.state.tanks[this.state.currentTurnIndex];e&&e.isBot&&this.checkBotTurn()}}checkBotTurn(){if(!this.isHost||this.state.selectedMode===u.CHAOS)return;if(this.state.phase!==f.AIMING)return;if(this.state.isSimulating)return;const e=this.state.tanks[this.state.currentTurnIndex];e?.isBot&&setTimeout(()=>this.runBotTurn(),500)}runBotTurn(){const e=this.state.tanks[this.state.currentTurnIndex];e&&e.isBot&&this.state.phase===f.AIMING&&(this.botState.planned||(this.planBotMove(e),this.botState.planned=!0),this.executeBotPlan(e))}planBotMove(e){this.botState.moveDir=Math.random()>.5?1:-1,this.botState.moveTimer=Math.floor(30*Math.random()),this.botState.aimTimer=1;const i=this.state.tanks.find(t=>t.id!==e.id&&t.health>0);if(i)if(e.health<35)this.botState.targetWeapon=c.HEAL,this.botState.targetAngle=90,this.botState.targetPower=15;else if(e.y>n-300){this.botState.targetWeapon=c.TELEPORT;const n=t/2-e.x;this.botState.targetAngle=n>0?60:120,this.botState.targetPower=80}else{const t=i.x-e.x,n=Math.abs(t),o=t>0?1:-1;if(n<400)this.botState.targetWeapon=Math.random()>.5?c.SCATTER:c.DRILL;else if(n>800)this.botState.targetWeapon=Math.random()>.6?c.NUKE:c.BASIC;else{const e=[c.BASIC,c.BARRAGE];this.botState.targetWeapon=e[Math.floor(Math.random()*e.length)]}const a=o>0?45:135;this.botState.targetAngle=a+(10*Math.random()-5);const r=Math.sqrt(n*v)/g*100,s=.1*(i.y-e.y);this.botState.targetPower=Math.max(10,Math.min(100,r+s+(10*Math.random()-5)))}}executeBotPlan(e){const t={moveTimer:this.botState.moveTimer,moveDir:this.botState.moveDir,aimTimer:this.botState.aimTimer,targetAngle:this.botState.targetAngle,targetPower:this.botState.targetPower,targetWeapon:this.botState.targetWeapon};t.moveTimer>0&&!e.isMoving&&(e.isMoving=!0,e.moveDir=t.moveDir,-1===t.moveDir?e.angle=Math.max(90,Math.min(180,e.angle)):e.angle=Math.max(0,Math.min(90,e.angle)));const n=e.id,i=e.playerId,o=()=>{const a=this.state.tanks[this.state.currentTurnIndex];if(!a||a.id!==n||this.state.phase!==f.AIMING)return e.isMoving=!1,void(e.moveDir=void 0);if(t.moveTimer>0)return t.moveTimer--,t.moveTimer<=0&&(e.isMoving=!1,e.moveDir=void 0),void requestAnimationFrame(o);if(t.aimTimer>0){e.weapon=t.targetWeapon;const n=t.targetAngle-e.angle;e.angle+=.4*n;const i=t.targetPower-e.power;return e.power+=.4*i,t.aimTimer--,void requestAnimationFrame(o)}e.angle=t.targetAngle,e.power=t.targetPower,this.handleFire(i||"BOT")};requestAnimationFrame(o)}startGame(){if(this.state.phase!==f.WAITING)return;if(!this.isHost)return;this.initTerrain();const e=this.state.players.length;this.state.tanks=this.state.players.map((n,i)=>{const o=`tank-${i+1}`;n.tankId=o;const a=Math.floor(t/2-1e3*e/2+1e3*(i+1)),r=this.getTerrainHeight(a);return{id:o,name:n.username||(n.isBot?"Bot":"Player"),playerId:n.id,isBot:!!n.isBot,x:a,y:r,angle:45,power:50,health:M,maxHealth:M,color:S[i%S.length],weapon:c.BASIC,fuel:T,lastFireTime:0}}),this.state.phase=f.AIMING,this.state.wind=.05*Math.random()-.025,this.state.currentTurnIndex=0,this.state.turnTimeEnd=Date.now()+(this.state.selectedMode===u.CHAOS?6e4:3e4),this.checkBotTurn()}reset(){this.isHost&&(this.state.phase=f.WAITING,this.state.tanks=[],this.state.currentTurnIndex=0,this.state.wind=0,this.state.winner=null,this.state.turnTimeEnd=0,this.state.players.forEach(e=>{e.tankId=null}),this.state.terrainSeed=Math.round(1e4*Math.random()),this.state.terrainMods=[],this.state.isSimulating=!1,this.state.gameStartTime=Date.now(),this._tankSimulations.clear(),this.initTerrain())}addBot(){if(!this.isHost)return;if(this.state.phase!==f.WAITING)return;const e=this.state.players.filter(e=>e.isBot).length,t=`BOT_${Math.random().toString(36).substr(2,5).toUpperCase()}`;this.state.players.push({id:t,username:`Bot ${e+1}`,tankId:null,isBot:!0})}removeBot(){if(!this.isHost)return;if(this.state.phase!==f.WAITING)return;const e=[...this.state.players].reverse().findIndex(e=>e.isBot);if(-1!==e){const t=this.state.players.length-1-e;this.state.players.splice(t,1)}}requestAddBot(){this.makeAction({type:"ADD_BOT"})}selectMode(e){this.makeAction({type:"SELECT_MODE",mode:e})}requestRemoveBot(){this.makeAction({type:"REMOVE_BOT"})}requestReset(){this.makeAction({type:"RESET_GAME"})}requestRegenerateMap(){const e=Math.round(1e4*Math.random());this.makeAction({type:"REGENERATE_MAP",seed:e})}handleRegenerateMap(e){this.state.terrainSeed=e,this.state.terrainMods=[],this._tankSimulations.clear(),this.initTerrain()}commitAngle(e){const t={type:"COMMIT_ANGLE",angle:e,playerId:this.userId};this.makeAction(t)}commitPower(e){const t={type:"COMMIT_POWER",power:e,playerId:this.userId};this.makeAction(t)}selectWeapon(e){const t={type:"SELECT_WEAPON",weapon:e,playerId:this.userId};this.makeAction(t)}moveStart(e){const t=this.getMyTank();if(!t||t.fuel<=0&&this.state.selectedMode!==u.CHAOS)return;const n={type:"MOVE_START",direction:e,x:t.x,playerId:this.userId};this.makeAction(n)}moveStop(){const e=this.getMyTank();if(!e)return;const t=this._tankSimulations.get(e.id),n={type:"MOVE_STOP",x:t?.x??e.x,y:t?.y??e.y,fuel:t?.fuel??e.fuel,playerId:this.userId};this.makeAction(n)}fire(){const e=this.getVisualTank(this.getMyTank()),t={type:"FIRE",playerId:this.userId,x:this.state.selectedMode===u.CHAOS?e?.x:void 0,y:this.state.selectedMode===u.CHAOS?e?.y:void 0};this.makeAction(t)}getTankByPlayerId(e){return this.state.tanks.find(t=>t.playerId===e)}isPlayerTurn(e){if(this.state.selectedMode===u.CHAOS)return!0;const t=this.state.tanks[this.state.currentTurnIndex];return t?.playerId===e}getMyTank(){return this.state.tanks.find(e=>e.playerId===this.userId)}isMyTurn(){return this.isPlayerTurn(this.userId)}getCurrentTank(){return this.state.tanks[this.state.currentTurnIndex]}canStartGame(){const e=this.state.selectedMode===u.CHAOS?1:2;return this.state.players.length>=e&&this.state.phase===f.WAITING}updatePlayers(e){if(!(this.players[0]?.id===this.userId))return;const t=[...this.state.players],n=t.filter(e=>e.isBot),i=e.map(e=>{const n=t.find(t=>t.id===e.id);return{id:e.id,username:e.username,tankId:n?.tankId||null,isBot:!1}});i.push(...n),this.state.players=i.slice(0,C)}destroy(){super.destroy()}}export{L as default};
