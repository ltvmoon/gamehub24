import{B as e}from"./BaseGame-DNFCKNJp.js";import{W as t,a as n,B as o,S as i,b as a,D as r,P as s,M as l,c as d,G as h,d as c,F as u,e as f,f as m,g as p,h as g,T as y,I as v,i as x}from"./constants-TU1irtgQ.js";import"./socket-DRbsQkF5.js";import"./index-C9Xpajrj.js";import"./react-vendor-CC_DdHLa.js";import"./zustand-CZbL3gdI.js";function T(e,t){let n=.1031*e+.3117*t;return n-=Math.floor(n),n*=n+33.33,n*=n+n,n-Math.floor(n)}function w(e,t){const n=Math.floor(e),o=e-n,i=o*o*(3-2*o);return T(n,t)*(1-i)+T(n+1,t)*i}function k(e,t){const n=function(e,t,n=4){let o=0,i=.5,a=1;for(let r=0;r<n;r++)o+=i*w(e*a,t+100*r),i*=.5,a*=2;return o}(e*o,t,2);return n<.1?2:n<.2?0:n<.3?1:n<.4?3:n<.5?5:n<.6?6:4}class S{bounds;entries=[];children=null;depth;static MAX_ENTRIES=8;static MAX_DEPTH=12;constructor(e,t=0){this.bounds=e,this.depth=t}insert(e){if(this.intersectsBounds(e.bounds))if(this.children)for(const t of this.children)t.intersectsBounds(e.bounds)&&t.insert(e);else this.entries.push(e),this.entries.length>S.MAX_ENTRIES&&this.depth<S.MAX_DEPTH&&this.split()}queryPoint(e,t){if(!this.containsPoint(e,t))return[];const n=[];for(const o of this.entries)this.pointInModification(e,t,o)&&n.push(o);if(this.children)for(const o of this.children)n.push(...o.queryPoint(e,t));return n}queryCircle(e,t,n){const o={x:e-n,y:t-n,width:2*n,height:2*n};if(!this.intersectsBounds(o))return[];const i=[];for(const a of this.entries)i.push(a);if(this.children)for(const a of this.children)i.push(...a.queryCircle(e,t,n));return i}clear(){this.entries=[],this.children=null}split(){const{x:e,y:t,width:n,height:o}=this.bounds,i=n/2,a=o/2;this.children=[new S({x:e,y:t,width:i,height:a},this.depth+1),new S({x:e+i,y:t,width:i,height:a},this.depth+1),new S({x:e,y:t+a,width:i,height:a},this.depth+1),new S({x:e+i,y:t+a,width:i,height:a},this.depth+1)];for(const r of this.entries)for(const e of this.children)e.intersectsBounds(r.bounds)&&e.insert(r)}containsPoint(e,t){return e>=this.bounds.x&&e<this.bounds.x+this.bounds.width&&t>=this.bounds.y&&t<this.bounds.y+this.bounds.height}intersectsBounds(e){return!(e.x>this.bounds.x+this.bounds.width||e.x+e.width<this.bounds.x||e.y>this.bounds.y+this.bounds.height||e.y+e.height<this.bounds.y)}pointInModification(e,t,n){const o=n.modification;if("carve"===o.type&&void 0!==o.vx&&void 0!==o.vy)return this.pointInCapsule(e,t,o.x,o.y,o.vx,o.vy,o.radius,o.length||100);const i=e-o.x,a=t-o.y;return i*i+a*a<=o.radius*o.radius}pointInCapsule(e,t,n,o,i,a,r,s){const l=Math.sqrt(i*i+a*a);if(0===l)return!1;const d=n+i/l*s-n,h=o+a/l*s-o,c=d*d+h*h;if(0===c){return(e-n)**2+(t-o)**2<=r*r}let u=((e-n)*d+(t-o)*h)/c;u=Math.max(0,Math.min(1,u));return(e-(n+u*d))**2+(t-(o+u*h))**2<=r*r}}class C{seed;quadtree;modificationCounter=0;modifications=[];bounds;static CACHE_SIZE=4096;static CACHE_MASK=4095;baseHeightCache=new Float32Array(C.CACHE_SIZE);baseHeightKeys=new Int32Array(C.CACHE_SIZE).fill(-999999);constructor(e,o=2*t,i=2*n){this.seed=e,this.bounds={x:-o/2,y:-i/2,width:2*o,height:2*i},this.quadtree=new S(this.bounds)}getBaseHeight(e){const o=Math.round(e),i=o&C.CACHE_MASK;if(this.baseHeightKeys[i]===o)return this.baseHeightCache[i];const a=function(e,o){const i=t,a=n;let r=a/1.6+(300*Math.sin(.001*(e+o))+80*Math.sin(.005*(e+2*o))+20*Math.sin(.02*(e+3*o)))+-200*Math.sin(e/i*Math.PI*5+o);return r=Math.max(200,Math.min(a-100,r)),r}(e,this.seed);return this.baseHeightKeys[i]=o,this.baseHeightCache[i]=a,a}getTerrainHeight(e){const t=this.getBaseHeight(e),o=this.quadtree.queryCircle(e,t/2,t/2+100);if(0===o.length)return t;let i=t;for(const n of o)if("add"===n.modification.type){const e=n.modification.y-n.modification.radius;e<i&&(i=e)}for(let a=Math.max(0,Math.floor(i));a<n;a+=4)if(this.isSolidFast(e,a,t)){for(let n=Math.max(0,a-4);n<=a;n++)if(this.isSolidFast(e,n,t))return n;return a}return t}isSolid(e,t){if(t>=n||t<0)return!1;const o=this.getBaseHeight(e);return this.isSolidFast(e,t,o)}isSolidFast(e,t,o){if(t>=n||t<0)return!1;let i=t>=o;const a=this.quadtree.queryPoint(e,t);if(0===a.length)return i;a.length>1&&a.sort((e,t)=>e.timestamp-t.timestamp);for(let n=0;n<a.length;n++){const o=a[n].modification,r=e-o.x,s=t-o.y,l=r*r+s*s,d=o._radiusSq;"destroy"===o.type?l<=d&&(i=!1):"add"===o.type?l<=d&&(i=!0):"carve"===o.type&&this.isInTunnel(e,t,o)&&(i=!1)}return i}destroyCircle(e,t,n){const o={type:"destroy",x:e,y:t,radius:n};this.addModification(o)}addCircle(e,t,n){const o={type:"add",x:e,y:t,radius:n};this.addModification(o)}carveTunnel(e,t,n,o,i,a=100){const r={type:"carve",x:e,y:t,radius:i,vx:n,vy:o,length:a};this.addModification(r)}getModifications(){return[...this.modifications]}applyModifications(e,t=!0){t&&(this.quadtree.clear(),this.modifications=[],this.modificationCounter=0,this.baseHeightKeys.fill(-999999));for(const n of e)this.addModification(n)}reset(e){this.seed=e,this.quadtree.clear(),this.modifications=[],this.modificationCounter=0,this.baseHeightKeys.fill(-999999)}addModification(e){if(e._radiusSq=e.radius*e.radius,void 0!==e.vx&&void 0!==e.vy){const t=Math.hypot(e.vx,e.vy);t>0&&(e._nx=e.vx/t,e._ny=e.vy/t)}const t={modification:e,bounds:this.getModificationBounds(e),timestamp:this.modificationCounter++};this.quadtree.insert(t),this.modifications.push(e)}getModificationBounds(e){if("carve"===e.type&&void 0!==e.vx&&void 0!==e.vy){const t=Math.sqrt(e.vx*e.vx+e.vy*e.vy);if(t>0){const n=e.vx/t,o=e.vy/t,i=e.length||100,a=e.x+n*i,r=e.y+o*i,s=Math.min(e.x,a)-e.radius,l=Math.max(e.x,a)+e.radius,d=Math.min(e.y,r)-e.radius;return{x:s,y:d,width:l-s,height:Math.max(e.y,r)+e.radius-d}}}return{x:e.x-e.radius,y:e.y-e.radius,width:2*e.radius,height:2*e.radius}}isInTunnel(e,t,n){const o=n._nx,i=n._ny;if(void 0===o||void 0===i)return!1;const a=n.length||100,r=o*a,s=i*a,l=a*a;if(0===l){return(e-n.x)**2+(t-n.y)**2<=n._radiusSq}let d=((e-n.x)*r+(t-n.y)*s)/l;d=Math.max(0,Math.min(1,d));return(e-(n.x+d*r))**2+(t-(n.y+d*s))**2<=n._radiusSq}getSeed(){return this.seed}}const M=256;class b{chunks=new Map;dirtyChunks=new Set;chunkAccessOrder=[];skyChunks=new Set;clearCache(){this.chunks.clear(),this.dirtyChunks.clear(),this.chunkAccessOrder=[],this.skyChunks.clear()}isChunkSkyOnly(e,t,n){const o=e*M,i=(t+1)*M;for(let r=0;r<=M;r+=32){const e=o+r;if(n.getBaseHeight(e)<i)return!1}const a=n.getModifications();for(const r of a)if("add"===r.type){const e=r.y-r.radius,n=r.y+r.radius,a=r.x-r.radius;if(r.x+r.radius>=o&&a<=o+M&&n>=t*M&&e<=i)return!1}return!0}renderVisibleChunks(e,t,n,o,i,a,r){const s=o/a,l=i/a,d=Math.floor(t/M),h=Math.ceil((t+s)/M),c=Math.floor(n/M),u=Math.ceil((n+l)/M);let f=0;const m=t+s/2,p=n+l/2,g=[];for(let y=d;y<=h;y++)for(let t=c;t<=u;t++){const n=`${y},${t}`;if(!this.skyChunks.has(n)||this.dirtyChunks.has(n))if(this.chunks.has(n)||this.dirtyChunks.has(n)||!this.isChunkSkyOnly(y,t,r))if(!this.chunks.has(n)||this.dirtyChunks.has(n)){const e=(y+.5)*M,o=(t+.5)*M,i=Math.abs(e-m)+Math.abs(o-p);g.push({cx:y,cy:t,key:n,dist:i})}else{const o=this.chunks.get(n);if(o){const i=y*M-.5,a=t*M-.5;e.drawImage(o,i,a,257,257),this.updateLRU(n)}}else this.skyChunks.add(n)}g.sort((e,t)=>e.dist-t.dist);for(const{cx:y,cy:v,key:x}of g){if(f>=4)break;if(this.dirtyChunks.has(x)&&(this.skyChunks.delete(x),this.isChunkSkyOnly(y,v,r))){this.skyChunks.add(x),this.dirtyChunks.delete(x),this.chunks.delete(x);continue}this.generateChunk(y,v,r),this.dirtyChunks.delete(x),f++;const t=this.chunks.get(x);if(t){const n=y*M-.5,o=v*M-.5;e.drawImage(t,n,o,257,257),this.updateLRU(x)}}this.pruneChunks()}invalidateArea(e,t,n){const o=Math.floor((e-n)/M),i=Math.ceil((e+n)/M),a=Math.floor((t-n)/M),r=Math.ceil((t+n)/M);for(let s=o;s<=i;s++)for(let e=a;e<=r;e++)this.dirtyChunks.add(`${s},${e}`)}invalidateTunnel(e,t,n,o,i,a){const r=Math.sqrt(n*n+o*o);if(0===r)return void this.invalidateArea(e,t,i);const s=e+n/r*a,l=t+o/r*a,d=Math.min(e,s)-i,h=Math.max(e,s)+i,c=Math.min(t,l)-i,u=Math.max(t,l)+i,f=Math.floor(d/M),m=Math.ceil(h/M),p=Math.floor(c/M),g=Math.ceil(u/M);for(let y=f;y<=m;y++)for(let e=p;e<=g;e++)this.dirtyChunks.add(`${y},${e}`)}clear(){this.chunks.clear(),this.dirtyChunks.clear(),this.chunkAccessOrder=[],this.skyChunks.clear()}generateChunk(e,t,o){const i=`${e},${t}`;let a=this.chunks.get(i);a||(a=document.createElement("canvas"),a.width=M,a.height=M,this.chunks.set(i,a));const r=a.getContext("2d");r.clearRect(0,0,M,M);const s=e*M,l=t*M,d=new Float32Array(257);for(let n=0;n<=M;n++)d[n]=o.getBaseHeight(s+n);const h={0:["#475569","#0f172a","#22c55e","#86efac"],1:["#737373","#262626","#a3a3a3","#e5e5e5"],2:["#2e4f36","#1a2e22","#166534","#4ade80"],3:["#d4a574","#8b4513","#d4a574","#f4d08a"],4:["#d1d5db","#5b6e80","#e5e7eb","#f9fafb"]},c=h[k(s+128,o.getSeed())]||h[0];r.beginPath();let u=!1;for(let n=0;n<=M;n++){const e=d[n]-l;e<=M&&(u?r.lineTo(n,Math.max(0,e)):(r.moveTo(n,Math.max(0,e)),u=!0))}r.lineTo(M,M),r.lineTo(0,M),r.closePath();const f=-l,m=n-l,p=r.createLinearGradient(0,f,0,m);p.addColorStop(0,c[0]),p.addColorStop(1,c[1]),r.fillStyle=p,r.fill(),r.globalCompositeOperation="source-atop";for(let n=0;n<15;n++){const e=4*Math.random()+1,t=Math.random()*M,n=Math.random()*M;r.fillStyle=Math.random()>.5?"rgba(0,0,0,0.2)":"rgba(255,255,255,0.05)",r.beginPath(),r.arc(t,n,e,0,2*Math.PI),r.fill()}r.globalCompositeOperation="source-over",r.beginPath();for(let n=0;n<=M;n++){const e=d[n]-l;0===n?r.moveTo(n,e):r.lineTo(n,e)}r.strokeStyle=c[2],r.lineWidth=15,r.lineCap="round",r.stroke(),r.strokeStyle=c[3],r.lineWidth=4,r.stroke(),this.applyModifications(r,s,l,o)}applyModifications(e,t,n,o){const i=o.getModifications();for(const a of i){const o=a.x-t,i=a.y-n,r=a.radius+20;if(o<-r||o>M+r||i<-r||i>M+r){if("carve"!==a.type||void 0===a.vx||void 0===a.vy)continue;{const e=Math.sqrt(a.vx*a.vx+a.vy*a.vy);if(e>0){const t=a.vx/e,n=a.vy/e,r=a.length||100,s=o+t*r,l=i+n*r,d=Math.min(o,s)-a.radius,h=Math.max(o,s)+a.radius,c=Math.min(i,l)-a.radius,u=Math.max(i,l)+a.radius;if(h<0||d>M||u<0||c>M)continue}}}if("destroy"===a.type){e.save(),e.globalCompositeOperation="destination-out",e.beginPath();for(let t=0;t<2*Math.PI;t+=.2){const n=a.radius*(.9+.2*Math.random()),r=o+Math.cos(t)*n,s=i+Math.sin(t)*n;0===t?e.moveTo(r,s):e.lineTo(r,s)}e.closePath(),e.fillStyle="#000",e.fill(),e.restore(),e.save(),e.globalCompositeOperation="source-atop",e.beginPath(),e.arc(o,i,a.radius+10,0,2*Math.PI),e.fillStyle="rgba(0, 0, 0, 0.5)",e.fill(),e.restore()}else if("add"===a.type)e.save(),e.globalCompositeOperation="source-over",e.beginPath(),e.arc(o,i,a.radius,0,2*Math.PI),e.fillStyle="#64748b",e.fill(),e.lineWidth=2,e.strokeStyle="#94a3b8",e.stroke(),e.restore();else if("carve"===a.type&&void 0!==a.vx&&void 0!==a.vy){const t=Math.sqrt(a.vx*a.vx+a.vy*a.vy);if(0===t)continue;const n=a.vx/t,r=a.vy/t,s=a.length||100;e.save(),e.globalCompositeOperation="destination-out",e.lineWidth=2*a.radius,e.lineCap="round",e.beginPath(),e.moveTo(o,i),e.lineTo(o+n*s,i+r*s),e.stroke(),e.restore(),e.save(),e.globalCompositeOperation="source-atop",e.lineWidth=2*a.radius+10,e.lineCap="round",e.strokeStyle="rgba(0,0,0,0.5)",e.beginPath(),e.moveTo(o,i),e.lineTo(o+n*s,i+r*s),e.stroke(),e.restore()}}}updateLRU(e){const t=this.chunkAccessOrder.indexOf(e);t>=0&&this.chunkAccessOrder.splice(t,1),this.chunkAccessOrder.push(e)}pruneChunks(){for(;this.chunks.size>64&&this.chunkAccessOrder.length>0;){const e=this.chunkAccessOrder.shift();this.chunks.delete(e),console.log("Pruned chunk",e)}}}const _=`#version 300 es\nprecision highp float;\n\nuniform float u_seed;\nuniform vec2 u_cameraPos;\nuniform vec2 u_viewSize;\nuniform float u_zoom;\nuniform vec2 u_worldSize;\nuniform sampler2D u_modTexture;\nuniform int u_modCount;\nuniform float u_time;\n\nout vec4 fragColor;\n\n// === Biome constants (must match CPU) ===\nconst float BIOME_SCALE = ${o.toFixed(10)};\nconst float SNOW_THRESHOLD = ${i.toFixed(1)};\n\n// Biome indices: 0=plains, 1=mountains, 2=valley, 3=desert, 4=tundra\n\n// === Noise functions ===\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat hash1D(float x, float seed) {\n  float p = x * 0.1031 + seed * 0.3117;\n  p = fract(p);\n  p *= p + 33.33;\n  p *= p + p;\n  return fract(p);\n}\n\nfloat noise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  f = f * f * (3.0 - 2.0 * f);\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nfloat noise1D(float x, float seed) {\n  float i = floor(x);\n  float f = fract(x);\n  float u = f * f * (3.0 - 2.0 * f);\n  return hash1D(i, seed) * (1.0 - u) + hash1D(i + 1.0, seed) * u;\n}\n\nfloat fbm(vec2 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * noise(p);\n    p *= 2.0;\n    amplitude *= 0.5;\n  }\n  return value;\n}\n\nfloat fbm1D(float x, float seed, int octaves) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n  for (int i = 0; i < octaves; i++) {\n    value += amplitude * noise1D(x * frequency, seed + float(i) * 100.0);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\n// === Biome detection (must match CPU) ===\nint getBiomeIndex(float x) {\n  // Match CPU chunk-based rendering (CHUNK_SIZE = 256)\n  // Sample at the center of each 256-pixel chunk\n  float chunkX = floor(x / 256.0) * 256.0 + 128.0;\n  float biomeNoise = fbm1D(chunkX * BIOME_SCALE, u_seed, 2);\n\n  // Map noise value (0-1) to biome index (0-6)\n  // Sync with CPU distribution logic\n  if (biomeNoise < 0.1) return 2; // Valley\n  if (biomeNoise < 0.2) return 0; // Plains\n  if (biomeNoise < 0.3) return 1; // Mountains\n  if (biomeNoise < 0.4) return 3; // Desert\n  if (biomeNoise < 0.5) return 5; // Swamp\n  if (biomeNoise < 0.6) return 6; // Volcanic\n  return 4; // Tundra\n}\n\n// === Simple terrain height (MUST MATCH CPU exactly!) ===\nfloat computeBaseHeight(float x) {\n  // Frequencies\n  float f1 = 0.001;\n  float f2 = 0.005;\n  float f3 = 0.02;\n\n  // Amplitudes\n  float a1 = 300.0;\n  float a2 = 80.0;\n  float a3 = 20.0;\n\n  // Noise from sine waves\n  float terrainNoise =\n    sin((x + u_seed) * f1) * a1 +\n    sin((x + u_seed * 2.0) * f2) * a2 +\n    sin((x + u_seed * 3.0) * f3) * a3;\n\n  // Mountain features\n  float mountain = sin((x / u_worldSize.x) * 3.14159265 * 5.0 + u_seed) * -200.0;\n\n  float y = u_worldSize.y / 1.6 + terrainNoise + mountain;\n\n  // Clamp to ensure playable area\n  return clamp(y, 200.0, u_worldSize.y - 100.0);\n}\n\n// === Tunnel check ===\nbool isInTunnel(float px, float py, float sx, float sy, float nx, float ny, float radius, float length) {\n  float dx = nx * length;\n  float dy = ny * length;\n  float len2 = length * length;\n  if (len2 == 0.0) {\n    float dist2 = (px - sx) * (px - sx) + (py - sy) * (py - sy);\n    return dist2 <= radius * radius;\n  }\n  float t = clamp(((px - sx) * dx + (py - sy) * dy) / len2, 0.0, 1.0);\n  float closestX = sx + t * dx;\n  float closestY = sy + t * dy;\n  float dist2 = (px - closestX) * (px - closestX) + (py - closestY) * (py - closestY);\n  return dist2 <= radius * radius;\n}\n\n// === Crater check ===\nbool isInCrater(float worldX, float worldY, float modX, float modY, float modRadius, out float edgeDist) {\n  float dx = worldX - modX;\n  float dy = worldY - modY;\n  float dist = sqrt(dx * dx + dy * dy);\n  float angle = atan(dy, dx);\n  vec2 noisePos = vec2(modX + modY * 0.37, angle * 3.0 + modRadius * 0.1);\n  float edgeNoise = fbm(noisePos * 0.5) * 0.3 + 0.85;\n  float detailNoise = noise(vec2(angle * 8.0 + modX, modY * 0.1)) * 0.15;\n  float irregularRadius = modRadius * (edgeNoise + detailNoise);\n  edgeDist = dist - irregularRadius;\n  return dist <= irregularRadius;\n}\n\n// === Star field ===\nfloat star(vec2 uv, float layer) {\n  vec2 id = floor(uv);\n  vec2 gridUV = fract(uv);\n  float starLight = 0.0;\n  for (int y = -1; y <= 1; y++) {\n    for (int x = -1; x <= 1; x++) {\n      vec2 neighbor = vec2(float(x), float(y));\n      vec2 cellId = id + neighbor;\n      vec2 starPos = neighbor + vec2(hash(cellId + layer * 17.0), hash(cellId + layer * 31.0 + 50.0)) * 0.8 + 0.1;\n      float starPresent = step(0.92, hash(cellId + layer * 47.0));\n      if (starPresent < 0.5) continue;\n      float d = length(gridUV - starPos);\n      // Increased size to match CPU (0.5 to 2.5px)\n      // UV is screenPos/40.0, so 0.02 is 0.8px, 0.06 is 2.4px\n      float size = hash(cellId + layer * 63.0) * 0.04 + 0.012;\n      float glow = exp(-d * d / (size * size * 2.0));\n      float brightness = hash(cellId + layer * 79.0) * 0.7 + 0.3;\n      starLight += glow * brightness;\n    }\n  }\n  return clamp(starLight, 0.0, 1.0);\n}\n\n// === Procedural Clouds ===\nfloat cloudNoise(vec2 uv) {\n  float n = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n  for (int i = 0; i < 5; i++) {\n    n += amplitude * noise(uv * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return n;\n}\n\nvec4 getCloud(vec2 uv, float layer) {\n  // Cloud shape using layered noise\n  float cloudShape = cloudNoise(uv * 0.15 + layer * 50.0);\n  cloudShape += cloudNoise(uv * 0.4 + layer * 30.0) * 0.4;\n  cloudShape += cloudNoise(uv * 0.8 + layer * 10.0) * 0.2;\n\n  // Higher threshold = fewer, more distinct clouds\n  float cloudDensity = smoothstep(0.55, 0.75, cloudShape);\n\n  // Only render where there's actually a cloud (sparse)\n  if (cloudDensity < 0.01) {\n    return vec4(0.0);\n  }\n\n  // Cloud brightness variation\n  float brightness = 0.85 + cloudNoise(uv * 2.0 + layer * 5.0) * 0.15;\n\n  // Fluffy edges for defined cloud shapes\n  float edge = smoothstep(0.5, 0.7, cloudShape);\n  float alpha = cloudDensity * edge * 0.7;\n\n  vec3 cloudColor = vec3(brightness);\n  return vec4(cloudColor, alpha);\n}\n\n// === Weather Particles (snow, sand) ===\nfloat weatherParticle(vec2 screenPos, vec2 cameraPos, float particleSize, float fallSpeed, float drift) {\n  // Use a mix of screen and camera position for parallax effect\n  vec2 uv = (screenPos + vec2(cameraPos.x, -cameraPos.y) * 0.4 * u_zoom) / particleSize;\n  vec2 cellId = floor(uv);\n  vec2 cellUV = fract(uv);\n\n  float particles = 0.0;\n\n  for (int dy = -1; dy <= 1; dy++) {\n    for (int dx = -1; dx <= 1; dx++) {\n      vec2 neighbor = vec2(float(dx), float(dy));\n      vec2 id = cellId + neighbor;\n\n      // Random offset within cell\n      float randX = hash1D(id.x * 0.1, id.y * 0.2);\n      float randY = hash1D(id.y * 0.3, id.x * 0.4);\n      float randPresent = hash1D(id.x, id.y + 200.0);\n\n      // Reduced density from 0.25 to 0.15\n      if (randPresent < 0.15) {\n        vec2 particlePos = neighbor + vec2(randX * 0.8 + 0.1, randY * 0.8 + 0.1);\n\n        // Time-based motion with CPU-side modulo for precision\n        float timeScale = u_time * 0.0006;\n        float progress = fract(randY * 10.0 - timeScale * fallSpeed * 10.0);\n        particlePos.y += progress;\n        particlePos.x += sin(u_time * 0.0005 * drift * 5.0 + randX * 6.28) * 0.4;\n\n        // Vertical fade to avoid "jumping" or "jitter" at cell boundaries\n        float verticalFade = smoothstep(0.0, 0.2, progress) * smoothstep(1.0, 0.7, progress);\n\n        float d = length(cellUV - particlePos);\n        float size = 0.04 + randX * 0.08;\n        particles += smoothstep(size, size * 0.5, d) * verticalFade;\n      }\n    }\n  }\n\n  return clamp(particles, 0.0, 1.0);\n}\n\n// === Rain Particles (thin streaks) ===\nfloat rainParticle(vec2 screenPos, vec2 cameraPos) {\n  // Elongated grid for streaks\n  vec2 uv = (screenPos + vec2(cameraPos.x, -cameraPos.y) * 0.4 * u_zoom) / vec2(8.0, 80.0);\n  vec2 cellId = floor(uv);\n  vec2 cellUV = fract(uv);\n\n  float rain = 0.0;\n  for (int dy = -1; dy <= 0; dy++) {\n    vec2 id = cellId + vec2(0.0, float(dy));\n    float randX = hash1D(id.x, id.y + 500.0);\n    float randY = hash1D(id.y, id.x + 600.0);\n\n    if (randX < 0.2) {\n      float timeScale = u_time * 0.005;\n      float progress = fract(randY - timeScale * (1.2 + randX));\n\n      float xOffset = randX * 5.0; // Random horizontal placement in cell\n      float dX = abs(cellUV.x - xOffset);\n      float dY = abs(cellUV.y - (float(dy) + progress));\n\n      // Thin vertical streak\n      if (dX < 0.1 && dY < 0.4) {\n        rain += (1.0 - dY * 2.5) * (1.0 - dX * 10.0);\n      }\n    }\n  }\n  return clamp(rain, 0.0, 1.0);\n}\n\n// === Point Light Calculation ===\n#define MAX_LIGHTS 10 // Define max number of lights\nuniform vec2 u_lightPos[MAX_LIGHTS];\nuniform vec3 u_lightColor[MAX_LIGHTS];\nuniform float u_lightRadius[MAX_LIGHTS];\nuniform int u_lightCount;\n\nvec3 calculateLighting(vec2 worldPos, vec3 baseColor) {\n  vec3 totalLight = vec3(0.0);\n  for (int i = 0; i < u_lightCount; i++) {\n    float dx = worldPos.x - u_lightPos[i].x;\n    float dy = worldPos.y - u_lightPos[i].y;\n    float dist = sqrt(dx*dx + dy*dy);\n\n    if (dist < u_lightRadius[i]) {\n      float atten = 1.0 - smoothstep(0.0, u_lightRadius[i], dist);\n      // Square the attenuation for a more natural falloff\n      atten = atten * atten;\n      totalLight += u_lightColor[i] * atten;\n    }\n  }\n\n  // Apply light to the base color (additive for a "glow" feel)\n  return baseColor + totalLight * 0.8;\n}\n\n// === Biome color palettes ===\nvec3 getPlainsColor(float depth, float worldY, float baseH) {\n  vec3 dirtColor = vec3(0.278, 0.333, 0.412);\n  vec3 deepColor = vec3(0.059, 0.090, 0.165);\n  vec3 grassColor = vec3(0.133, 0.773, 0.369);\n  vec3 grassLight = vec3(0.525, 0.937, 0.675);\n\n  vec3 color = mix(dirtColor, deepColor, worldY / u_worldSize.y);\n  if (depth >= 0.0 && depth < 15.0) {\n    color = depth < 4.0 ? grassLight : grassColor;\n  }\n  return color;\n}\n\nvec3 getMountainsColor(float depth, float worldY, float baseH) {\n  vec3 rockDark = vec3(0.25, 0.25, 0.28);\n  vec3 rockLight = vec3(0.45, 0.45, 0.5);\n  vec3 snowColor = vec3(0.95, 0.97, 1.0);\n  vec3 snowShadow = vec3(0.75, 0.82, 0.9);\n\n  vec3 color = mix(rockLight, rockDark, worldY / u_worldSize.y);\n\n  // Snow on high peaks\n  if (baseH < SNOW_THRESHOLD) {\n    float snowBlend = smoothstep(SNOW_THRESHOLD, SNOW_THRESHOLD - 50.0, baseH);\n    vec3 snow = depth < 5.0 ? snowColor : snowShadow;\n    color = mix(color, snow, snowBlend);\n  }\n  return color;\n}\n\nvec3 getValleyColor(float depth, float worldY, float baseH) {\n  vec3 grassDark = vec3(0.08, 0.45, 0.22);\n  vec3 grassLight = vec3(0.15, 0.65, 0.35);\n  vec3 dirtColor = vec3(0.35, 0.25, 0.18);\n\n  vec3 color = mix(grassLight, dirtColor, worldY / u_worldSize.y);\n  if (depth >= 0.0 && depth < 12.0) {\n    color = depth < 3.0 ? grassLight : grassDark;\n  }\n  return color;\n}\n\nvec3 getDesertColor(float depth, float worldY, float baseH) {\n  vec3 sandLight = vec3(0.93, 0.85, 0.65);\n  vec3 sandDark = vec3(0.75, 0.60, 0.40);\n  vec3 rockColor = vec3(0.55, 0.45, 0.35);\n\n  vec3 color = mix(sandLight, rockColor, worldY / u_worldSize.y);\n  if (depth >= 0.0 && depth < 8.0) {\n    color = depth < 3.0 ? sandLight : sandDark;\n  }\n  return color;\n}\n\nvec3 getTundraColor(float depth, float worldY, float baseH) {\n  vec3 snowWhite = vec3(0.92, 0.95, 0.98);\n  vec3 iceBluePale = vec3(0.80, 0.88, 0.95);\n  vec3 iceBlue = vec3(0.55, 0.70, 0.85);\n  vec3 frozenGround = vec3(0.45, 0.50, 0.55);\n\n  vec3 color = mix(iceBluePale, frozenGround, worldY / u_worldSize.y);\n  if (depth >= 0.0 && depth < 10.0) {\n    color = depth < 3.0 ? snowWhite : iceBlue;\n  }\n  return color;\n}\n\nvec3 getSwampColor(float worldX, float depth, float worldY, float baseH) {\n  vec3 muckColor = vec3(0.15, 0.18, 0.12);\n  vec3 waterColor = vec3(0.1, 0.25, 0.15);\n  vec3 mossColor = vec3(0.2, 0.4, 0.1);\n  vec3 grassColor = vec3(0.1, 0.3, 0.05);\n\n  vec3 color = mix(muckColor, vec3(0.05, 0.08, 0.05), worldY / u_worldSize.y);\n  if (depth >= 0.0 && depth < 15.0) {\n    color = depth < 4.0 ? mossColor : grassColor;\n    if (noise(vec2(worldX * 0.1, worldY * 0.5)) > 0.6) color = waterColor;\n  }\n  return color;\n}\n\nvec3 getVolcanicColor(float worldX, float depth, float worldY, float baseH) {\n  vec3 basaltColor = vec3(0.12, 0.12, 0.15);\n  vec3 ashColor = vec3(0.25, 0.25, 0.28);\n  vec3 lavaGlow = vec3(0.8, 0.2, 0.0);\n\n  vec3 color = mix(basaltColor, vec3(0.05, 0.05, 0.08), worldY / u_worldSize.y);\n  if (depth >= 0.0 && depth < 10.0) {\n    float lavaNoise = noise(vec2(worldX * 0.05, worldY * 0.1 + u_time * 0.001));\n    color = depth < 3.0 ? ashColor : basaltColor;\n    if (lavaNoise > 0.8) color = mix(color, lavaGlow, (lavaNoise - 0.8) * 5.0);\n  }\n  return color;\n}\n\n// === Terrain Decorations (Trees, Rocks) ===\nvec4 getDecorationColor(float worldX, float worldY, float baseH, int biomeIdx) {\n  float dy_ground = worldY - baseH;\n\n  // Grid-based Large Decorations\n  float decoGrid = 200.0;\n  float cellId = floor(worldX / decoGrid);\n  float cellRand = hash1D(cellId, u_seed * 1.5);\n\n  if (cellRand > 0.4) {\n    float decoX = (cellId + 0.3 + cellRand * 0.4) * decoGrid;\n    float decoH = computeBaseHeight(decoX);\n    float dx = worldX - decoX;\n    float dy = worldY - decoH;\n\n    // Trees (Plains/Valley/Tundra)\n    if (biomeIdx == 0 || biomeIdx == 2 || biomeIdx == 4) {\n      float trunkW = 4.0;\n      float trunkH = 40.0 + cellRand * 30.0;\n      if (biomeIdx == 4) trunkH *= 1.5; // Increased from 0.7 to 1.5\n\n      // Trunk\n      if (abs(dx) < trunkW && dy < 0.0 && dy > -trunkH) {\n        return vec4(0.25, 0.15, 0.08, 1.0);\n      }\n\n      // Foliage\n      float leafY = dy + trunkH * 0.9;\n      if (biomeIdx == 4) { // Pine shape for Tundra\n        float pineW = (dy + trunkH) * 0.5; // Increased width factor to 0.5\n        if (abs(dx) < pineW && dy < 0.0 && dy > -trunkH * 1.1) {\n          float noiseVal = noise(vec2(worldX * 0.2, worldY * 0.2));\n          vec3 leafColor = mix(vec3(0.1, 0.2, 0.15), vec3(0.8, 0.85, 0.9), step(0.6, noiseVal));\n          return vec4(leafColor, 1.0);\n        }\n      } else { // Fluffy trees for Plains/Valley\n        float dLeaf = length(vec2(dx, leafY));\n        float leafRadius = 30.0 + cellRand * 20.0;\n        float leafNoise = noise(vec2(worldX * 0.08, worldY * 0.08 + cellId)) * 12.0;\n        if (dLeaf < leafRadius + leafNoise) {\n          vec3 leafBase = (biomeIdx == 2) ? vec3(0.05, 0.3, 0.1) : vec3(0.15, 0.5, 0.1);\n          vec3 leafTop = leafBase + 0.2;\n          vec3 leafColor = mix(leafBase, leafTop, clamp(-dy/trunkH, 0.0, 1.0));\n          return vec4(leafColor, 1.0);\n        }\n      }\n    }\n    // Swamp Trees\n    else if (biomeIdx == 5) {\n      float trunkW = 6.0;\n      float trunkH = 50.0 + cellRand * 40.0;\n      if (abs(dx) < trunkW && dy < 0.0 && dy > -trunkH) {\n        return vec4(0.18, 0.12, 0.05, 1.0); // Darker trunk\n      }\n      // Drooping foliage\n      float leafY = dy + trunkH * 0.8;\n      float dLeaf = length(vec2(dx * 0.7, leafY));\n      float leafRadius = 40.0 + cellRand * 25.0;\n      if (dLeaf < leafRadius) {\n        float noiseVal = noise(vec2(worldX * 0.1, worldY * 0.1));\n        vec3 leafColor = mix(vec3(0.05, 0.15, 0.05), vec3(0.1, 0.25, 0.1), noiseVal);\n        return vec4(leafColor, 1.0);\n      }\n    }\n    // Volcanic Pillars/Rocks\n    else if (biomeIdx == 6) {\n      float pillarW = 15.0 + cellRand * 20.0;\n      float pillarH = 30.0 + cellRand * 60.0;\n      // Sharp, jagged shapes\n      float jagged = noise(vec2(worldX * 0.2, worldY * 0.1)) * 10.0;\n      if (abs(dx) < (pillarW - dy * 0.2) + jagged && dy < 0.0 && dy > -pillarH) {\n        float glow = step(0.8, noise(vec2(worldX * 0.1, worldY * 0.1 + u_time * 0.002)));\n        vec3 color = mix(vec3(0.1, 0.1, 0.12), vec3(0.6, 0.2, 0.0), glow * 0.5);\n        return vec4(color, 1.0);\n      }\n    }\n    // Smooth Boulders (Mountains/Desert)\n    else {\n      // Use elliptical shape and low-frequency noise for smoothness\n      float rockSize = 25.0 + cellRand * 25.0;\n      vec2 stretch = vec2(1.2 + cellRand * 0.4, 0.8 + cellRand * 0.2); // Elliptical distortion\n\n      // Sink rock into the ground by a random amount (0.2 to 0.7 of its size)\n      float sinkDepth = rockSize * (0.2 + cellRand * 0.5);\n      vec2 rockUV = vec2(dx / stretch.x, (dy + sinkDepth) / stretch.y);\n      float dRock = length(rockUV);\n\n      // Smooth, low-frequency noise instead of jagged detail\n      float rockNoise = noise(vec2(worldX * 0.05, worldY * 0.05 + cellId)) * (rockSize * 0.3);\n      rockNoise += noise(vec2(worldX * 0.1, worldY * 0.1)) * (rockSize * 0.1);\n\n      if (dRock < rockSize + rockNoise) {\n        vec3 rockBase = (biomeIdx == 3) ? vec3(0.7, 0.55, 0.35) : vec3(0.4, 0.4, 0.45);\n        vec3 rockHighlight = rockBase + 0.15;\n        // Smooth shading\n        float shading = dot(normalize(rockUV), normalize(vec2(-1.0, -1.0)));\n        vec3 rockColor = mix(rockBase, rockHighlight, shading * 0.4 + 0.6);\n        return vec4(rockColor, 1.0);\n      }\n    }\n  }\n\n  // Small Surface Details (Grass/Pebbles) - only rendered if solid is true in main\n  return vec4(0.0);\n}\n\n// Get biome color with smooth blending at boundaries\nvec3 getBiomeColorBlended(float worldX, float worldY, float baseH) {\n  float depth = worldY - baseH;\n\n  // BIOME_SCALE is very small, so we use a reasonable transition width\n  float blendWidth = ${a.toFixed(1)};\n\n  // Find current and neighbor biomes for blending\n  int currentBiome = getBiomeIndex(worldX);\n\n  // Check transitions at chunk boundaries (every 256px) or continuous?\n  // CPU uses CHUNK_SIZE/2 offset for getBiomeIndex sampling.\n  // We want to blend between the zones.\n\n  float chunkX = floor(worldX / 256.0) * 256.0 + 128.0;\n  float nextChunkX = chunkX + 256.0;\n  float prevChunkX = chunkX - 256.0;\n\n  int nextBiome = getBiomeIndex(nextChunkX);\n  int prevBiome = getBiomeIndex(prevChunkX);\n\n  vec3 color;\n  if (currentBiome == 0) color = getPlainsColor(depth, worldY, baseH);\n  else if (currentBiome == 1) color = getMountainsColor(depth, worldY, baseH);\n  else if (currentBiome == 2) color = getValleyColor(depth, worldY, baseH);\n  else if (currentBiome == 3) color = getDesertColor(depth, worldY, baseH);\n  else if (currentBiome == 4) color = getTundraColor(depth, worldY, baseH);\n  else if (currentBiome == 5) color = getSwampColor(worldX, depth, worldY, baseH);\n  else color = getVolcanicColor(worldX, depth, worldY, baseH);\n\n  // Smoothly blend with neighbors\n  float distToNext = nextChunkX - 128.0 - worldX;\n  float distToPrev = worldX - (prevChunkX + 128.0);\n\n  if (distToNext < 128.0 && nextBiome != currentBiome) {\n    float t = smoothstep(128.0, 0.0, distToNext);\n    vec3 nextColor;\n    if (nextBiome == 0) nextColor = getPlainsColor(depth, worldY, baseH);\n    else if (nextBiome == 1) nextColor = getMountainsColor(depth, worldY, baseH);\n    else if (nextBiome == 2) nextColor = getValleyColor(depth, worldY, baseH);\n    else if (nextBiome == 3) nextColor = getDesertColor(depth, worldY, baseH);\n    else if (nextBiome == 4) nextColor = getTundraColor(depth, worldY, baseH);\n    else if (nextBiome == 5) nextColor = getSwampColor(worldX, depth, worldY, baseH);\n    else nextColor = getVolcanicColor(worldX, depth, worldY, baseH);\n    color = mix(color, nextColor, t * 0.5);\n  }\n\n  if (distToPrev < 128.0 && prevBiome != currentBiome) {\n    float t = smoothstep(128.0, 0.0, distToPrev);\n    vec3 prevColor;\n    if (prevBiome == 0) prevColor = getPlainsColor(depth, worldY, baseH);\n    else if (prevBiome == 1) prevColor = getMountainsColor(depth, worldY, baseH);\n    else if (prevBiome == 2) prevColor = getValleyColor(depth, worldY, baseH);\n    else if (prevBiome == 3) prevColor = getDesertColor(depth, worldY, baseH);\n    else if (prevBiome == 4) prevColor = getTundraColor(depth, worldY, baseH);\n    else if (prevBiome == 5) prevColor = getSwampColor(worldX, depth, worldY, baseH);\n    else prevColor = getVolcanicColor(worldX, depth, worldY, baseH);\n    color = mix(color, prevColor, t * 0.5);\n  }\n\n  return color;\n}\n\nvoid main() {\n  vec2 screenPos = gl_FragCoord.xy;\n  float worldX = u_cameraPos.x + screenPos.x / u_zoom;\n  float worldY = u_cameraPos.y + (u_viewSize.y - screenPos.y) / u_zoom;\n\n  float baseH = computeBaseHeight(worldX);\n  bool solid = worldY >= baseH;\n  int biomeIdx = getBiomeIndex(worldX);\n\n  float nearestCraterDist = 1000.0;\n  float nearestCraterRadius = 0.0;\n\n  // Track terrain modification masking\n  bool masked = false;\n\n  // Apply modifications\n  for (int i = 0; i < u_modCount; i++) {\n    vec4 data0 = texelFetch(u_modTexture, ivec2(i, 0), 0);\n    float modType = data0.r;\n    float modX = data0.g;\n    float modY = data0.b;\n    float modRadius = data0.a;\n\n    if (modType < 0.5) {\n      float edgeDist;\n      if (isInCrater(worldX, worldY, modX, modY, modRadius, edgeDist)) {\n        solid = false;\n        masked = true;\n      }\n      float dx = worldX - modX;\n      float dy = worldY - modY;\n      float dist = sqrt(dx * dx + dy * dy);\n      if (dist < nearestCraterDist) {\n        nearestCraterDist = dist;\n        nearestCraterRadius = modRadius;\n      }\n    } else if (modType < 1.5) {\n      float dx = worldX - modX;\n      float dy = worldY - modY;\n      if (dx * dx + dy * dy <= modRadius * modRadius) solid = true;\n    } else {\n      vec4 data1 = texelFetch(u_modTexture, ivec2(i, 1), 0);\n      if (isInTunnel(worldX, worldY, modX, modY, data1.r, data1.g, modRadius, data1.b)) {\n        solid = false;\n        masked = true;\n      }\n    }\n  }\n\n  // === New: Popup Decorations check (rendered above terrain, hidden by craters) ===\n  if (!masked) {\n    vec4 deco = getDecorationColor(worldX, worldY, baseH, biomeIdx);\n    if (deco.a > 0.0) {\n      fragColor = vec4(deco.rgb, 1.0);\n      return;\n    }\n  }\n\n  // === Sky rendering (for non-solid pixels) ===\n  if (!solid) {\n    float skyT = screenPos.y / u_viewSize.y;\n    // === Day/Night Cycle ===\n    float timeOfDay = fract(u_time / ${r.toFixed(1)});\n\n    // Light factor (0.0 at midnight, 1.0 at noon)\n    // Shifted so 0.25 is noon, 0.75 is midnight\n    float lightFactor = smoothstep(-0.5, 0.5, cos((timeOfDay - 0.25) * 6.283185));\n\n    // Dusk/Dawn factor for reddish horizon\n    float horizonFactor = smoothstep(0.3, 0.0, abs(timeOfDay - 0.0)) +\n                          smoothstep(0.3, 0.0, abs(timeOfDay - 0.5)) +\n                          smoothstep(0.3, 0.0, abs(timeOfDay - 1.0));\n    horizonFactor = clamp(horizonFactor, 0.0, 1.0);\n\n    vec3 skyTopNight = vec3(0.008, 0.02, 0.08);\n    vec3 skyBotNight = vec3(0.05, 0.08, 0.2);\n    vec3 skyTopDay = vec3(0.2, 0.4, 0.8);\n    vec3 skyBotDay = vec3(0.5, 0.7, 0.95);\n    vec3 horizonColor = vec3(1.0, 0.4, 0.2);\n\n    vec3 skyTop = mix(skyTopNight, skyTopDay, lightFactor);\n    vec3 skyBot = mix(skyBotNight, skyBotDay, lightFactor);\n    skyBot = mix(skyBot, horizonColor, horizonFactor * (1.0 - skyT));\n\n    vec3 skyColor = mix(skyBot, skyTop, skyT);\n\n    // Stars (only at night)\n    float starIntensity = smoothstep(0.4, 0.1, lightFactor);\n    if (starIntensity > 0.0) {\n      vec2 starUV = (screenPos + vec2(u_cameraPos.x, -u_cameraPos.y) * 0.05) / 40.0;\n      float stars = star(starUV, 1.0) * 0.8 + star(starUV * 1.5 + 100.0, 2.0) * 0.5 + star(starUV * 2.0 + 200.0, 3.0) * 0.3;\n      skyColor += vec3(stars) * starIntensity;\n    }\n\n    // === Weather particles based on biome ===\n    // Lower threshold globally (0.5 -> 0.3) to make weather more common\n    float weatherIntensity = noise1D(worldX * 0.0005, u_seed + 1234.0);\n    float weatherThreshold = 0.3;\n\n    // Tundra override: Snow is even more frequent\n    if (biomeIdx == 4) weatherThreshold = 0.15;\n\n    if (weatherIntensity > weatherThreshold) {\n      float intensity = smoothstep(weatherThreshold, weatherThreshold + 0.1, weatherIntensity);\n\n      // Tundra - falling snow\n      if (biomeIdx == 4) {\n        float snow = weatherParticle(screenPos, u_cameraPos, 20.0, 0.6, 0.2);\n        skyColor = mix(skyColor, vec3(1.0), snow * 0.5 * intensity);\n      }\n      // Desert - blowing sand/dust\n      else if (biomeIdx == 3) {\n        float sand = weatherParticle(screenPos, u_cameraPos, 25.0, 0.3, 0.7);\n        skyColor = mix(skyColor, vec3(0.9, 0.8, 0.6), sand * 0.2 * intensity);\n      }\n      // Plain, Valley, Swamp - rain\n      else if (biomeIdx == 0 || biomeIdx == 2 || biomeIdx == 5) {\n        float rain = rainParticle(screenPos, u_cameraPos);\n        vec3 rainColor = (biomeIdx == 5) ? vec3(0.4, 0.5, 0.4) : vec3(0.6, 0.7, 0.8);\n        skyColor = mix(skyColor, rainColor, rain * 0.5 * intensity);\n      }\n      // Volcanic - rising ash/embers\n      else if (biomeIdx == 6) {\n        // Use weatherParticle with negative fallSpeed for "rising" ash\n        float ash = weatherParticle(screenPos, u_cameraPos, 15.0, -0.3, 0.5);\n        vec3 emberColor = mix(vec3(0.2, 0.2, 0.2), vec3(1.0, 0.3, 0.0), step(0.7, noise(screenPos * 0.1)));\n        skyColor = mix(skyColor, emberColor, ash * 0.4 * intensity);\n      }\n    }\n\n    fragColor = vec4(skyColor, 1.0);\n\n    // Apply lighting to sky (smoke/fog effect)\n    fragColor.rgb = calculateLighting(vec2(worldX, worldY), fragColor.rgb);\n    return;\n  }\n\n  // === Terrain color with biome blending ===\n  vec3 color = getBiomeColorBlended(worldX, worldY, baseH);\n\n  // Texture noise\n  float texNoise = fract(sin(dot(vec2(worldX, worldY), vec2(12.9898, 78.233))) * 43758.5453);\n  color += (texNoise - 0.5) * 0.04;\n\n  // === Surface Decorations (Grass) ===\n  float depth = worldY - baseH;\n  if (depth >= 0.0 && depth < 25.0) {\n    float grassPattern = noise(vec2(worldX * 0.3, worldY * 1.5 + u_seed));\n    float grassHeight = noise(vec2(worldX * 0.2 + u_seed, 0.0)) * 15.0 + 8.0;\n    float grassBlade = smoothstep(grassHeight, 0.0, depth) * step(0.35, grassPattern);\n\n    if (grassBlade > 0.0) {\n      vec3 gColor;\n      if (biomeIdx == 0) gColor = mix(vec3(0.2, 0.7, 0.2), vec3(0.4, 0.9, 0.3), grassPattern);\n      else if (biomeIdx == 1) gColor = mix(vec3(0.3, 0.4, 0.3), vec3(0.4, 0.5, 0.4), grassPattern);\n      else if (biomeIdx == 2) gColor = mix(vec3(0.1, 0.5, 0.2), vec3(0.2, 0.7, 0.3), grassPattern);\n      else if (biomeIdx == 3) gColor = mix(vec3(0.6, 0.5, 0.3), vec3(0.4, 0.6, 0.2), grassPattern);\n      else gColor = mix(vec3(0.8, 0.9, 1.0), vec3(0.6, 0.7, 0.8), grassPattern);\n      color = mix(color, gColor, grassBlade * 0.9);\n    }\n  }\n\n  // Scorch marks\n  if (nearestCraterRadius > 0.0) {\n    float scorchOuter = nearestCraterRadius * 1.4;\n    if (nearestCraterDist <= scorchOuter) {\n      float scorchT = 1.0 - (nearestCraterDist - nearestCraterRadius * 0.7) / (scorchOuter - nearestCraterRadius * 0.7);\n      scorchT = clamp(scorchT, 0.0, 1.0);\n      float scorchNoise = noise(vec2(worldX * 0.2, worldY * 0.2)) * 0.3;\n      scorchT = clamp(scorchT + scorchNoise - 0.15, 0.0, 1.0);\n      vec3 scorchColor = mix(vec3(0.15, 0.1, 0.05), vec3(0.02, 0.01, 0.01), scorchT * 0.5);\n      color = mix(color, scorchColor, scorchT * 0.7);\n      if (nearestCraterDist <= nearestCraterRadius * 1.1) {\n        float innerT = 1.0 - (nearestCraterDist / (nearestCraterRadius * 1.1));\n        color = mix(color, vec3(0.0), innerT * 0.6);\n      }\n    }\n  }\n\n  // Apply Day/Night lighting (re-use factor)\n  float timeOfDay = fract(u_time / ${r.toFixed(1)});\n  float lightFactor = smoothstep(-0.5, 0.5, cos((timeOfDay - 0.25) * 6.283185));\n  float ambLight = mix(0.25, 1.0, lightFactor);\n\n  // Tint during dusk/dawn\n  float horizonFactor = smoothstep(0.3, 0.0, abs(timeOfDay - 0.0)) +\n                        smoothstep(0.3, 0.0, abs(timeOfDay - 0.5)) +\n                        smoothstep(0.3, 0.0, abs(timeOfDay - 1.0));\n  horizonFactor = clamp(horizonFactor, 0.0, 1.0);\n  vec3 tint = mix(vec3(1.0), vec3(1.0, 0.8, 0.7), horizonFactor);\n\n  color *= ambLight * tint;\n\n  // Apply Point Lights\n  color = calculateLighting(vec2(worldX, worldY), color);\n\n  fragColor = vec4(color, 1.0);\n}\n`,I=4096;class P{gl=null;program=null;vao=null;modTexture=null;uniforms={seed:null,cameraPos:null,viewSize:null,zoom:null,worldSize:null,modTexture:null,modCount:null,time:null,lightPos:null,lightColor:null,lightRadius:null,lightCount:null};modTextureData;lastModCount=0;isInitialized=!1;constructor(){this.modTextureData=new Float32Array(32768)}init(e){const t=e.getContext("webgl2",{alpha:!0,antialias:!1,premultipliedAlpha:!1});if(!t)return console.warn("WebGL2 not available, falling back to CPU rendering"),!1;this.gl=t;const n=this.compileShader(t,t.VERTEX_SHADER,"#version 300 es\nprecision highp float;\n\n// Fullscreen quad vertices (2 triangles)\nconst vec2 positions[6] = vec2[](\n  vec2(-1.0, -1.0),\n  vec2( 1.0, -1.0),\n  vec2( 1.0,  1.0),\n  vec2(-1.0, -1.0),\n  vec2( 1.0,  1.0),\n  vec2(-1.0,  1.0)\n);\n\nvoid main() {\n  gl_Position = vec4(positions[gl_VertexID], 0.0, 1.0);\n}\n"),o=this.compileShader(t,t.FRAGMENT_SHADER,_);if(!n||!o)return console.error("Failed to compile shaders"),!1;const i=t.createProgram();return!!i&&(t.attachShader(i,n),t.attachShader(i,o),t.linkProgram(i),t.getProgramParameter(i,t.LINK_STATUS)?(this.program=i,this.uniforms={seed:t.getUniformLocation(i,"u_seed"),cameraPos:t.getUniformLocation(i,"u_cameraPos"),viewSize:t.getUniformLocation(i,"u_viewSize"),zoom:t.getUniformLocation(i,"u_zoom"),worldSize:t.getUniformLocation(i,"u_worldSize"),modTexture:t.getUniformLocation(i,"u_modTexture"),modCount:t.getUniformLocation(i,"u_modCount"),time:t.getUniformLocation(i,"u_time"),lightPos:t.getUniformLocation(i,"u_lightPos"),lightColor:t.getUniformLocation(i,"u_lightColor"),lightRadius:t.getUniformLocation(i,"u_lightRadius"),lightCount:t.getUniformLocation(i,"u_lightCount")},this.vao=t.createVertexArray(),this.modTexture=t.createTexture(),t.bindTexture(t.TEXTURE_2D,this.modTexture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),this.isInitialized=!0,!0):(console.error("Program link error:",t.getProgramInfoLog(i)),!1))}resize(e,t){this.gl&&this.gl.viewport(0,0,e,t)}uploadModifications(e,t,n,o,i,a){if(!this.gl||!this.modTexture)return;let r=e;if(void 0!==t&&void 0!==n&&void 0!==o&&void 0!==i&&void 0!==a){const s=200,l=t-s,d=t+o/a+s,h=n-s,c=n+i/a+s;r=e.filter(e=>{const t="carve"===e.type?(e.length||100)+e.radius:e.radius,n=e.x-t,o=e.x+t,i=e.y-t,a=e.y+t;return!(o<l||n>d||a<h||i>c)})}const s=Math.min(r.length,I);this.lastModCount=s;for(let d=0;d<s;d++){const e=r[d],t=4*d;let n=0;"add"===e.type?n=1:"carve"===e.type&&(n=2),this.modTextureData[t+0]=n,this.modTextureData[t+1]=e.x,this.modTextureData[t+2]=e.y,this.modTextureData[t+3]=e.radius;const o=16384+t;this.modTextureData[o+0]=e._nx??0,this.modTextureData[o+1]=e._ny??0,this.modTextureData[o+2]=e.length??0,this.modTextureData[o+3]=0}const l=this.gl;l.bindTexture(l.TEXTURE_2D,this.modTexture),l.texImage2D(l.TEXTURE_2D,0,l.RGBA32F,I,2,0,l.RGBA,l.FLOAT,this.modTextureData)}setLights(e,t,n,o){const i=this.gl;i&&this.program&&(i.useProgram(this.program),i.uniform2fv(this.uniforms.lightPos,e),i.uniform3fv(this.uniforms.lightColor,t),i.uniform1fv(this.uniforms.lightRadius,n),i.uniform1i(this.uniforms.lightCount,o))}render(e,o,i,a,s,l){const d=this.gl;if(!d||!this.program||!this.vao)return;d.clearColor(0,0,0,0),d.clear(d.COLOR_BUFFER_BIT),d.useProgram(this.program),d.bindVertexArray(this.vao),d.uniform1f(this.uniforms.seed,e),d.uniform2f(this.uniforms.cameraPos,o,i),d.uniform2f(this.uniforms.viewSize,a,s),d.uniform1f(this.uniforms.zoom,l),d.uniform2f(this.uniforms.worldSize,t,n),d.uniform1i(this.uniforms.modCount,this.lastModCount);const h=10*r;d.uniform1f(this.uniforms.time,performance.now()%h),d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_2D,this.modTexture),d.uniform1i(this.uniforms.modTexture,0),d.drawArrays(d.TRIANGLES,0,6)}isReady(){return this.isInitialized}dispose(){const e=this.gl;e&&(this.program&&e.deleteProgram(this.program),this.vao&&e.deleteVertexArray(this.vao),this.modTexture&&e.deleteTexture(this.modTexture),this.isInitialized=!1)}compileShader(e,t,n){const o=e.createShader(t);return o?(e.shaderSource(o,n),e.compileShader(o),e.getShaderParameter(o,e.COMPILE_STATUS)?o:(console.error(t===e.VERTEX_SHADER?"Vertex":"Fragment","shader error:",e.getShaderInfoLog(o)),e.deleteShader(o),null)):null}}class E{gl=null;program=null;vao=null;vbo=null;isInitialized=!1;uniforms={cameraPos:null,viewSize:null,zoom:null,worldSize:null,pass:null,time:null};init(e){this.gl=e;const t=this.compileShader(e,e.VERTEX_SHADER,"#version 300 es\nprecision highp float;\n\nlayout(location = 0) in vec2 a_pos;\nlayout(location = 4) in float a_life;\nlayout(location = 6) in float a_size;\nlayout(location = 7) in float a_type;\nlayout(location = 8) in vec3 a_color;\n\nuniform vec2 u_cameraPos;\nuniform vec2 u_viewSize;\nuniform float u_zoom;\nuniform vec2 u_worldSize;\n\nout float v_life;\nout float v_type;\nout vec3 v_color;\n\nvoid main() {\n  // World to screen transformation\n  vec2 screenPos = (a_pos - u_cameraPos) * u_zoom;\n\n  // Convert to clip space\n  vec2 clipSpace = (screenPos / u_viewSize) * 2.0 - 1.0;\n  gl_Position = vec4(clipSpace.x, -clipSpace.y, 0.0, 1.0);\n\n  gl_PointSize = a_size * u_zoom;\n  v_life = a_life;\n  v_type = a_type;\n  v_color = a_color;\n}\n"),n=this.compileShader(e,e.FRAGMENT_SHADER,"#version 300 es\nprecision highp float;\n\nuniform int u_pass; // 0 = Alpha Pass (Smoke/Debris), 1 = Additive Pass (Fire/Sparks)\nuniform float u_time; // For flicker\n\nin float v_life;\nin float v_type;\nin vec3 v_color;\n\nout vec4 fragColor;\n\nvoid main() {\n  float dist = length(gl_PointCoord - 0.5);\n  if (dist > 0.5) discard;\n\n  bool isFire = v_type > 0.5;\n\n  // Filter based on pass\n  if (u_pass == 0 && isFire) discard;\n  if (u_pass == 1 && !isFire) discard;\n\n  if (isFire) { // fire, spark, glow\n    // High intensity center + LARGE soft outer glow for shining effect\n    float core = 1.0 - smoothstep(0.0, 0.2, dist);\n    float glow = 1.0 - smoothstep(0.0, 0.5, dist);\n    float aura = 1.0 - smoothstep(0.2, 0.5, dist); // Extra layer for volume\n\n    // Flicker effect\n    float flicker = 0.8 + 0.2 * sin(u_time * 0.05 + v_life * 100.0);\n\n    // Boost brightness significantly\n    vec3 col = v_color * 1.8 * flicker;\n    col = mix(col, vec3(1.0, 1.0, 0.95), core * 0.8); // Very hot white-yellow core\n\n    // Output with high alpha for additive pass\n    // Multiply by v_life for fade out\n    fragColor = vec4(col * (glow * 0.6 + aura * 0.4) * v_life, 1.0);\n  } else { // smoke\n    // Softer smoke edges\n    float smokeAlpha = 1.0 - smoothstep(0.2, 0.5, dist);\n    fragColor = vec4(v_color, smokeAlpha * v_life * 0.6);\n  }\n}\n");if(!t||!n)return!1;const o=e.createProgram();if(!o)return!1;if(e.attachShader(o,t),e.attachShader(o,n),e.linkProgram(o),!e.getProgramParameter(o,e.LINK_STATUS))return console.error("Particle program link error:",e.getProgramInfoLog(o)),!1;this.program=o,this.uniforms={cameraPos:e.getUniformLocation(o,"u_cameraPos"),viewSize:e.getUniformLocation(o,"u_viewSize"),zoom:e.getUniformLocation(o,"u_zoom"),worldSize:e.getUniformLocation(o,"u_worldSize"),pass:e.getUniformLocation(o,"u_pass"),time:e.getUniformLocation(o,"u_time")},this.vao=e.createVertexArray(),this.vbo=e.createBuffer(),e.bindVertexArray(this.vao),e.bindBuffer(e.ARRAY_BUFFER,this.vbo);const i=4*s;return e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,i,0),e.enableVertexAttribArray(4),e.vertexAttribPointer(4,1,e.FLOAT,!1,i,16),e.enableVertexAttribArray(6),e.vertexAttribPointer(6,1,e.FLOAT,!1,i,24),e.enableVertexAttribArray(7),e.vertexAttribPointer(7,1,e.FLOAT,!1,i,28),e.enableVertexAttribArray(8),e.vertexAttribPointer(8,3,e.FLOAT,!1,i,32),this.isInitialized=!0,!0}render(e,o,i,a,r,l,d){const h=this.gl;h&&this.program&&this.vao&&0!==o&&(h.useProgram(this.program),h.bindVertexArray(this.vao),h.uniform2f(this.uniforms.cameraPos,i,a),h.uniform2f(this.uniforms.viewSize,r,l),h.uniform1f(this.uniforms.zoom,d),h.uniform2f(this.uniforms.worldSize,t,n),h.uniform1f(this.uniforms.time,performance.now()),h.bindBuffer(h.ARRAY_BUFFER,this.vbo),h.bufferData(h.ARRAY_BUFFER,e.subarray(0,o*s),h.DYNAMIC_DRAW),h.enable(h.BLEND),h.blendFunc(h.SRC_ALPHA,h.ONE_MINUS_SRC_ALPHA),h.uniform1i(this.uniforms.pass,0),h.drawArrays(h.POINTS,0,o),h.blendFunc(h.ONE,h.ONE),h.uniform1i(this.uniforms.pass,1),h.drawArrays(h.POINTS,0,o))}isReady(){return this.isInitialized}compileShader(e,t,n){const o=e.createShader(t);return o?(e.shaderSource(o,n),e.compileShader(o),e.getShaderParameter(o,e.COMPILE_STATUS)?o:(console.error(e.getShaderInfoLog(o)),e.deleteShader(o),null)):null}}class R extends e{terrainMap=null;terrainRenderer=null;terrainShaderRenderer=null;lastSyncedModCount=0;_projectiles=[];_particleData=new Float32Array(l*s);_particleCount=0;_particleShaderRenderer=null;get projectiles(){return this._projectiles}get particleData(){return this._particleData}get particleCount(){return this._particleCount}botState={planned:!1,moveTimer:0,moveDir:0,aimTimer:0,targetWeapon:d.BASIC,targetAngle:0,targetPower:0};getInitState(){return{phase:h.WAITING,tanks:[],currentTurnIndex:0,wind:0,winner:null,turnTimeEnd:0,players:this.players.map(e=>({id:e.id||null,username:e.username||null,tankId:null})),terrainSeed:Math.round(1e4*Math.random()),terrainMods:[],isSimulating:!1,isExploration:!1}}initTerrain(){this.terrainMap&&this.terrainMap.getSeed()===this.state.terrainSeed||(this.terrainMap=new C(this.state.terrainSeed),this.terrainRenderer=new b,this.lastSyncedModCount=0),this.syncTerrain()}onStateUpdate(e){super.onStateUpdate(e),this.syncTerrain()}onSocketGameState(e){super.onSocketGameState(e),this.initTerrain()}syncTerrain(){if(!this.terrainMap)return;const e=this.state.terrainMods.length;if(e===this.lastSyncedModCount)return;e<this.lastSyncedModCount&&(this.terrainMap.reset(this.state.terrainSeed),this.terrainRenderer&&this.terrainRenderer.clearCache(),this.lastSyncedModCount=0);const t=this.state.terrainMods.slice(this.lastSyncedModCount);if(t.length>0){if(this.terrainMap.applyModifications(t,!1),this.terrainRenderer)for(const e of t){const t="destroy"===e.type?e.radius*(c[d.BASIC].terrainDamageMultiplier||1.2):e.radius;"carve"===e.type&&void 0!==e.vx&&void 0!==e.vy?this.terrainRenderer.invalidateTunnel(e.x,e.y,e.vx,e.vy,e.radius,e.length||100):this.terrainRenderer.invalidateArea(e.x,e.y,t)}this.terrainShaderRenderer&&this.terrainShaderRenderer.uploadModifications(this.state.terrainMods),this.lastSyncedModCount=e}}checkSolid(e,t){return!!this.terrainMap&&this.terrainMap.isSolid(e,t)}getTerrainHeight(e){return this.terrainMap?this.terrainMap.getTerrainHeight(e):n+100}getTerrainMap(){return this.terrainMap}getTerrainRenderer(){return this.terrainRenderer}getTerrainShaderRenderer(){return this.terrainShaderRenderer}initShaderRenderer(e){this.terrainShaderRenderer||(this.terrainShaderRenderer=new P);const t=this.terrainShaderRenderer.init(e);t&&this.terrainMap&&this.terrainShaderRenderer.uploadModifications(this.state.terrainMods);const n=e.getContext("webgl2");return n&&(this._particleShaderRenderer||(this._particleShaderRenderer=new E),this._particleShaderRenderer.init(n)),t}getParticleShaderRenderer(){return this._particleShaderRenderer}seededRandom(e){const t=1e4*Math.sin(e);return t-Math.floor(t)}onSocketGameAction(e){const t=e.action;switch(console.log("onSocketGameAction",e),t.type){case"FIRE_SHOT":this.fireTank(t.shot);break;case"COMMIT_ANGLE":this.handleCommitAngle(t.angle,t.playerId);break;case"COMMIT_POWER":this.handleCommitPower(t.power,t.playerId);break;case"SELECT_WEAPON":this.handleSelectWeapon(t.weapon,t.playerId);break;case"MOVE_START":this.handleMoveStart(t.direction,t.x,t.playerId);break;case"MOVE_STOP":this.handleMoveStop(t.x,t.y,t.fuel,t.playerId);break;case"REGENERATE_MAP":this.handleRegenerateMap(t.seed);break;default:if(!this.isHost)return;switch(t.type){case"FIRE":this.handleFire(t.playerId);break;case"START_GAME":this.handleStartGame();break;case"RESET_GAME":this.reset();break;case"ADD_BOT":this.addBot();break;case"REMOVE_BOT":this.removeBot();break;case"START_EXPLORATION":this.handleStartExploration()}}}handleCommitAngle(e,t){const n=this.getTankByPlayerId(t);if(!n)return;if(!this.isPlayerTurn(t))return;if(this.state.phase!==h.AIMING)return;n.angle=Math.max(0,Math.min(180,e));const o=this._tankSimulations.get(n.id);o&&(o.angle=n.angle)}handleCommitPower(e,t){const n=this.getTankByPlayerId(t);n&&this.isPlayerTurn(t)&&this.state.phase===h.AIMING&&(n.power=Math.max(0,Math.min(100,e)))}handleSelectWeapon(e,t){const n=this.getTankByPlayerId(t);n&&this.isPlayerTurn(t)&&this.state.phase===h.AIMING&&(n.weapon=e)}handleMoveStart(e,t,n){const o=this.getTankByPlayerId(n);o&&this.isPlayerTurn(n)&&this.state.phase===h.AIMING&&(o.isMoving=!0,o.moveDir=e)}handleMoveStop(e,t,n,o){const i=this.getTankByPlayerId(o);i&&this.isPlayerTurn(o)&&this.state.phase===h.AIMING&&(i.isMoving=!1,i.moveDir=void 0,i.x=e,i.y=t,i.fuel=n,this._tankSimulations.delete(i.id))}handleFire(e){if(!this.isHost)return;if(this.state.phase!==h.AIMING)return;if(!this.isPlayerTurn(e))return;const t=this.getTankByPlayerId(e);if(!t)return;const n={tankId:t.id,x:t.x,y:t.y,angle:t.angle,power:t.power,weapon:t.weapon,wind:this.state.wind,seed:Math.random()};this.makeAction({type:"FIRE_SHOT",shot:n})}_tankSimulations=new Map;update(){if(this.syncTerrain(),!this.terrainMap)return;this.state.phase===h.AIMING&&this.state.tanks.forEach(e=>{if(e.isMoving&&e.moveDir){let t=this._tankSimulations.get(e.id);t||(t={x:e.x,y:e.y,fuel:e.fuel,angle:e.angle,health:e.health,falling:!1},this._tankSimulations.set(e.id,t));const n={...e,...t},o=this.calculateTankMovement(n,e.moveDir);o?(t.x=o.x,t.y=o.y,t.fuel=o.fuel):(e.playerId===this.userId&&this.moveStop(),e.isMoving=!1,e.moveDir=void 0,this._tankSimulations.delete(e.id))}else this._tankSimulations.has(e.id)&&this._tankSimulations.delete(e.id)});const e=this.updateTankPhysics(),t=this.updateProjectilePhysics(),n=this.updateParticlePhysics();this.checkPhaseTransitions(e,t,n)&&this.state.isSimulating&&this.onSimulationEnd()}getVisualTank(e){const t=this._tankSimulations.get(e.id);return t?{...e,...t}:e}gravityTank(e,t,o){const i={x:e,y:t,health:o,moving:!1};if(i.health<=0)return i;if(this.checkSolid(i.x,i.y+1))for(;this.checkSolid(i.x,i.y);)i.y--,i.moving=!0;else i.y+=3,i.moving=!0,i.y>n&&(i.health=0);return i}calculateTankMovement(e,n){if(!this.state.isExploration&&e.fuel<=0)return null;if(!this.terrainMap)return null;let{x:o,y:i,fuel:a,angle:r}=e;const s=Math.max(15,Math.min(t-15,o+n*x));if(this.checkSolid(s,i)){let e=!1;for(let t=1;t<=5;t++)if(!this.checkSolid(s,i-t)){o=s,i-=t,e=!0;break}e&&(this.state.isExploration||(a-=u))}else{o=s,this.state.isExploration||(a-=u);for(let e=1;e<=5;e++)if(this.checkSolid(o,i+e)){i+=e-1;break}}return{x:o,y:i,fuel:Math.max(0,a),angle:r}}fireTank(e){this.state.phase=h.FIRING,this.state.isSimulating=!0;const t=e.angle*Math.PI/180,n=e.power/100*f,o=(o=0,i=0)=>{const a=t+o*Math.PI/180,r=e.x+30*Math.cos(a),s=e.y-10-30*Math.sin(a);return{id:(e.seed+i).toString(36),x:r,y:s,vx:Math.cos(a)*n,vy:-Math.sin(a)*n,radius:5,weapon:e.weapon,ownerId:e.tankId,active:!0,bounces:e.weapon===d.BOUNCY?3:void 0}},i=c[e.weapon],a=i.count,r=i.spread||0;for(let s=0;s<a;s++){let e=0;a>1&&(e=-(a-1)*r/2+s*r),this._projectiles.push(o(e,.001*s))}this.state.phase=h.PROJECTILE_MOVING}updateTankPhysics(){let e=!1;return this.state.tanks.forEach(t=>{if(t.health<=0)return void this._tankSimulations.delete(t.id);let n=this._tankSimulations.get(t.id);n||(n={x:t.x,y:t.y,fuel:t.fuel,angle:t.angle,health:t.health,falling:!1},this._tankSimulations.set(t.id,n)),n.falling||t.isMoving||(n.x=t.x,n.y=t.y,n.health=t.health);const{x:o,y:i,health:a,moving:r}=this.gravityTank(n.x,n.y,n.health);r?(n.x=o,n.y=i,n.health=a,n.falling=!0,e=!0):n.falling&&(n.falling=!1,t.x=n.x,t.y=n.y,t.health=n.health)}),e}updateProjectilePhysics(){let e=!1;return this._projectiles.forEach(o=>{if(o.active){if(e=!0,o.x+=o.vx,o.y+=o.vy,o.vy+=m,o.vx+=this.state.wind,o.weapon===d.METEOR_STRIKE)for(let e=0;e<3;e++)this.createTrailParticle(o);else Math.random()>.3&&this.createTrailParticle(o);if(!this.checkProjectileTankCollision(o))if(o.x<0||o.x>t||o.y>n)o.active=!1;else if(this.checkSolid(o.x,o.y))if(o.weapon===d.BOUNCY&&(o.bounces||0)>0){o.vy=.6*-o.vy,o.vx*=.8,o.bounces=(o.bounces||0)-1;let e=0;for(;this.checkSolid(o.x,o.y)&&e<10;)o.y-=2,e++;this.createParticles(o.x,o.y,5,p.spark,1)}else this.explode(o)}}),this._projectiles=this._projectiles.filter(e=>e.active),e}checkProjectileTankCollision(e){for(const t of this.state.tanks){if(t.health<=0)continue;if(t.id===e.ownerId&&Math.abs(e.x-t.x)<20&&Math.abs(e.y-t.y)<20)continue;const n=t.x-e.x,o=t.y-10-e.y;if(Math.sqrt(n*n+o*o)<15)return this.explode(e),!0}return!1}updateParticlePhysics(){if(0===this._particleCount)return!1;for(let e=0;e<this._particleCount;e++){const t=e*s;this._particleData[t+0]+=this._particleData[t+2],this._particleData[t+1]+=this._particleData[t+3],this._particleData[t+4]-=this._particleData[t+5];if(this._particleData[t+7]===p.smoke&&(this._particleData[t+3]-=.05,this._particleData[t+6]+=.1),this._particleData[t+4]<=0){if(this._particleCount>1){const e=(this._particleCount-1)*s;this._particleData.copyWithin(t,e,e+s)}this._particleCount--,e--}}return this._particleCount>0}checkPhaseTransitions(e,t,n){const o=this.state;return 0===this._projectiles.filter(e=>e.active).length&&o.phase===h.PROJECTILE_MOVING&&(o.phase=h.IMPACT,o.turnTimeEnd=Date.now()+1e3),o.phase===h.IMPACT&&o.turnTimeEnd<=Date.now()&&!e||!(e||t||n||o.tanks.some(e=>e.isMoving)||o.phase===h.IMPACT||o.phase===h.PROJECTILE_MOVING)}explode(e){const t=c[e.weapon]||c[d.BASIC];if(this.isHost)if(t.type===d.BUILDER)this.state.terrainMods.push({type:"add",x:Math.round(e.x),y:Math.round(e.y),radius:Math.round(t.radius)});else if(t.type===d.DRILL)this.state.terrainMods.push({type:"carve",x:Math.round(e.x),y:Math.round(e.y),vx:e.vx,vy:e.vy,radius:Math.round(t.radius),length:150});else if(t.type!==d.TELEPORT&&t.type!==d.AIRSTRIKE&&t.type!==d.HEAL){const n=t.radius*t.terrainDamageMultiplier;this.state.terrainMods.push({type:"destroy",x:Math.round(e.x),y:Math.round(e.y),radius:Math.round(n)})}this.syncTerrain(),this.createExplosionParticles(e.x,e.y,t),this.handleSpecialWeapons(e,t),this.isHost&&t.damage>0&&this.state.tanks.forEach(n=>{const o=n.x-e.x,i=n.y-10-e.y,a=Math.sqrt(o*o+i*i);if(a<t.radius+20){const o=Math.floor(t.damage*(1-a/(t.radius+50)));if(o>0)if(t.type===d.HEAL)n.health=Math.min(n.maxHealth,n.health+o);else if(t.type===d.VAMPIRE){n.health=Math.max(0,n.health-o);const t=this.state.tanks.find(t=>t.id===e.ownerId);t&&(t.health=Math.min(t.maxHealth,t.health+o))}else n.health=Math.max(0,n.health-o)}}),t.damage>0&&this.state.tanks.forEach(n=>{const o=n.x-e.x,i=n.y-10-e.y,a=Math.sqrt(o*o+i*i);if(a<t.radius+20){Math.floor(t.damage*(1-a/(t.radius+50)))>0&&(t.type===d.HEAL?this.createParticles(n.x,n.y-10,8,p.glow,1,"#4ade80"):this.createParticles(n.x,n.y-10,10,p.spark,2))}}),e.active=!1}handleSpecialWeapons(e,t){if(t.type===d.TELEPORT){if(!this.isHost)return;const n=this.state.tanks.find(t=>t.id===e.ownerId);if(n){let o=null,i=t.radius+15;for(const t of this.state.tanks){if(t.id===n.id||t.health<=0)continue;const a=Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-10-e.y,2));a<i&&(i=a,o=t)}if(o){const e=o.x,t=o.y;o.x=n.x,o.y=n.y,n.x=e,n.y=t}else{n.x=e.x,n.y=e.y;let t=0;for(;this.checkSolid(n.x,n.y)&&t<50;)n.y--,t++}}}if(t.type===d.AIRSTRIKE){const t=Number(e.id)||0;for(let n=0;n<8;n++){const o=t+.1*n,i=100*(this.seededRandom(o)-.5),a=200*-this.seededRandom(o+.05);this._projectiles.push({id:(t+1+.1*n).toString(),x:e.x+i,y:a,vx:0,vy:5+5*this.seededRandom(o+.07),radius:5,weapon:d.AIRSTRIKE_BOMB,ownerId:e.ownerId,active:!0})}}if(t.type===d.MIRV){const t=Number(e.id)||e.x;for(let n=0;n<5;n++){const o=t+.13*n,i=12*(this.seededRandom(o)-.5),a=-3-8*this.seededRandom(o+.05);this._projectiles.push({id:(t+n+100).toString(36),x:e.x,y:e.y-10,vx:i,vy:a,radius:5,weapon:d.MIRV_MINI,ownerId:e.ownerId,active:!0})}}t.type===d.METEOR&&this._projectiles.push({id:(Number(e.id)+1e3).toString(),x:e.x,y:-1e3,vx:.1*e.vx+10*this.state.wind,vy:6,radius:40,weapon:d.METEOR_STRIKE,ownerId:e.ownerId,active:!0})}createExplosionParticles(e,t,n){n.type===d.NUKE?(this.createParticles(e,t,100,p.smoke,3),this.createParticles(e,t,50,p.smoke,2),this.createParticles(e,t,30,p.glow,4,"#d946ef")):n.type===d.TELEPORT?(this.createParticles(e,t,30,p.glow,2,"#c084fc"),this.createParticles(e,t,20,p.spark,3,"#ffffff")):n.type===d.METEOR_STRIKE?(this.createParticles(e,t,150,p.fire,6,void 0,.3),this.createParticles(e,t,50,p.smoke,3,void 0,.3),this.createParticles(e,t,50,p.glow,8,"#ff4500",.4)):n.type===d.BUILDER?this.createParticles(e,t,20,p.smoke,1,"#64748b"):n.type===d.HEAL?(this.createParticles(e,t,20,p.glow,2,"#4ade80"),this.createParticles(e,t,15,p.spark,1.5,"#ffffff")):(this.createParticles(e,t,20,p.fire,1.5),this.createParticles(e,t,20,p.smoke,1))}createTrailParticle(e){const t={[d.NUKE]:"#d946ef",[d.DRILL]:"#94a3b8",[d.TELEPORT]:"#c084fc",[d.AIRSTRIKE]:"#ef4444",[d.AIRSTRIKE_BOMB]:"#ef4444",[d.BUILDER]:"#60a5fa",[d.HEAL]:"#4ade80",[d.METEOR_STRIKE]:"#fb923c"}[e.weapon];t?this.createParticles(e.x,e.y,1,p.glow,.3,t):this.createParticles(e.x,e.y,1,p.smoke,0,"rgba(255,255,255,0.5)",5)}createParticles(e,t,n,o,i=1,a,r=1){const d=Math.min(n,100);for(let h=0;h<d&&!(this._particleCount>=l);h++){const n=Math.random()*Math.PI*2,l=2*Math.random()*i;let d="#fff",h=.02,c=3*Math.random()+1,u=p.smoke,f=0;o===p.fire?(d=a||(Math.random()>.5?"#fbbf24":"#ef4444"),h=.04*r,c=6*Math.random()+4,u=p.fire,f=1):o===p.smoke?(d=a||"#64748b",h=.02*r,c=8*Math.random()+4,u=p.smoke):o===p.spark?(d=a||"#facc15",h=.08*r,c=2*Math.random()+1,u=p.spark,f=1):o===p.glow&&(d=a||"#22c55e",h=.05*r,c=5*Math.random()+2,u=p.glow,f=1);const m=parseInt(d.slice(1,3),16)/255||1,g=parseInt(d.slice(3,5),16)/255||1,y=parseInt(d.slice(5,7),16)/255||1,v=this._particleCount*s;this._particleData[v+0]=e,this._particleData[v+1]=t,this._particleData[v+2]=Math.cos(n)*l,this._particleData[v+3]=Math.sin(n)*l,this._particleData[v+4]=1,this._particleData[v+5]=h,this._particleData[v+6]=c,this._particleData[v+7]=u,this._particleData[v+8]=m,this._particleData[v+9]=g,this._particleData[v+10]=y,this._particleData[v+11]=f,this._particleCount++}}onSimulationEnd(){if(this.state.isSimulating){if(this.state.isSimulating=!1,!this.state.isExploration){const e=this.state.tanks.filter(e=>e.health>0);if(e.length<=1){if(this.state.phase=h.GAME_OVER,1===e.length){const t=e[0],n=this.state.players.find(e=>e.id===t.playerId);this.state.winner=n?.username||(t.isBot?"Bot":"Player")}else this.state.winner="Draw";return}}this.nextTurn(),this.checkBotTurn()}}nextTurn(){const e=this.state;if(e.isExploration)return e.phase=h.AIMING,void(e.turnTimeEnd=0);for(e.currentTurnIndex=(e.currentTurnIndex+1)%e.tanks.length;e.tanks[e.currentTurnIndex].health<=0;)e.currentTurnIndex=(e.currentTurnIndex+1)%e.tanks.length;e.tanks[e.currentTurnIndex].fuel=g,this.botState.planned=!1,e.phase=h.AIMING,e.wind=.05*Math.random()-.025}checkBotTurn(){if(!this.isHost||this.state.isExploration)return;if(this.state.phase!==h.AIMING)return;if(this.state.isSimulating)return;const e=this.state.tanks[this.state.currentTurnIndex];e?.isBot&&setTimeout(()=>this.runBotTurn(),500)}runBotTurn(){const e=this.state.tanks[this.state.currentTurnIndex];e&&e.isBot&&this.state.phase===h.AIMING&&(this.botState.planned||(this.planBotMove(e),this.botState.planned=!0),this.executeBotPlan(e))}planBotMove(e){this.botState.moveDir=Math.random()>.5?1:-1,this.botState.moveTimer=Math.floor(30*Math.random()),this.botState.aimTimer=1;const o=this.state.tanks.find(t=>t.id!==e.id&&t.health>0);if(o)if(e.health<35)this.botState.targetWeapon=d.HEAL,this.botState.targetAngle=90,this.botState.targetPower=15;else if(e.y>n-300){this.botState.targetWeapon=d.TELEPORT;const n=t/2-e.x;this.botState.targetAngle=n>0?60:120,this.botState.targetPower=80}else{const t=o.x-e.x,n=Math.abs(t),i=t>0?1:-1;if(n<400)this.botState.targetWeapon=Math.random()>.5?d.SCATTER:d.DRILL;else if(n>800)this.botState.targetWeapon=Math.random()>.6?d.NUKE:d.BASIC;else{const e=[d.BASIC,d.BARRAGE];this.botState.targetWeapon=e[Math.floor(Math.random()*e.length)]}const a=i>0?45:135;this.botState.targetAngle=a+(10*Math.random()-5);const r=Math.sqrt(n*m)/f*100,s=.1*(o.y-e.y);this.botState.targetPower=Math.max(10,Math.min(100,r+s+(10*Math.random()-5)))}}executeBotPlan(e){const t={moveTimer:this.botState.moveTimer,moveDir:this.botState.moveDir,aimTimer:this.botState.aimTimer,targetAngle:this.botState.targetAngle,targetPower:this.botState.targetPower,targetWeapon:this.botState.targetWeapon};t.moveTimer>0&&!e.isMoving&&(e.isMoving=!0,e.moveDir=t.moveDir,-1===t.moveDir?e.angle=Math.max(90,Math.min(180,e.angle)):e.angle=Math.max(0,Math.min(90,e.angle)));const n=e.id,o=e.playerId,i=()=>{const a=this.state.tanks[this.state.currentTurnIndex];if(!a||a.id!==n||this.state.phase!==h.AIMING)return e.isMoving=!1,void(e.moveDir=void 0);if(t.moveTimer>0)return t.moveTimer--,t.moveTimer<=0&&(e.isMoving=!1,e.moveDir=void 0),void requestAnimationFrame(i);if(t.aimTimer>0){e.weapon=t.targetWeapon;const n=t.targetAngle-e.angle;e.angle+=.4*n;const o=t.targetPower-e.power;return e.power+=.4*o,t.aimTimer--,void requestAnimationFrame(i)}e.angle=t.targetAngle,e.power=t.targetPower,this.handleFire(o||"BOT")};requestAnimationFrame(i)}startGame(){this.handleStartGame()}handleStartExploration(){if(this.state.phase!==h.WAITING)return;this.initTerrain();const e=this.state.players[0]||{id:"ME",username:"Explorer"},n=Math.floor(t/2),o=this.getTerrainHeight(n);this.state.tanks=[{id:"tank-explorer",name:e.username||"Explorer",playerId:e.id,isBot:!1,x:n,y:o,angle:45,power:50,health:v,maxHealth:v,color:y[0],weapon:d.BASIC,fuel:g}],this.state.isExploration=!0,this.state.phase=h.AIMING}handleStartGame(){if(this.state.phase!==h.WAITING)return;this.initTerrain();const e=this.state.players.length,n=t/(e+1);this.state.tanks=this.state.players.map((e,t)=>{const o=`tank-${t+1}`;e.tankId=o;const i=Math.floor(n*(t+1)),a=this.getTerrainHeight(i);return{id:o,name:e.username||(e.isBot?"Bot":"Player"),playerId:e.id,isBot:!!e.isBot,x:i,y:a,angle:45,power:50,health:v,maxHealth:v,color:y[t%y.length],weapon:d.BASIC,fuel:g}}),this.state.phase=h.AIMING,this.state.wind=.05*Math.random()-.025,this.state.currentTurnIndex=0,this.checkBotTurn()}reset(){this.state.phase=h.WAITING,this.state.tanks=[],this.state.currentTurnIndex=0,this.state.wind=0,this.state.winner=null,this.state.turnTimeEnd=0,this.state.isExploration=!1,this.state.players.forEach(e=>{e.tankId=null}),this.state.terrainSeed=Math.round(1e4*Math.random()),this.state.terrainMods=[],this.state.isSimulating=!1,this._tankSimulations.clear(),this.initTerrain()}addBot(){if(!this.isHost)return;if(this.state.phase!==h.WAITING)return;const e=this.state.players.filter(e=>e.isBot).length,t=`BOT_${Math.random().toString(36).substr(2,5).toUpperCase()}`;this.state.players.push({id:t,username:`Bot ${e+1}`,tankId:null,isBot:!0})}removeBot(){if(!this.isHost)return;if(this.state.phase!==h.WAITING)return;const e=[...this.state.players].reverse().findIndex(e=>e.isBot);if(-1!==e){const t=this.state.players.length-1-e;this.state.players.splice(t,1)}}requestAddBot(){this.makeAction({type:"ADD_BOT"})}requestStartExploration(){this.makeAction({type:"START_EXPLORATION"})}requestRemoveBot(){this.makeAction({type:"REMOVE_BOT"})}requestReset(){this.makeAction({type:"RESET_GAME"})}requestRegenerateMap(){const e=Math.round(1e4*Math.random());this.makeAction({type:"REGENERATE_MAP",seed:e})}handleRegenerateMap(e){this.state.terrainSeed=e,this.state.terrainMods=[],this._tankSimulations.clear(),this.initTerrain(),console.log("Map regenerated with seed:",e)}commitAngle(e){const t={type:"COMMIT_ANGLE",angle:e,playerId:this.userId};this.makeAction(t)}commitPower(e){const t={type:"COMMIT_POWER",power:e,playerId:this.userId};this.makeAction(t)}selectWeapon(e){const t={type:"SELECT_WEAPON",weapon:e,playerId:this.userId};this.makeAction(t)}moveStart(e){const t=this.getMyTank();if(!t||t.fuel<=0)return;const n={type:"MOVE_START",direction:e,x:t.x,playerId:this.userId};this.makeAction(n)}moveStop(){const e=this.getMyTank();if(!e)return;const t=this._tankSimulations.get(e.id),n={type:"MOVE_STOP",x:t?.x??e.x,y:t?.y??e.y,fuel:t?.fuel??e.fuel,playerId:this.userId};this.makeAction(n)}fire(){const e={type:"FIRE",playerId:this.userId};this.makeAction(e)}getTankByPlayerId(e){return this.state.tanks.find(t=>t.playerId===e)}isPlayerTurn(e){const t=this.state.tanks[this.state.currentTurnIndex];return t?.playerId===e}getMyTank(){return this.state.tanks.find(e=>e.playerId===this.userId)}isMyTurn(){return this.isPlayerTurn(this.userId)}getCurrentTank(){return this.state.tanks[this.state.currentTurnIndex]}canStartGame(){return this.state.players.length>1&&this.state.phase===h.WAITING}updatePlayers(e){if(!(this.players[0]?.id===this.userId))return;const t=[...this.state.players],n=t.filter(e=>"BOT"===e.id),o=e.map(e=>{const n=t.find(t=>t.id===e.id);return{id:e.id,username:e.username,tankId:n?.tankId||null}});o.push(...n),this.state.players=o}destroy(){super.destroy()}}export{R as default};
