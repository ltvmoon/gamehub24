import{B as t}from"./BaseGame-iDkECrzW.js";import{W as e,a as i,b as s,G as a,c as n,F as r,M as o,d as h,e as l,T as d,I as c,f as u}from"./constants-OCdO85vu.js";import"./socket-DRbsQkF5.js";import"./index-BiWvX6AI.js";import"./react-vendor-CyPxdFQK.js";import"./zustand-BbtpVoJv.js";class f{bounds;entries=[];children=null;depth;static MAX_ENTRIES=8;static MAX_DEPTH=12;constructor(t,e=0){this.bounds=t,this.depth=e}insert(t){if(this.intersectsBounds(t.bounds))if(this.children)for(const e of this.children)e.intersectsBounds(t.bounds)&&e.insert(t);else this.entries.push(t),this.entries.length>f.MAX_ENTRIES&&this.depth<f.MAX_DEPTH&&this.split()}queryPoint(t,e){if(!this.containsPoint(t,e))return[];const i=[];for(const s of this.entries)this.pointInModification(t,e,s)&&i.push(s);if(this.children)for(const s of this.children)i.push(...s.queryPoint(t,e));return i}queryCircle(t,e,i){const s={x:t-i,y:e-i,width:2*i,height:2*i};if(!this.intersectsBounds(s))return[];const a=[];for(const n of this.entries)a.push(n);if(this.children)for(const n of this.children)a.push(...n.queryCircle(t,e,i));return a}clear(){this.entries=[],this.children=null}split(){const{x:t,y:e,width:i,height:s}=this.bounds,a=i/2,n=s/2;this.children=[new f({x:t,y:e,width:a,height:n},this.depth+1),new f({x:t+a,y:e,width:a,height:n},this.depth+1),new f({x:t,y:e+n,width:a,height:n},this.depth+1),new f({x:t+a,y:e+n,width:a,height:n},this.depth+1)];for(const r of this.entries)for(const t of this.children)t.intersectsBounds(r.bounds)&&t.insert(r)}containsPoint(t,e){return t>=this.bounds.x&&t<this.bounds.x+this.bounds.width&&e>=this.bounds.y&&e<this.bounds.y+this.bounds.height}intersectsBounds(t){return!(t.x>this.bounds.x+this.bounds.width||t.x+t.width<this.bounds.x||t.y>this.bounds.y+this.bounds.height||t.y+t.height<this.bounds.y)}pointInModification(t,e,i){const s=i.modification;if("carve"===s.type&&void 0!==s.vx&&void 0!==s.vy)return this.pointInCapsule(t,e,s.x,s.y,s.vx,s.vy,s.radius,s.length||100);const a=t-s.x,n=e-s.y;return a*a+n*n<=s.radius*s.radius}pointInCapsule(t,e,i,s,a,n,r,o){const h=Math.sqrt(a*a+n*n);if(0===h)return!1;const l=i+a/h*o-i,d=s+n/h*o-s,c=l*l+d*d;if(0===c){return(t-i)**2+(e-s)**2<=r*r}let u=((t-i)*l+(e-s)*d)/c;u=Math.max(0,Math.min(1,u));return(t-(i+u*l))**2+(e-(s+u*d))**2<=r*r}}class m{seed;quadtree;modificationCounter=0;modifications=[];bounds;static CACHE_SIZE=4096;static CACHE_MASK=4095;baseHeightCache=new Float32Array(m.CACHE_SIZE);baseHeightKeys=new Int32Array(m.CACHE_SIZE).fill(-999999);constructor(t,s=2*e,a=2*i){this.seed=t,this.bounds={x:-s/2,y:-a/2,width:2*s,height:2*a},this.quadtree=new f(this.bounds)}getBaseHeight(t){const s=Math.round(t),a=s&m.CACHE_MASK;if(this.baseHeightKeys[a]===s)return this.baseHeightCache[a];const n=function(t,s){const a=e,n=i;let r=n/1.6+(200*Math.sin(.001*(t+s))+50*Math.sin(.005*(t+2*s))+10*Math.sin(.02*(t+3*s)))+-120*Math.sin(t/a*Math.PI*5+s);return r=Math.max(200,Math.min(n-100,r)),r}(t,this.seed);return this.baseHeightKeys[a]=s,this.baseHeightCache[a]=n,n}getTerrainHeight(t){const e=this.getBaseHeight(t),s=this.quadtree.queryCircle(t,e/2,e/2+100);if(0===s.length)return e;let a=e;for(const i of s)if("add"===i.modification.type){const t=i.modification.y-i.modification.radius;t<a&&(a=t)}for(let n=Math.max(0,Math.floor(a));n<i;n+=4)if(this.isSolidFast(t,n,e)){for(let i=Math.max(0,n-4);i<=n;i++)if(this.isSolidFast(t,i,e))return i;return n}return e}isSolid(t,e){if(e>=i||e<0)return!1;const s=this.getBaseHeight(t);return this.isSolidFast(t,e,s)}isSolidFast(t,e,s){if(e>=i||e<0)return!1;let a=e>=s;const n=this.quadtree.queryPoint(t,e);if(0===n.length)return a;n.length>1&&n.sort((t,e)=>t.timestamp-e.timestamp);for(let i=0;i<n.length;i++){const s=n[i].modification,r=t-s.x,o=e-s.y,h=r*r+o*o,l=s._radiusSq;"destroy"===s.type?h<=l&&(a=!1):"add"===s.type?h<=l&&(a=!0):"carve"===s.type&&this.isInTunnel(t,e,s)&&(a=!1)}return a}destroyCircle(t,e,i){const s={type:"destroy",x:t,y:e,radius:i};this.addModification(s)}addCircle(t,e,i){const s={type:"add",x:t,y:e,radius:i};this.addModification(s)}carveTunnel(t,e,i,s,a,n=100){const r={type:"carve",x:t,y:e,radius:a,vx:i,vy:s,length:n};this.addModification(r)}getModifications(){return[...this.modifications]}applyModifications(t,e=!0){e&&(this.quadtree.clear(),this.modifications=[],this.modificationCounter=0,this.baseHeightKeys.fill(-999999));for(const i of t)this.addModification(i)}reset(t){this.seed=t,this.quadtree.clear(),this.modifications=[],this.modificationCounter=0,this.baseHeightKeys.fill(-999999)}addModification(t){if(t._radiusSq=t.radius*t.radius,void 0!==t.vx&&void 0!==t.vy){const e=Math.hypot(t.vx,t.vy);e>0&&(t._nx=t.vx/e,t._ny=t.vy/e)}const e={modification:t,bounds:this.getModificationBounds(t),timestamp:this.modificationCounter++};this.quadtree.insert(e),this.modifications.push(t)}getModificationBounds(t){if("carve"===t.type&&void 0!==t.vx&&void 0!==t.vy){const e=Math.sqrt(t.vx*t.vx+t.vy*t.vy);if(e>0){const i=t.vx/e,s=t.vy/e,a=t.length||100,n=t.x+i*a,r=t.y+s*a,o=Math.min(t.x,n)-t.radius,h=Math.max(t.x,n)+t.radius,l=Math.min(t.y,r)-t.radius;return{x:o,y:l,width:h-o,height:Math.max(t.y,r)+t.radius-l}}}return{x:t.x-t.radius,y:t.y-t.radius,width:2*t.radius,height:2*t.radius}}isInTunnel(t,e,i){const s=i._nx,a=i._ny;if(void 0===s||void 0===a)return!1;const n=i.length||100,r=s*n,o=a*n,h=n*n;if(0===h){return(t-i.x)**2+(e-i.y)**2<=i._radiusSq}let l=((t-i.x)*r+(e-i.y)*o)/h;l=Math.max(0,Math.min(1,l));return(t-(i.x+l*r))**2+(e-(i.y+l*o))**2<=i._radiusSq}getSeed(){return this.seed}}const y=256;class p{chunks=new Map;dirtyChunks=new Set;chunkAccessOrder=[];skyChunks=new Set;clearCache(){this.chunks.clear(),this.dirtyChunks.clear(),this.chunkAccessOrder=[],this.skyChunks.clear()}isChunkSkyOnly(t,e,i){const s=t*y,a=(e+1)*y;for(let r=0;r<=y;r+=32){const t=s+r;if(i.getBaseHeight(t)<a)return!1}const n=i.getModifications();for(const r of n)if("add"===r.type){const t=r.y-r.radius,i=r.y+r.radius,n=r.x-r.radius;if(r.x+r.radius>=s&&n<=s+y&&i>=e*y&&t<=a)return!1}return!0}renderVisibleChunks(t,e,i,s,a,n,r){const o=s/n,h=a/n,l=Math.floor(e/y),d=Math.ceil((e+o)/y),c=Math.floor(i/y),u=Math.ceil((i+h)/y);let f=0;const m=e+o/2,p=i+h/2,g=[];for(let x=l;x<=d;x++)for(let e=c;e<=u;e++){const i=`${x},${e}`;if(!this.skyChunks.has(i)||this.dirtyChunks.has(i))if(this.chunks.has(i)||this.dirtyChunks.has(i)||!this.isChunkSkyOnly(x,e,r))if(!this.chunks.has(i)||this.dirtyChunks.has(i)){const t=(x+.5)*y,s=(e+.5)*y,a=Math.abs(t-m)+Math.abs(s-p);g.push({cx:x,cy:e,key:i,dist:a})}else{const s=this.chunks.get(i);if(s){const a=x*y-.5,n=e*y-.5;t.drawImage(s,a,n,257,257),this.updateLRU(i)}}else this.skyChunks.add(i)}g.sort((t,e)=>t.dist-e.dist);for(const{cx:x,cy:M,key:T}of g){if(f>=4)break;if(this.dirtyChunks.has(T)&&(this.skyChunks.delete(T),this.isChunkSkyOnly(x,M,r))){this.skyChunks.add(T),this.dirtyChunks.delete(T),this.chunks.delete(T);continue}this.generateChunk(x,M,r),this.dirtyChunks.delete(T),f++;const e=this.chunks.get(T);if(e){const i=x*y-.5,s=M*y-.5;t.drawImage(e,i,s,257,257),this.updateLRU(T)}}this.pruneChunks()}invalidateArea(t,e,i){const s=Math.floor((t-i)/y),a=Math.ceil((t+i)/y),n=Math.floor((e-i)/y),r=Math.ceil((e+i)/y);for(let o=s;o<=a;o++)for(let t=n;t<=r;t++)this.dirtyChunks.add(`${o},${t}`)}invalidateTunnel(t,e,i,s,a,n){const r=Math.sqrt(i*i+s*s);if(0===r)return void this.invalidateArea(t,e,a);const o=t+i/r*n,h=e+s/r*n,l=Math.min(t,o)-a,d=Math.max(t,o)+a,c=Math.min(e,h)-a,u=Math.max(e,h)+a,f=Math.floor(l/y),m=Math.ceil(d/y),p=Math.floor(c/y),g=Math.ceil(u/y);for(let y=f;y<=m;y++)for(let t=p;t<=g;t++)this.dirtyChunks.add(`${y},${t}`)}clear(){this.chunks.clear(),this.dirtyChunks.clear(),this.chunkAccessOrder=[],this.skyChunks.clear()}generateChunk(t,e,s){const a=`${t},${e}`;let n=this.chunks.get(a);n||(n=document.createElement("canvas"),n.width=y,n.height=y,this.chunks.set(a,n));const r=n.getContext("2d");r.clearRect(0,0,y,y);const o=t*y,h=e*y,l=new Float32Array(257);for(let i=0;i<=y;i++)l[i]=s.getBaseHeight(o+i);r.beginPath();let d=!1;for(let i=0;i<=y;i++){const t=l[i]-h;t<=y&&(d?r.lineTo(i,Math.max(0,t)):(r.moveTo(i,Math.max(0,t)),d=!0))}r.lineTo(y,y),r.lineTo(0,y),r.closePath();const c=-h,u=i-h,f=r.createLinearGradient(0,c,0,u);f.addColorStop(0,"#475569"),f.addColorStop(1,"#0f172a"),r.fillStyle=f,r.fill(),r.globalCompositeOperation="source-atop";for(let i=0;i<15;i++){const t=4*Math.random()+1,e=Math.random()*y,i=Math.random()*y;r.fillStyle=Math.random()>.5?"rgba(0,0,0,0.2)":"rgba(255,255,255,0.05)",r.beginPath(),r.arc(e,i,t,0,2*Math.PI),r.fill()}r.globalCompositeOperation="source-over",r.beginPath();for(let i=0;i<=y;i++){const t=l[i]-h;0===i?r.moveTo(i,t):r.lineTo(i,t)}r.strokeStyle="#22c55e",r.lineWidth=15,r.lineCap="round",r.stroke(),r.strokeStyle="#86efac",r.lineWidth=4,r.stroke(),this.applyModifications(r,o,h,s)}applyModifications(t,e,i,s){const a=s.getModifications();for(const n of a){const s=n.x-e,a=n.y-i,r=n.radius+20;if(s<-r||s>y+r||a<-r||a>y+r){if("carve"!==n.type||void 0===n.vx||void 0===n.vy)continue;{const t=Math.sqrt(n.vx*n.vx+n.vy*n.vy);if(t>0){const e=n.vx/t,i=n.vy/t,r=n.length||100,o=s+e*r,h=a+i*r,l=Math.min(s,o)-n.radius,d=Math.max(s,o)+n.radius,c=Math.min(a,h)-n.radius,u=Math.max(a,h)+n.radius;if(d<0||l>y||u<0||c>y)continue}}}if("destroy"===n.type){t.save(),t.globalCompositeOperation="destination-out",t.beginPath();for(let e=0;e<2*Math.PI;e+=.2){const i=n.radius*(.9+.2*Math.random()),r=s+Math.cos(e)*i,o=a+Math.sin(e)*i;0===e?t.moveTo(r,o):t.lineTo(r,o)}t.closePath(),t.fillStyle="#000",t.fill(),t.restore(),t.save(),t.globalCompositeOperation="source-atop",t.beginPath(),t.arc(s,a,n.radius+10,0,2*Math.PI),t.fillStyle="rgba(0, 0, 0, 0.5)",t.fill(),t.restore()}else if("add"===n.type)t.save(),t.globalCompositeOperation="source-over",t.beginPath(),t.arc(s,a,n.radius,0,2*Math.PI),t.fillStyle="#64748b",t.fill(),t.lineWidth=2,t.strokeStyle="#94a3b8",t.stroke(),t.restore();else if("carve"===n.type&&void 0!==n.vx&&void 0!==n.vy){const e=Math.sqrt(n.vx*n.vx+n.vy*n.vy);if(0===e)continue;const i=n.vx/e,r=n.vy/e,o=n.length||100;t.save(),t.globalCompositeOperation="destination-out",t.lineWidth=2*n.radius,t.lineCap="round",t.beginPath(),t.moveTo(s,a),t.lineTo(s+i*o,a+r*o),t.stroke(),t.restore(),t.save(),t.globalCompositeOperation="source-atop",t.lineWidth=2*n.radius+10,t.lineCap="round",t.strokeStyle="rgba(0,0,0,0.5)",t.beginPath(),t.moveTo(s,a),t.lineTo(s+i*o,a+r*o),t.stroke(),t.restore()}}}updateLRU(t){const e=this.chunkAccessOrder.indexOf(t);e>=0&&this.chunkAccessOrder.splice(e,1),this.chunkAccessOrder.push(t)}pruneChunks(){for(;this.chunks.size>64&&this.chunkAccessOrder.length>0;){const t=this.chunkAccessOrder.shift();this.chunks.delete(t),console.log("Pruned chunk",t)}}}const g=4096;class x{gl=null;program=null;vao=null;modTexture=null;uniforms={seed:null,cameraPos:null,viewSize:null,zoom:null,worldSize:null,modTexture:null,modCount:null};modTextureData;lastModCount=0;isInitialized=!1;constructor(){this.modTextureData=new Float32Array(32768)}init(t){const e=t.getContext("webgl2",{alpha:!0,antialias:!1,premultipliedAlpha:!1});if(!e)return console.warn("WebGL2 not available, falling back to CPU rendering"),!1;this.gl=e;const i=this.compileShader(e,e.VERTEX_SHADER,"#version 300 es\nprecision highp float;\n\n// Fullscreen quad vertices (2 triangles)\nconst vec2 positions[6] = vec2[](\n  vec2(-1.0, -1.0),\n  vec2( 1.0, -1.0),\n  vec2( 1.0,  1.0),\n  vec2(-1.0, -1.0),\n  vec2( 1.0,  1.0),\n  vec2(-1.0,  1.0)\n);\n\nvoid main() {\n  gl_Position = vec4(positions[gl_VertexID], 0.0, 1.0);\n}\n"),s=this.compileShader(e,e.FRAGMENT_SHADER,"#version 300 es\nprecision highp float;\n\nuniform float u_seed;\nuniform vec2 u_cameraPos;\nuniform vec2 u_viewSize;\nuniform float u_zoom;\nuniform vec2 u_worldSize;\nuniform sampler2D u_modTexture;\nuniform int u_modCount;\n\nout vec4 fragColor;\n\n// === Noise functions for irregular edges ===\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat noise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  f = f * f * (3.0 - 2.0 * f); // Smooth interpolation\n\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n\n  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\n// Fractal Brownian Motion for more natural irregular edges\nfloat fbm(vec2 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * noise(p);\n    p *= 2.0;\n    amplitude *= 0.5;\n  }\n  return value;\n}\n\n// === Terrain height calculation (matches CPU implementation) ===\nfloat computeBaseHeight(float x) {\n  float f1 = 0.001;\n  float f2 = 0.005;\n  float f3 = 0.02;\n\n  float a1 = 200.0;\n  float a2 = 50.0;\n  float a3 = 10.0;\n\n  float noise = sin((x + u_seed) * f1) * a1 +\n                sin((x + u_seed * 2.0) * f2) * a2 +\n                sin((x + u_seed * 3.0) * f3) * a3;\n\n  float mountain = sin((x / u_worldSize.x) * 3.14159265 * 5.0 + u_seed) * -120.0;\n\n  float h = u_worldSize.y / 1.6 + noise + mountain;\n  return clamp(h, 200.0, u_worldSize.y - 100.0);\n}\n\n// === Check if point is in tunnel (capsule SDF) ===\nbool isInTunnel(float px, float py, float sx, float sy, float nx, float ny, float radius, float length) {\n  float dx = nx * length;\n  float dy = ny * length;\n  float len2 = length * length;\n\n  if (len2 == 0.0) {\n    float dist2 = (px - sx) * (px - sx) + (py - sy) * (py - sy);\n    return dist2 <= radius * radius;\n  }\n\n  float t = clamp(((px - sx) * dx + (py - sy) * dy) / len2, 0.0, 1.0);\n  float closestX = sx + t * dx;\n  float closestY = sy + t * dy;\n\n  float dist2 = (px - closestX) * (px - closestX) + (py - closestY) * (py - closestY);\n  return dist2 <= radius * radius;\n}\n\n// === Check if point is inside irregular crater ===\nbool isInCrater(float worldX, float worldY, float modX, float modY, float modRadius, out float edgeDist) {\n  float dx = worldX - modX;\n  float dy = worldY - modY;\n  float dist = sqrt(dx * dx + dy * dy);\n\n  // Calculate angle for noise sampling\n  float angle = atan(dy, dx);\n\n  // Create irregular edge using noise\n  // Use position-based noise for consistent edges\n  vec2 noisePos = vec2(modX + modY * 0.37, angle * 3.0 + modRadius * 0.1);\n  float edgeNoise = fbm(noisePos * 0.5) * 0.3 + 0.85; // 0.55 to 1.15 range\n\n  // Add smaller high-frequency detail\n  float detailNoise = noise(vec2(angle * 8.0 + modX, modY * 0.1)) * 0.15;\n\n  float irregularRadius = modRadius * (edgeNoise + detailNoise);\n  edgeDist = dist - irregularRadius;\n\n  return dist <= irregularRadius;\n}\n\n// === Generate star field (smooth point-based, no grid artifacts) ===\nfloat star(vec2 uv, float layer) {\n  // Create grid for star placement\n  vec2 id = floor(uv);\n  vec2 gridUV = fract(uv);\n\n  float starLight = 0.0;\n\n  // Check this cell and neighbors to avoid edge cutoff\n  for (int y = -1; y <= 1; y++) {\n    for (int x = -1; x <= 1; x++) {\n      vec2 neighbor = vec2(float(x), float(y));\n      vec2 cellId = id + neighbor;\n\n      // Random position within cell\n      vec2 starPos = neighbor + vec2(\n        hash(cellId + layer * 17.0),\n        hash(cellId + layer * 31.0 + 50.0)\n      ) * 0.8 + 0.1;\n\n      // Only some cells have stars\n      float starPresent = step(0.92, hash(cellId + layer * 47.0));\n      if (starPresent < 0.5) continue;\n\n      // Distance to star\n      float d = length(gridUV - starPos);\n\n      // Star size varies\n      float size = hash(cellId + layer * 63.0) * 0.015 + 0.005;\n\n      // Smooth star glow (exponential falloff)\n      float glow = exp(-d * d / (size * size * 2.0));\n\n      // Brightness variation\n      float brightness = hash(cellId + layer * 79.0) * 0.7 + 0.3;\n\n      starLight += glow * brightness;\n    }\n  }\n\n  return clamp(starLight, 0.0, 1.0);\n}\n\nvoid main() {\n  // Screen coordinates â†’ World coordinates\n  vec2 screenPos = gl_FragCoord.xy;\n  float worldX = u_cameraPos.x + screenPos.x / u_zoom;\n  float worldY = u_cameraPos.y + (u_viewSize.y - screenPos.y) / u_zoom;\n\n  // Compute base terrain height\n  float baseH = computeBaseHeight(worldX);\n  bool solid = worldY >= baseH;\n\n  // Track crater effects for coloring\n  float nearestCraterDist = 1000.0;\n  float nearestCraterRadius = 0.0;\n\n  // Apply modifications from texture\n  for (int i = 0; i < u_modCount; i++) {\n    vec4 data0 = texelFetch(u_modTexture, ivec2(i, 0), 0);\n    float modType = data0.r;\n    float modX = data0.g;\n    float modY = data0.b;\n    float modRadius = data0.a;\n\n    if (modType < 0.5) {\n      // Destroy (crater) - use irregular edges\n      float edgeDist;\n      if (isInCrater(worldX, worldY, modX, modY, modRadius, edgeDist)) {\n        solid = false;\n      }\n      // Track for scorch marks\n      float dx = worldX - modX;\n      float dy = worldY - modY;\n      float dist = sqrt(dx * dx + dy * dy);\n      if (dist < nearestCraterDist) {\n        nearestCraterDist = dist;\n        nearestCraterRadius = modRadius;\n      }\n    } else if (modType < 1.5) {\n      // Add (builder)\n      float dx = worldX - modX;\n      float dy = worldY - modY;\n      float distSq = dx * dx + dy * dy;\n      if (distSq <= modRadius * modRadius) solid = true;\n    } else {\n      // Carve (tunnel)\n      vec4 data1 = texelFetch(u_modTexture, ivec2(i, 1), 0);\n      float nx = data1.r;\n      float ny = data1.g;\n      float length = data1.b;\n\n      if (isInTunnel(worldX, worldY, modX, modY, nx, ny, modRadius, length)) {\n        solid = false;\n      }\n    }\n  }\n\n  // === Render sky for non-solid pixels (background + stars) ===\n  if (!solid) {\n    // Sky gradient (matches original CSS gradient)\n    float skyT = screenPos.y / u_viewSize.y;\n    vec3 skyTop = vec3(0.008, 0.024, 0.09);    // #020617\n    vec3 skyBot = vec3(0.09, 0.145, 0.33);     // #172554\n    vec3 skyColor = mix(skyBot, skyTop, skyT);\n\n    // === Procedural starfield with parallax ===\n    // Parallax: stars move slower than camera (0.05x)\n    // Negate Y because screen Y is flipped relative to world Y\n    vec2 starUV = (screenPos + vec2(u_cameraPos.x, -u_cameraPos.y) * 0.05) / 40.0;\n\n    // Multiple star layers for depth\n    float stars = 0.0;\n    stars += star(starUV * 1.0, 1.0) * 0.8;\n    stars += star(starUV * 1.5 + 100.0, 2.0) * 0.5;\n    stars += star(starUV * 2.0 + 200.0, 3.0) * 0.3;\n\n    // Add stars to sky\n    skyColor += vec3(stars);\n\n    fragColor = vec4(skyColor, 1.0);\n    return;\n  }\n\n  // === Terrain color with gradient ===\n  float t = worldY / u_worldSize.y;\n  vec3 topColor = vec3(0.278, 0.333, 0.412);   // #475569\n  vec3 botColor = vec3(0.059, 0.090, 0.165);   // #0f172a\n  vec3 color = mix(topColor, botColor, t);\n\n  // === Grass layer near surface ===\n  float distFromSurface = worldY - baseH;\n  if (distFromSurface >= 0.0 && distFromSurface < 15.0) {\n    color = vec3(0.133, 0.773, 0.369); // #22c55e\n    if (distFromSurface < 4.0) {\n      color = vec3(0.525, 0.937, 0.675); // #86efac\n    }\n  }\n\n  // === Subtle texture noise ===\n  float texNoise = fract(sin(dot(vec2(worldX, worldY), vec2(12.9898, 78.233))) * 43758.5453);\n  color += (texNoise - 0.5) * 0.05;\n\n  // === Enhanced scorch marks near craters ===\n  if (nearestCraterRadius > 0.0) {\n    float scorchOuter = nearestCraterRadius * 1.4;  // Outer scorch radius\n    float scorchInner = nearestCraterRadius * 0.7;  // Inner dark zone\n\n    if (nearestCraterDist <= scorchOuter) {\n      // Outer scorch zone - brown/dark gradient\n      float scorchT = 1.0 - (nearestCraterDist - scorchInner) / (scorchOuter - scorchInner);\n      scorchT = clamp(scorchT, 0.0, 1.0);\n\n      // Add noise to scorch for natural look\n      float scorchNoise = noise(vec2(worldX * 0.2, worldY * 0.2)) * 0.3;\n      scorchT = clamp(scorchT + scorchNoise - 0.15, 0.0, 1.0);\n\n      // Scorch colors: dark brown to black\n      vec3 scorchColor = mix(vec3(0.15, 0.1, 0.05), vec3(0.02, 0.01, 0.01), scorchT * 0.5);\n      color = mix(color, scorchColor, scorchT * 0.7);\n\n      // Inner edge darkening (near crater wall)\n      if (nearestCraterDist <= nearestCraterRadius * 1.1) {\n        float innerT = 1.0 - (nearestCraterDist / (nearestCraterRadius * 1.1));\n        color = mix(color, vec3(0.0), innerT * 0.6);\n      }\n    }\n  }\n\n  fragColor = vec4(color, 1.0);\n}\n");if(!i||!s)return console.error("Failed to compile shaders"),!1;const a=e.createProgram();return!!a&&(e.attachShader(a,i),e.attachShader(a,s),e.linkProgram(a),e.getProgramParameter(a,e.LINK_STATUS)?(this.program=a,this.uniforms={seed:e.getUniformLocation(a,"u_seed"),cameraPos:e.getUniformLocation(a,"u_cameraPos"),viewSize:e.getUniformLocation(a,"u_viewSize"),zoom:e.getUniformLocation(a,"u_zoom"),worldSize:e.getUniformLocation(a,"u_worldSize"),modTexture:e.getUniformLocation(a,"u_modTexture"),modCount:e.getUniformLocation(a,"u_modCount")},this.vao=e.createVertexArray(),this.modTexture=e.createTexture(),e.bindTexture(e.TEXTURE_2D,this.modTexture),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),this.isInitialized=!0,!0):(console.error("Program link error:",e.getProgramInfoLog(a)),!1))}resize(t,e){this.gl&&this.gl.viewport(0,0,t,e)}uploadModifications(t){if(!this.gl||!this.modTexture)return;const e=Math.min(t.length,g);this.lastModCount=e;for(let s=0;s<e;s++){const e=t[s],i=4*s;let a=0;"add"===e.type?a=1:"carve"===e.type&&(a=2),this.modTextureData[i+0]=a,this.modTextureData[i+1]=e.x,this.modTextureData[i+2]=e.y,this.modTextureData[i+3]=e.radius;const n=16384+i;this.modTextureData[n+0]=e._nx??0,this.modTextureData[n+1]=e._ny??0,this.modTextureData[n+2]=e.length??0,this.modTextureData[n+3]=0}const i=this.gl;i.bindTexture(i.TEXTURE_2D,this.modTexture),i.texImage2D(i.TEXTURE_2D,0,i.RGBA32F,g,2,0,i.RGBA,i.FLOAT,this.modTextureData)}render(t,s,a,n,r,o){const h=this.gl;h&&this.program&&this.vao&&(h.clearColor(0,0,0,0),h.clear(h.COLOR_BUFFER_BIT),h.useProgram(this.program),h.bindVertexArray(this.vao),h.uniform1f(this.uniforms.seed,t),h.uniform2f(this.uniforms.cameraPos,s,a),h.uniform2f(this.uniforms.viewSize,n,r),h.uniform1f(this.uniforms.zoom,o),h.uniform2f(this.uniforms.worldSize,e,i),h.uniform1i(this.uniforms.modCount,this.lastModCount),h.activeTexture(h.TEXTURE0),h.bindTexture(h.TEXTURE_2D,this.modTexture),h.uniform1i(this.uniforms.modTexture,0),h.drawArrays(h.TRIANGLES,0,6))}isReady(){return this.isInitialized}dispose(){const t=this.gl;t&&(this.program&&t.deleteProgram(this.program),this.vao&&t.deleteVertexArray(this.vao),this.modTexture&&t.deleteTexture(this.modTexture),this.isInitialized=!1)}compileShader(t,e,i){const s=t.createShader(e);return s?(t.shaderSource(s,i),t.compileShader(s),t.getShaderParameter(s,t.COMPILE_STATUS)?s:(console.error(e===t.VERTEX_SHADER?"Vertex":"Fragment","shader error:",t.getShaderInfoLog(s)),t.deleteShader(s),null)):null}}class M extends t{terrainMap=null;terrainRenderer=null;terrainShaderRenderer=null;lastSyncedModCount=0;_projectiles=[];_particles=[];get projectiles(){return this._projectiles}get particles(){return this._particles}botState={planned:!1,moveTimer:0,moveDir:0,aimTimer:0,targetWeapon:s.BASIC,targetAngle:0,targetPower:0};getInitState(){return{phase:a.WAITING,tanks:[],currentTurnIndex:0,wind:0,winner:null,turnTimeEnd:0,players:this.players.map(t=>({id:t.id||null,username:t.username||null,tankId:null})),terrainSeed:Math.round(1e6*Math.random()),terrainMods:[],isSimulating:!1}}initTerrain(){this.terrainMap&&this.terrainMap.getSeed()===this.state.terrainSeed||(this.terrainMap=new m(this.state.terrainSeed),this.terrainRenderer=new p,this.lastSyncedModCount=0),this.syncTerrain()}onStateUpdate(t){super.onStateUpdate(t),this.syncTerrain()}onSocketGameState(t){super.onSocketGameState(t),this.initTerrain()}syncTerrain(){if(!this.terrainMap)return;const t=this.state.terrainMods.length;if(t===this.lastSyncedModCount)return;t<this.lastSyncedModCount&&(this.terrainMap.reset(this.state.terrainSeed),this.terrainRenderer&&this.terrainRenderer.clearCache(),this.lastSyncedModCount=0);const e=this.state.terrainMods.slice(this.lastSyncedModCount);if(e.length>0){if(this.terrainMap.applyModifications(e,!1),this.terrainRenderer)for(const t of e){const e="destroy"===t.type?t.radius*(n[s.BASIC].terrainDamageMultiplier||1.2):t.radius;"carve"===t.type&&void 0!==t.vx&&void 0!==t.vy?this.terrainRenderer.invalidateTunnel(t.x,t.y,t.vx,t.vy,t.radius,t.length||100):this.terrainRenderer.invalidateArea(t.x,t.y,e)}this.terrainShaderRenderer&&this.terrainShaderRenderer.uploadModifications(this.state.terrainMods),this.lastSyncedModCount=t}}checkSolid(t,e){return!!this.terrainMap&&this.terrainMap.isSolid(t,e)}getTerrainHeight(t){return this.terrainMap?this.terrainMap.getTerrainHeight(t):i+100}getTerrainMap(){return this.terrainMap}getTerrainRenderer(){return this.terrainRenderer}getTerrainShaderRenderer(){return this.terrainShaderRenderer}initShaderRenderer(t){this.terrainShaderRenderer||(this.terrainShaderRenderer=new x);const e=this.terrainShaderRenderer.init(t);return e&&this.terrainMap&&this.terrainShaderRenderer.uploadModifications(this.state.terrainMods),e}seededRandom(t){const e=1e4*Math.sin(t);return e-Math.floor(e)}onSocketGameAction(t){const e=t.action;switch(console.log("onSocketGameAction",t),e.type){case"FIRE_SHOT":this.fireTank(e.shot);break;case"COMMIT_ANGLE":this.handleCommitAngle(e.angle,e.playerId);break;case"COMMIT_POWER":this.handleCommitPower(e.power,e.playerId);break;case"SELECT_WEAPON":this.handleSelectWeapon(e.weapon,e.playerId);break;case"MOVE_START":this.handleMoveStart(e.direction,e.x,e.playerId);break;case"MOVE_STOP":this.handleMoveStop(e.x,e.y,e.fuel,e.playerId);break;default:if(!this.isHost)return;switch(e.type){case"FIRE":this.handleFire(e.playerId);break;case"START_GAME":this.handleStartGame();break;case"RESET_GAME":this.reset();break;case"ADD_BOT":this.addBot();break;case"REMOVE_BOT":this.removeBot()}}}handleCommitAngle(t,e){const i=this.getTankByPlayerId(e);i&&this.isPlayerTurn(e)&&this.state.phase===a.AIMING&&(i.angle=Math.max(0,Math.min(180,t)))}handleCommitPower(t,e){const i=this.getTankByPlayerId(e);i&&this.isPlayerTurn(e)&&this.state.phase===a.AIMING&&(i.power=Math.max(0,Math.min(100,t)))}handleSelectWeapon(t,e){const i=this.getTankByPlayerId(e);i&&this.isPlayerTurn(e)&&this.state.phase===a.AIMING&&(i.weapon=t)}handleMoveStart(t,e,i){const s=this.getTankByPlayerId(i);s&&this.isPlayerTurn(i)&&this.state.phase===a.AIMING&&(s.isMoving=!0,s.moveDir=t)}handleMoveStop(t,e,i,s){const n=this.getTankByPlayerId(s);n&&this.isPlayerTurn(s)&&this.state.phase===a.AIMING&&(n.isMoving=!1,n.moveDir=void 0,n.x=t,n.y=e,n.fuel=i,this._tankSimulations.delete(n.id))}handleFire(t){if(!this.isHost)return;if(this.state.phase!==a.AIMING)return;if(!this.isPlayerTurn(t))return;const e=this.getTankByPlayerId(t);if(!e)return;const i={tankId:e.id,x:e.x,y:e.y,angle:e.angle,power:e.power,weapon:e.weapon,wind:this.state.wind,seed:Math.random()};this.makeAction({type:"FIRE_SHOT",shot:i})}_tankSimulations=new Map;update(){if(this.syncTerrain(),!this.terrainMap)return;this.state.phase===a.AIMING&&this.state.tanks.forEach(t=>{if(t.isMoving&&t.moveDir){let e=this._tankSimulations.get(t.id);e||(e={x:t.x,y:t.y,fuel:t.fuel,angle:t.angle},this._tankSimulations.set(t.id,e));const i={...t,...e},s=this.calculateTankMovement(i,t.moveDir);s?(e.x=s.x,e.y=s.y,e.fuel=s.fuel):(t.playerId===this.userId&&this.moveStop(),t.isMoving=!1,t.moveDir=void 0,this._tankSimulations.delete(t.id))}else this._tankSimulations.has(t.id)&&this._tankSimulations.delete(t.id)});const t=this.updateTankPhysics(),e=this.updateProjectilePhysics(),i=this.updateParticlePhysics();this.checkPhaseTransitions(t,e,i)&&this.state.isSimulating&&this.onSimulationEnd()}getVisualTank(t){const e=this._tankSimulations.get(t.id);return e?{...t,...e}:t}gravityTank(t,e,s){const a={x:t,y:e,health:s,moving:!1};if(a.health<=0)return a;if(this.checkSolid(a.x,a.y+1))for(;this.checkSolid(a.x,a.y);)a.y--,a.moving=!0;else a.y+=3,a.moving=!0,a.y>i&&(a.health=0);return a}calculateTankMovement(t,i){if(!this.terrainMap||t.fuel<=0)return null;let{x:s,y:a,fuel:n,angle:o}=t;const h=Math.max(15,Math.min(e-15,s+i*u));if(this.checkSolid(h,a)){let t=!1;for(let e=1;e<=5;e++)if(!this.checkSolid(h,a-e)){s=h,a-=e,t=!0;break}t&&(n-=r)}else{s=h,n-=r;for(let t=1;t<=5;t++)if(this.checkSolid(s,a+t)){a+=t-1;break}}return{x:s,y:a,fuel:Math.max(0,n),angle:o}}fireTank(t){this.state.phase=a.FIRING,this.state.isSimulating=!0;const e=t.angle*Math.PI/180,i=t.power/100*o,s=(s=0,a=0)=>{const n=e+s*Math.PI/180,r=t.x+30*Math.cos(n),o=t.y-10-30*Math.sin(n);return{id:(t.seed+a).toString(36),x:r,y:o,vx:Math.cos(n)*i,vy:-Math.sin(n)*i,radius:5,weapon:t.weapon,ownerId:t.tankId,active:!0}},r=n[t.weapon],h=r.count,l=r.spread||0;for(let a=0;a<h;a++){let t=0;h>1&&(t=-(h-1)*l/2+a*l),this._projectiles.push(s(t,.001*a))}this.state.phase=a.PROJECTILE_MOVING}updateTankPhysics(){let t=!1;return this._tankSimulations.forEach(e=>{const{x:i,y:s,moving:a}=this.gravityTank(e.x,e.y,100);a&&(e.x=i,e.y=s,t=!0)}),this.state.tanks.forEach(e=>{const{x:i,y:s,health:a,moving:n}=this.gravityTank(e.x,e.y,e.health);n&&(e.x=i,e.y=s,e.health=a,t=!0)}),t}updateProjectilePhysics(){let t=!1;return this._projectiles.forEach(s=>{s.active&&(t=!0,s.x+=s.vx,s.y+=s.vy,s.vy+=h,s.vx+=this.state.wind,Math.random()>.3&&this.createTrailParticle(s),this.checkProjectileTankCollision(s)||(s.x<0||s.x>e||s.y>i?s.active=!1:this.checkSolid(s.x,s.y)&&this.explode(s)))}),this._projectiles=this._projectiles.filter(t=>t.active),t}checkProjectileTankCollision(t){for(const e of this.state.tanks){if(e.health<=0)continue;if(e.id===t.ownerId&&Math.abs(t.x-e.x)<20&&Math.abs(t.y-e.y)<20)continue;const i=e.x-t.x,s=e.y-10-t.y;if(Math.sqrt(i*i+s*s)<15)return this.explode(t),!0}return!1}updateParticlePhysics(){let t=!1;return this._particles.forEach(e=>{e.x+=e.vx,e.y+=e.vy,e.life-=e.decay,"smoke"===e.type&&(e.vy-=.05,e.size+=.1),t=!0}),this._particles=this._particles.filter(t=>t.life>0),t}checkPhaseTransitions(t,e,i){const s=this.state;return 0===this._projectiles.filter(t=>t.active).length&&s.phase===a.PROJECTILE_MOVING&&(s.phase=a.IMPACT,s.turnTimeEnd=Date.now()+1e3),s.phase===a.IMPACT&&s.turnTimeEnd<=Date.now()&&!t||!(t||e||i||s.tanks.some(t=>t.isMoving)||s.phase===a.IMPACT||s.phase===a.PROJECTILE_MOVING)}explode(t){const e=n[t.weapon]||n[s.BASIC];if(this.isHost)if(e.type===s.BUILDER)this.state.terrainMods.push({type:"add",x:Math.round(t.x),y:Math.round(t.y),radius:Math.round(e.radius)});else if(e.type===s.DRILL)this.state.terrainMods.push({type:"carve",x:Math.round(t.x),y:Math.round(t.y),vx:t.vx,vy:t.vy,radius:Math.round(e.radius),length:150});else if(e.type!==s.TELEPORT&&e.type!==s.AIRSTRIKE&&e.type!==s.HEAL){const i=e.radius*e.terrainDamageMultiplier;this.state.terrainMods.push({type:"destroy",x:Math.round(t.x),y:Math.round(t.y),radius:Math.round(i)})}this.syncTerrain(),this.createExplosionParticles(t.x,t.y,e),this.handleSpecialWeapons(t,e),this.isHost&&e.damage>0&&this.state.tanks.forEach(i=>{const a=i.x-t.x,n=i.y-10-t.y,r=Math.sqrt(a*a+n*n);if(r<e.radius+20){const t=Math.floor(e.damage*(1-r/(e.radius+50)));t>0&&(e.type===s.HEAL?i.health=Math.min(i.maxHealth,i.health+t):i.health=Math.max(0,i.health-t))}}),e.damage>0&&this.state.tanks.forEach(i=>{const a=i.x-t.x,n=i.y-10-t.y,r=Math.sqrt(a*a+n*n);if(r<e.radius+20){Math.floor(e.damage*(1-r/(e.radius+50)))>0&&(e.type===s.HEAL?this.createParticles(i.x,i.y-10,8,"glow",1,"#4ade80"):this.createParticles(i.x,i.y-10,10,"spark",2))}}),t.active=!1}handleSpecialWeapons(t,e){if(e.type===s.TELEPORT){if(!this.isHost)return;const i=this.state.tanks.find(e=>e.id===t.ownerId);if(i){let s=null,a=e.radius+15;for(const e of this.state.tanks){if(e.id===i.id||e.health<=0)continue;const n=Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-10-t.y,2));n<a&&(a=n,s=e)}if(s){const t=s.x,e=s.y;s.x=i.x,s.y=i.y,i.x=t,i.y=e}else{i.x=t.x,i.y=t.y;let e=0;for(;this.checkSolid(i.x,i.y)&&e<50;)i.y--,e++}}}if(e.type===s.AIRSTRIKE){const e=Number(t.id)||0;for(let i=0;i<8;i++){const a=e+.1*i,n=100*(this.seededRandom(a)-.5),r=200*-this.seededRandom(a+.05);this._projectiles.push({id:(e+1+.1*i).toString(),x:t.x+n,y:r,vx:0,vy:5+5*this.seededRandom(a+.07),radius:5,weapon:s.AIRSTRIKE_BOMB,ownerId:t.ownerId,active:!0})}}}createExplosionParticles(t,e,i){i.type===s.NUKE?(this.createParticles(t,e,100,"fire",3),this.createParticles(t,e,50,"smoke",2),this.createParticles(t,e,30,"glow",4,"#d946ef")):i.type===s.TELEPORT?(this.createParticles(t,e,30,"glow",2,"#c084fc"),this.createParticles(t,e,20,"spark",3,"#ffffff")):i.type===s.BUILDER?this.createParticles(t,e,20,"smoke",1,"#64748b"):i.type===s.HEAL?(this.createParticles(t,e,20,"glow",2,"#4ade80"),this.createParticles(t,e,15,"spark",1.5,"#ffffff")):(this.createParticles(t,e,20,"fire",1.5),this.createParticles(t,e,20,"smoke",1))}createTrailParticle(t){const e={[s.NUKE]:"#d946ef",[s.DRILL]:"#94a3b8",[s.TELEPORT]:"#c084fc",[s.AIRSTRIKE]:"#ef4444",[s.AIRSTRIKE_BOMB]:"#ef4444",[s.BUILDER]:"#60a5fa",[s.HEAL]:"#4ade80"}[t.weapon];e?this.createParticles(t.x,t.y,1,"glow",.3,e):this._particles.push({x:t.x,y:t.y,vx:0,vy:0,life:.5,decay:.1,size:2,color:"rgba(255,255,255,0.5)",type:"smoke"})}createParticles(t,e,i,s,a=1,n){const r=Math.min(i,50);for(let o=0;o<r;o++){const i=Math.random()*Math.PI*2,r=2*Math.random()*a;let o="#fff",h=.02,l=3*Math.random()+1;"fire"===s?(o=n||(Math.random()>.5?"#fbbf24":"#ef4444"),h=.04,l=6*Math.random()+4):"smoke"===s?(o=n||`rgba(100, 116, 139, ${Math.random()})`,h=.02,l=8*Math.random()+4):"spark"===s?(o=n||"#facc15",h=.08,l=2*Math.random()+1):"glow"===s&&(o=n||"#22c55e",h=.05,l=5*Math.random()+2),this._particles.push({x:t,y:e,vx:Math.cos(i)*r,vy:Math.sin(i)*r,life:1,decay:h,size:l,color:o,type:s})}}onSimulationEnd(){if(!this.state.isSimulating)return;this.state.isSimulating=!1;const t=this.state.tanks.filter(t=>t.health>0);if(t.length<=1)if(this.state.phase=a.GAME_OVER,1===t.length){const e=t[0],i=this.state.players.find(t=>t.id===e.playerId);this.state.winner=i?.username||(e.isBot?"Bot":"Player")}else this.state.winner="Draw";else this.nextTurn(),this.checkBotTurn()}nextTurn(){const t=this.state;for(t.currentTurnIndex=(t.currentTurnIndex+1)%t.tanks.length;t.tanks[t.currentTurnIndex].health<=0;)t.currentTurnIndex=(t.currentTurnIndex+1)%t.tanks.length;t.tanks[t.currentTurnIndex].fuel=l,this.botState.planned=!1,t.phase=a.AIMING,t.wind=.05*Math.random()-.025}checkBotTurn(){if(!this.isHost)return;if(this.state.phase!==a.AIMING)return;if(this.state.isSimulating)return;const t=this.state.tanks[this.state.currentTurnIndex];t?.isBot&&setTimeout(()=>this.runBotTurn(),500)}runBotTurn(){const t=this.state.tanks[this.state.currentTurnIndex];t&&t.isBot&&this.state.phase===a.AIMING&&(this.botState.planned||(this.planBotMove(t),this.botState.planned=!0),this.executeBotPlan(t))}planBotMove(t){this.botState.moveDir=Math.random()>.5?1:-1,this.botState.moveTimer=Math.floor(30*Math.random()),this.botState.aimTimer=1;const a=this.state.tanks.find(e=>e.id!==t.id&&e.health>0);if(a)if(t.health<35)this.botState.targetWeapon=s.HEAL,this.botState.targetAngle=90,this.botState.targetPower=15;else if(t.y>i-300){this.botState.targetWeapon=s.TELEPORT;const i=e/2-t.x;this.botState.targetAngle=i>0?60:120,this.botState.targetPower=80}else{const e=a.x-t.x,i=Math.abs(e),n=e>0?1:-1;if(i<400)this.botState.targetWeapon=Math.random()>.5?s.SCATTER:s.DRILL;else if(i>800)this.botState.targetWeapon=Math.random()>.6?s.NUKE:s.BASIC;else{const t=[s.BASIC,s.BARRAGE];this.botState.targetWeapon=t[Math.floor(Math.random()*t.length)]}const r=n>0?45:135;this.botState.targetAngle=r+(10*Math.random()-5);const l=Math.sqrt(i*h)/o*100,d=.1*(a.y-t.y);this.botState.targetPower=Math.max(10,Math.min(100,l+d+(10*Math.random()-5)))}}executeBotPlan(t){this.botState.moveTimer>0&&!t.isMoving&&(t.isMoving=!0,t.moveDir=this.botState.moveDir,-1===this.botState.moveDir?t.angle=Math.max(90,Math.min(180,t.angle)):t.angle=Math.max(0,Math.min(90,t.angle)));const e=()=>{if(console.log("step"),this.botState.moveTimer>0)return this.botState.moveTimer--,this.botState.moveTimer<=0&&(t.isMoving=!1,t.moveDir=void 0),void requestAnimationFrame(e);if(this.botState.aimTimer>0){t.weapon=this.botState.targetWeapon;const i=this.botState.targetAngle-t.angle;t.angle+=.4*i;const s=this.botState.targetPower-t.power;return t.power+=.4*s,this.botState.aimTimer--,void requestAnimationFrame(e)}t.angle=this.botState.targetAngle,t.power=this.botState.targetPower,this.handleFire(t.playerId||"BOT")};requestAnimationFrame(e)}startGame(){this.handleStartGame()}handleStartGame(){if(this.state.phase!==a.WAITING)return;this.initTerrain();const t=this.state.players.length,i=e/(t+1);this.state.tanks=this.state.players.map((t,e)=>{const a=`tank-${e+1}`;t.tankId=a;const n=Math.floor(i*(e+1)),r=this.getTerrainHeight(n);return{id:a,name:t.username||("BOT"===t.id?"Bot":"Player"),playerId:t.id,isBot:"BOT"===t.id,x:n,y:r,angle:45,power:50,health:c,maxHealth:c,color:d[e%d.length],weapon:s.BASIC,fuel:l}}),this.state.phase=a.AIMING,this.state.wind=.05*Math.random()-.025,this.state.currentTurnIndex=0,this.checkBotTurn()}reset(){this.state.phase=a.WAITING,this.state.tanks=[],this.state.currentTurnIndex=0,this.state.wind=0,this.state.winner=null,this.state.turnTimeEnd=0,this.state.players.forEach(t=>{t.tankId=null}),this.state.terrainSeed=Math.round(1e6*Math.random()),this.state.terrainMods=[],this.state.isSimulating=!1}addBot(){this.isHost&&this.state.phase===a.WAITING&&this.state.players.push({id:"BOT",username:`Bot ${this.state.players.filter(t=>"BOT"===t.id).length+1}`,tankId:null})}removeBot(){if(!this.isHost)return;if(this.state.phase!==a.WAITING)return;const t=[...this.state.players].reverse().findIndex(t=>"BOT"===t.id);if(-1!==t){const e=this.state.players.length-1-t;this.state.players.splice(e,1)}}requestAddBot(){this.makeAction({type:"ADD_BOT"})}requestRemoveBot(){this.makeAction({type:"REMOVE_BOT"})}requestReset(){this.makeAction({type:"RESET_GAME"})}commitAngle(t){const e={type:"COMMIT_ANGLE",angle:t,playerId:this.userId};this.makeAction(e)}commitPower(t){const e={type:"COMMIT_POWER",power:t,playerId:this.userId};this.makeAction(e)}selectWeapon(t){const e={type:"SELECT_WEAPON",weapon:t,playerId:this.userId};this.makeAction(e)}moveStart(t){const e=this.getMyTank();if(!e)return;const i={type:"MOVE_START",direction:t,x:e.x,playerId:this.userId};this.makeAction(i)}moveStop(){const t=this.getMyTank();if(!t)return;const e=this._tankSimulations.get(t.id),i={type:"MOVE_STOP",x:e?.x??t.x,y:e?.y??t.y,fuel:e?.fuel??t.fuel,playerId:this.userId};this.makeAction(i)}fire(){const t={type:"FIRE",playerId:this.userId};this.makeAction(t)}getTankByPlayerId(t){return this.state.tanks.find(e=>e.playerId===t)}isPlayerTurn(t){const e=this.state.tanks[this.state.currentTurnIndex];return e?.playerId===t}getMyTank(){return this.state.tanks.find(t=>t.playerId===this.userId)}isMyTurn(){return this.isPlayerTurn(this.userId)}getCurrentTank(){return this.state.tanks[this.state.currentTurnIndex]}canStartGame(){return this.state.players.length>1&&this.state.phase===a.WAITING}updatePlayers(t){if(!(this.players[0]?.id===this.userId))return;const e=[...this.state.players],i=e.filter(t=>"BOT"===t.id),s=t.map(t=>{const i=e.find(e=>e.id===t.id);return{id:t.id,username:t.username,tankId:i?.tankId||null}});s.push(...i),this.state.players=s}destroy(){super.destroy()}}export{M as default};
