import{B as e}from"./BaseGame-BoHpQUK3.js";import{W as t,a as n,B as i,S as a,P as r,M as o,b as s,G as l,c as h,F as d,d as c,e as u,f,g as m,T as p,I as y,h as g}from"./constants-Dc6HpWt9.js";import"./socket-DRbsQkF5.js";import"./index-BLcGWsmB.js";import"./react-vendor-DeJ0i39y.js";import"./zustand-ie0NTbcC.js";function v(e,t){let n=.1031*e+.3117*t;return n-=Math.floor(n),n*=n+33.33,n*=n+n,n-Math.floor(n)}function x(e,t){const n=Math.floor(e),i=e-n,a=i*i*(3-2*i);return v(n,t)*(1-a)+v(n+1,t)*a}function T(e,t){const n=function(e,t,n=4){let i=0,a=.5,r=1;for(let o=0;o<n;o++)i+=a*x(e*r,t+100*o),a*=.5,r*=2;return i}(e*i,t,2);return n<.15?2:n<.3?0:n<.45?1:n<.6?3:4}class M{bounds;entries=[];children=null;depth;static MAX_ENTRIES=8;static MAX_DEPTH=12;constructor(e,t=0){this.bounds=e,this.depth=t}insert(e){if(this.intersectsBounds(e.bounds))if(this.children)for(const t of this.children)t.intersectsBounds(e.bounds)&&t.insert(e);else this.entries.push(e),this.entries.length>M.MAX_ENTRIES&&this.depth<M.MAX_DEPTH&&this.split()}queryPoint(e,t){if(!this.containsPoint(e,t))return[];const n=[];for(const i of this.entries)this.pointInModification(e,t,i)&&n.push(i);if(this.children)for(const i of this.children)n.push(...i.queryPoint(e,t));return n}queryCircle(e,t,n){const i={x:e-n,y:t-n,width:2*n,height:2*n};if(!this.intersectsBounds(i))return[];const a=[];for(const r of this.entries)a.push(r);if(this.children)for(const r of this.children)a.push(...r.queryCircle(e,t,n));return a}clear(){this.entries=[],this.children=null}split(){const{x:e,y:t,width:n,height:i}=this.bounds,a=n/2,r=i/2;this.children=[new M({x:e,y:t,width:a,height:r},this.depth+1),new M({x:e+a,y:t,width:a,height:r},this.depth+1),new M({x:e,y:t+r,width:a,height:r},this.depth+1),new M({x:e+a,y:t+r,width:a,height:r},this.depth+1)];for(const o of this.entries)for(const e of this.children)e.intersectsBounds(o.bounds)&&e.insert(o)}containsPoint(e,t){return e>=this.bounds.x&&e<this.bounds.x+this.bounds.width&&t>=this.bounds.y&&t<this.bounds.y+this.bounds.height}intersectsBounds(e){return!(e.x>this.bounds.x+this.bounds.width||e.x+e.width<this.bounds.x||e.y>this.bounds.y+this.bounds.height||e.y+e.height<this.bounds.y)}pointInModification(e,t,n){const i=n.modification;if("carve"===i.type&&void 0!==i.vx&&void 0!==i.vy)return this.pointInCapsule(e,t,i.x,i.y,i.vx,i.vy,i.radius,i.length||100);const a=e-i.x,r=t-i.y;return a*a+r*r<=i.radius*i.radius}pointInCapsule(e,t,n,i,a,r,o,s){const l=Math.sqrt(a*a+r*r);if(0===l)return!1;const h=n+a/l*s-n,d=i+r/l*s-i,c=h*h+d*d;if(0===c){return(e-n)**2+(t-i)**2<=o*o}let u=((e-n)*h+(t-i)*d)/c;u=Math.max(0,Math.min(1,u));return(e-(n+u*h))**2+(t-(i+u*d))**2<=o*o}}class S{seed;quadtree;modificationCounter=0;modifications=[];bounds;static CACHE_SIZE=4096;static CACHE_MASK=4095;baseHeightCache=new Float32Array(S.CACHE_SIZE);baseHeightKeys=new Int32Array(S.CACHE_SIZE).fill(-999999);constructor(e,i=2*t,a=2*n){this.seed=e,this.bounds={x:-i/2,y:-a/2,width:2*i,height:2*a},this.quadtree=new M(this.bounds)}getBaseHeight(e){const i=Math.round(e),a=i&S.CACHE_MASK;if(this.baseHeightKeys[a]===i)return this.baseHeightCache[a];const r=function(e,i){const a=t,r=n;let o=r/1.6+(300*Math.sin(.001*(e+i))+80*Math.sin(.005*(e+2*i))+20*Math.sin(.02*(e+3*i)))+-200*Math.sin(e/a*Math.PI*5+i);return o=Math.max(200,Math.min(r-100,o)),o}(e,this.seed);return this.baseHeightKeys[a]=i,this.baseHeightCache[a]=r,r}getTerrainHeight(e){const t=this.getBaseHeight(e),i=this.quadtree.queryCircle(e,t/2,t/2+100);if(0===i.length)return t;let a=t;for(const n of i)if("add"===n.modification.type){const e=n.modification.y-n.modification.radius;e<a&&(a=e)}for(let r=Math.max(0,Math.floor(a));r<n;r+=4)if(this.isSolidFast(e,r,t)){for(let n=Math.max(0,r-4);n<=r;n++)if(this.isSolidFast(e,n,t))return n;return r}return t}isSolid(e,t){if(t>=n||t<0)return!1;const i=this.getBaseHeight(e);return this.isSolidFast(e,t,i)}isSolidFast(e,t,i){if(t>=n||t<0)return!1;let a=t>=i;const r=this.quadtree.queryPoint(e,t);if(0===r.length)return a;r.length>1&&r.sort((e,t)=>e.timestamp-t.timestamp);for(let n=0;n<r.length;n++){const i=r[n].modification,o=e-i.x,s=t-i.y,l=o*o+s*s,h=i._radiusSq;"destroy"===i.type?l<=h&&(a=!1):"add"===i.type?l<=h&&(a=!0):"carve"===i.type&&this.isInTunnel(e,t,i)&&(a=!1)}return a}destroyCircle(e,t,n){const i={type:"destroy",x:e,y:t,radius:n};this.addModification(i)}addCircle(e,t,n){const i={type:"add",x:e,y:t,radius:n};this.addModification(i)}carveTunnel(e,t,n,i,a,r=100){const o={type:"carve",x:e,y:t,radius:a,vx:n,vy:i,length:r};this.addModification(o)}getModifications(){return[...this.modifications]}applyModifications(e,t=!0){t&&(this.quadtree.clear(),this.modifications=[],this.modificationCounter=0,this.baseHeightKeys.fill(-999999));for(const n of e)this.addModification(n)}reset(e){this.seed=e,this.quadtree.clear(),this.modifications=[],this.modificationCounter=0,this.baseHeightKeys.fill(-999999)}addModification(e){if(e._radiusSq=e.radius*e.radius,void 0!==e.vx&&void 0!==e.vy){const t=Math.hypot(e.vx,e.vy);t>0&&(e._nx=e.vx/t,e._ny=e.vy/t)}const t={modification:e,bounds:this.getModificationBounds(e),timestamp:this.modificationCounter++};this.quadtree.insert(t),this.modifications.push(e)}getModificationBounds(e){if("carve"===e.type&&void 0!==e.vx&&void 0!==e.vy){const t=Math.sqrt(e.vx*e.vx+e.vy*e.vy);if(t>0){const n=e.vx/t,i=e.vy/t,a=e.length||100,r=e.x+n*a,o=e.y+i*a,s=Math.min(e.x,r)-e.radius,l=Math.max(e.x,r)+e.radius,h=Math.min(e.y,o)-e.radius;return{x:s,y:h,width:l-s,height:Math.max(e.y,o)+e.radius-h}}}return{x:e.x-e.radius,y:e.y-e.radius,width:2*e.radius,height:2*e.radius}}isInTunnel(e,t,n){const i=n._nx,a=n._ny;if(void 0===i||void 0===a)return!1;const r=n.length||100,o=i*r,s=a*r,l=r*r;if(0===l){return(e-n.x)**2+(t-n.y)**2<=n._radiusSq}let h=((e-n.x)*o+(t-n.y)*s)/l;h=Math.max(0,Math.min(1,h));return(e-(n.x+h*o))**2+(t-(n.y+h*s))**2<=n._radiusSq}getSeed(){return this.seed}}const k=256;class I{chunks=new Map;dirtyChunks=new Set;chunkAccessOrder=[];skyChunks=new Set;clearCache(){this.chunks.clear(),this.dirtyChunks.clear(),this.chunkAccessOrder=[],this.skyChunks.clear()}isChunkSkyOnly(e,t,n){const i=e*k,a=(t+1)*k;for(let o=0;o<=k;o+=32){const e=i+o;if(n.getBaseHeight(e)<a)return!1}const r=n.getModifications();for(const o of r)if("add"===o.type){const e=o.y-o.radius,n=o.y+o.radius,r=o.x-o.radius;if(o.x+o.radius>=i&&r<=i+k&&n>=t*k&&e<=a)return!1}return!0}renderVisibleChunks(e,t,n,i,a,r,o){const s=i/r,l=a/r,h=Math.floor(t/k),d=Math.ceil((t+s)/k),c=Math.floor(n/k),u=Math.ceil((n+l)/k);let f=0;const m=t+s/2,p=n+l/2,y=[];for(let g=h;g<=d;g++)for(let t=c;t<=u;t++){const n=`${g},${t}`;if(!this.skyChunks.has(n)||this.dirtyChunks.has(n))if(this.chunks.has(n)||this.dirtyChunks.has(n)||!this.isChunkSkyOnly(g,t,o))if(!this.chunks.has(n)||this.dirtyChunks.has(n)){const e=(g+.5)*k,i=(t+.5)*k,a=Math.abs(e-m)+Math.abs(i-p);y.push({cx:g,cy:t,key:n,dist:a})}else{const i=this.chunks.get(n);if(i){const a=g*k-.5,r=t*k-.5;e.drawImage(i,a,r,257,257),this.updateLRU(n)}}else this.skyChunks.add(n)}y.sort((e,t)=>e.dist-t.dist);for(const{cx:g,cy:v,key:x}of y){if(f>=4)break;if(this.dirtyChunks.has(x)&&(this.skyChunks.delete(x),this.isChunkSkyOnly(g,v,o))){this.skyChunks.add(x),this.dirtyChunks.delete(x),this.chunks.delete(x);continue}this.generateChunk(g,v,o),this.dirtyChunks.delete(x),f++;const t=this.chunks.get(x);if(t){const n=g*k-.5,i=v*k-.5;e.drawImage(t,n,i,257,257),this.updateLRU(x)}}this.pruneChunks()}invalidateArea(e,t,n){const i=Math.floor((e-n)/k),a=Math.ceil((e+n)/k),r=Math.floor((t-n)/k),o=Math.ceil((t+n)/k);for(let s=i;s<=a;s++)for(let e=r;e<=o;e++)this.dirtyChunks.add(`${s},${e}`)}invalidateTunnel(e,t,n,i,a,r){const o=Math.sqrt(n*n+i*i);if(0===o)return void this.invalidateArea(e,t,a);const s=e+n/o*r,l=t+i/o*r,h=Math.min(e,s)-a,d=Math.max(e,s)+a,c=Math.min(t,l)-a,u=Math.max(t,l)+a,f=Math.floor(h/k),m=Math.ceil(d/k),p=Math.floor(c/k),y=Math.ceil(u/k);for(let g=f;g<=m;g++)for(let e=p;e<=y;e++)this.dirtyChunks.add(`${g},${e}`)}clear(){this.chunks.clear(),this.dirtyChunks.clear(),this.chunkAccessOrder=[],this.skyChunks.clear()}generateChunk(e,t,i){const a=`${e},${t}`;let r=this.chunks.get(a);r||(r=document.createElement("canvas"),r.width=k,r.height=k,this.chunks.set(a,r));const o=r.getContext("2d");o.clearRect(0,0,k,k);const s=e*k,l=t*k,h=new Float32Array(257);for(let n=0;n<=k;n++)h[n]=i.getBaseHeight(s+n);const d={0:["#475569","#0f172a","#22c55e","#86efac"],1:["#737373","#262626","#a3a3a3","#e5e5e5"],2:["#2e4f36","#1a2e22","#166534","#4ade80"],3:["#d4a574","#8b4513","#d4a574","#f4d08a"],4:["#d1d5db","#5b6e80","#e5e7eb","#f9fafb"]},c=d[T(s+128,i.getSeed())]||d[0];o.beginPath();let u=!1;for(let n=0;n<=k;n++){const e=h[n]-l;e<=k&&(u?o.lineTo(n,Math.max(0,e)):(o.moveTo(n,Math.max(0,e)),u=!0))}o.lineTo(k,k),o.lineTo(0,k),o.closePath();const f=-l,m=n-l,p=o.createLinearGradient(0,f,0,m);p.addColorStop(0,c[0]),p.addColorStop(1,c[1]),o.fillStyle=p,o.fill(),o.globalCompositeOperation="source-atop";for(let n=0;n<15;n++){const e=4*Math.random()+1,t=Math.random()*k,n=Math.random()*k;o.fillStyle=Math.random()>.5?"rgba(0,0,0,0.2)":"rgba(255,255,255,0.05)",o.beginPath(),o.arc(t,n,e,0,2*Math.PI),o.fill()}o.globalCompositeOperation="source-over",o.beginPath();for(let n=0;n<=k;n++){const e=h[n]-l;0===n?o.moveTo(n,e):o.lineTo(n,e)}o.strokeStyle=c[2],o.lineWidth=15,o.lineCap="round",o.stroke(),o.strokeStyle=c[3],o.lineWidth=4,o.stroke(),this.applyModifications(o,s,l,i)}applyModifications(e,t,n,i){const a=i.getModifications();for(const r of a){const i=r.x-t,a=r.y-n,o=r.radius+20;if(i<-o||i>k+o||a<-o||a>k+o){if("carve"!==r.type||void 0===r.vx||void 0===r.vy)continue;{const e=Math.sqrt(r.vx*r.vx+r.vy*r.vy);if(e>0){const t=r.vx/e,n=r.vy/e,o=r.length||100,s=i+t*o,l=a+n*o,h=Math.min(i,s)-r.radius,d=Math.max(i,s)+r.radius,c=Math.min(a,l)-r.radius,u=Math.max(a,l)+r.radius;if(d<0||h>k||u<0||c>k)continue}}}if("destroy"===r.type){e.save(),e.globalCompositeOperation="destination-out",e.beginPath();for(let t=0;t<2*Math.PI;t+=.2){const n=r.radius*(.9+.2*Math.random()),o=i+Math.cos(t)*n,s=a+Math.sin(t)*n;0===t?e.moveTo(o,s):e.lineTo(o,s)}e.closePath(),e.fillStyle="#000",e.fill(),e.restore(),e.save(),e.globalCompositeOperation="source-atop",e.beginPath(),e.arc(i,a,r.radius+10,0,2*Math.PI),e.fillStyle="rgba(0, 0, 0, 0.5)",e.fill(),e.restore()}else if("add"===r.type)e.save(),e.globalCompositeOperation="source-over",e.beginPath(),e.arc(i,a,r.radius,0,2*Math.PI),e.fillStyle="#64748b",e.fill(),e.lineWidth=2,e.strokeStyle="#94a3b8",e.stroke(),e.restore();else if("carve"===r.type&&void 0!==r.vx&&void 0!==r.vy){const t=Math.sqrt(r.vx*r.vx+r.vy*r.vy);if(0===t)continue;const n=r.vx/t,o=r.vy/t,s=r.length||100;e.save(),e.globalCompositeOperation="destination-out",e.lineWidth=2*r.radius,e.lineCap="round",e.beginPath(),e.moveTo(i,a),e.lineTo(i+n*s,a+o*s),e.stroke(),e.restore(),e.save(),e.globalCompositeOperation="source-atop",e.lineWidth=2*r.radius+10,e.lineCap="round",e.strokeStyle="rgba(0,0,0,0.5)",e.beginPath(),e.moveTo(i,a),e.lineTo(i+n*s,a+o*s),e.stroke(),e.restore()}}}updateLRU(e){const t=this.chunkAccessOrder.indexOf(e);t>=0&&this.chunkAccessOrder.splice(t,1),this.chunkAccessOrder.push(e)}pruneChunks(){for(;this.chunks.size>64&&this.chunkAccessOrder.length>0;){const e=this.chunkAccessOrder.shift();this.chunks.delete(e),console.log("Pruned chunk",e)}}}const w=`#version 300 es\nprecision highp float;\n\nuniform float u_seed;\nuniform vec2 u_cameraPos;\nuniform vec2 u_viewSize;\nuniform float u_zoom;\nuniform vec2 u_worldSize;\nuniform sampler2D u_modTexture;\nuniform int u_modCount;\nuniform float u_time;\n\nout vec4 fragColor;\n\n// === Biome constants (must match CPU) ===\nconst float BIOME_SCALE = ${i.toFixed(10)};\nconst float SNOW_THRESHOLD = ${a.toFixed(1)};\n\n// Biome indices: 0=plains, 1=mountains, 2=valley, 3=desert, 4=tundra\n\n// === Noise functions ===\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat hash1D(float x, float seed) {\n  float p = x * 0.1031 + seed * 0.3117;\n  p = fract(p);\n  p *= p + 33.33;\n  p *= p + p;\n  return fract(p);\n}\n\nfloat noise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  f = f * f * (3.0 - 2.0 * f);\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nfloat noise1D(float x, float seed) {\n  float i = floor(x);\n  float f = fract(x);\n  float u = f * f * (3.0 - 2.0 * f);\n  return hash1D(i, seed) * (1.0 - u) + hash1D(i + 1.0, seed) * u;\n}\n\nfloat fbm(vec2 p) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  for (int i = 0; i < 4; i++) {\n    value += amplitude * noise(p);\n    p *= 2.0;\n    amplitude *= 0.5;\n  }\n  return value;\n}\n\nfloat fbm1D(float x, float seed, int octaves) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n  for (int i = 0; i < octaves; i++) {\n    value += amplitude * noise1D(x * frequency, seed + float(i) * 100.0);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}\n\n// === Biome detection (must match CPU) ===\nint getBiomeIndex(float x) {\n  // Match CPU chunk-based rendering (CHUNK_SIZE = 256)\n  // Sample at the center of each 256-pixel chunk\n  float chunkX = floor(x / 256.0) * 256.0 + 128.0;\n  float biomeNoise = fbm1D(chunkX * BIOME_SCALE, u_seed, 2);\n  if (biomeNoise < 0.15) return 2; // Valley\n  if (biomeNoise < 0.30) return 0; // Plains\n  if (biomeNoise < 0.45) return 1; // Mountains\n  if (biomeNoise < 0.60) return 3; // Desert\n  return 4; // Tundra\n}\n\n// === Simple terrain height (MUST MATCH CPU exactly!) ===\nfloat computeBaseHeight(float x) {\n  // Frequencies\n  float f1 = 0.001;\n  float f2 = 0.005;\n  float f3 = 0.02;\n\n  // Amplitudes\n  float a1 = 300.0;\n  float a2 = 80.0;\n  float a3 = 20.0;\n\n  // Noise from sine waves\n  float terrainNoise =\n    sin((x + u_seed) * f1) * a1 +\n    sin((x + u_seed * 2.0) * f2) * a2 +\n    sin((x + u_seed * 3.0) * f3) * a3;\n\n  // Mountain features\n  float mountain = sin((x / u_worldSize.x) * 3.14159265 * 5.0 + u_seed) * -200.0;\n\n  float y = u_worldSize.y / 1.6 + terrainNoise + mountain;\n\n  // Clamp to ensure playable area\n  return clamp(y, 200.0, u_worldSize.y - 100.0);\n}\n\n// === Tunnel check ===\nbool isInTunnel(float px, float py, float sx, float sy, float nx, float ny, float radius, float length) {\n  float dx = nx * length;\n  float dy = ny * length;\n  float len2 = length * length;\n  if (len2 == 0.0) {\n    float dist2 = (px - sx) * (px - sx) + (py - sy) * (py - sy);\n    return dist2 <= radius * radius;\n  }\n  float t = clamp(((px - sx) * dx + (py - sy) * dy) / len2, 0.0, 1.0);\n  float closestX = sx + t * dx;\n  float closestY = sy + t * dy;\n  float dist2 = (px - closestX) * (px - closestX) + (py - closestY) * (py - closestY);\n  return dist2 <= radius * radius;\n}\n\n// === Crater check ===\nbool isInCrater(float worldX, float worldY, float modX, float modY, float modRadius, out float edgeDist) {\n  float dx = worldX - modX;\n  float dy = worldY - modY;\n  float dist = sqrt(dx * dx + dy * dy);\n  float angle = atan(dy, dx);\n  vec2 noisePos = vec2(modX + modY * 0.37, angle * 3.0 + modRadius * 0.1);\n  float edgeNoise = fbm(noisePos * 0.5) * 0.3 + 0.85;\n  float detailNoise = noise(vec2(angle * 8.0 + modX, modY * 0.1)) * 0.15;\n  float irregularRadius = modRadius * (edgeNoise + detailNoise);\n  edgeDist = dist - irregularRadius;\n  return dist <= irregularRadius;\n}\n\n// === Star field ===\nfloat star(vec2 uv, float layer) {\n  vec2 id = floor(uv);\n  vec2 gridUV = fract(uv);\n  float starLight = 0.0;\n  for (int y = -1; y <= 1; y++) {\n    for (int x = -1; x <= 1; x++) {\n      vec2 neighbor = vec2(float(x), float(y));\n      vec2 cellId = id + neighbor;\n      vec2 starPos = neighbor + vec2(hash(cellId + layer * 17.0), hash(cellId + layer * 31.0 + 50.0)) * 0.8 + 0.1;\n      float starPresent = step(0.92, hash(cellId + layer * 47.0));\n      if (starPresent < 0.5) continue;\n      float d = length(gridUV - starPos);\n      // Increased size to match CPU (0.5 to 2.5px)\n      // UV is screenPos/40.0, so 0.02 is 0.8px, 0.06 is 2.4px\n      float size = hash(cellId + layer * 63.0) * 0.04 + 0.012;\n      float glow = exp(-d * d / (size * size * 2.0));\n      float brightness = hash(cellId + layer * 79.0) * 0.7 + 0.3;\n      starLight += glow * brightness;\n    }\n  }\n  return clamp(starLight, 0.0, 1.0);\n}\n\n// === Procedural Clouds ===\nfloat cloudNoise(vec2 uv) {\n  float n = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n  for (int i = 0; i < 5; i++) {\n    n += amplitude * noise(uv * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return n;\n}\n\nvec4 getCloud(vec2 uv, float layer) {\n  // Cloud shape using layered noise\n  float cloudShape = cloudNoise(uv * 0.15 + layer * 50.0);\n  cloudShape += cloudNoise(uv * 0.4 + layer * 30.0) * 0.4;\n  cloudShape += cloudNoise(uv * 0.8 + layer * 10.0) * 0.2;\n\n  // Higher threshold = fewer, more distinct clouds\n  float cloudDensity = smoothstep(0.55, 0.75, cloudShape);\n\n  // Only render where there's actually a cloud (sparse)\n  if (cloudDensity < 0.01) {\n    return vec4(0.0);\n  }\n\n  // Cloud brightness variation\n  float brightness = 0.85 + cloudNoise(uv * 2.0 + layer * 5.0) * 0.15;\n\n  // Fluffy edges for defined cloud shapes\n  float edge = smoothstep(0.5, 0.7, cloudShape);\n  float alpha = cloudDensity * edge * 0.7;\n\n  vec3 cloudColor = vec3(brightness);\n  return vec4(cloudColor, alpha);\n}\n\n// === Weather Particles (snow, sand) ===\nfloat weatherParticle(vec2 screenPos, vec2 cameraPos, float particleSize, float fallSpeed, float drift) {\n  // Use a mix of screen and camera position for parallax effect\n  vec2 uv = (screenPos + vec2(cameraPos.x, -cameraPos.y) * 0.4 * u_zoom) / particleSize;\n  vec2 cellId = floor(uv);\n  vec2 cellUV = fract(uv);\n\n  float particles = 0.0;\n\n  for (int dy = -1; dy <= 1; dy++) {\n    for (int dx = -1; dx <= 1; dx++) {\n      vec2 neighbor = vec2(float(dx), float(dy));\n      vec2 id = cellId + neighbor;\n\n      // Random offset within cell\n      float randX = hash1D(id.x * 0.1, id.y * 0.2);\n      float randY = hash1D(id.y * 0.3, id.x * 0.4);\n      float randPresent = hash1D(id.x, id.y + 200.0);\n\n      if (randPresent < 0.25) {\n        vec2 particlePos = neighbor + vec2(randX * 0.8 + 0.1, randY * 0.8 + 0.1);\n\n        // Slowed down falling motion (0.0006 instead of 0.001)\n        float timeScale = u_time * 0.0006;\n        float progress = fract(randY * 10.0 - timeScale * fallSpeed * 10.0);\n        particlePos.y += progress;\n        particlePos.x += sin(u_time * 0.0005 * drift * 5.0 + randX * 6.28) * 0.4;\n\n        // Vertical fade to avoid "jumping" or "jitter" at cell boundaries\n        float verticalFade = smoothstep(0.0, 0.2, progress) * smoothstep(1.0, 0.7, progress);\n\n        float d = length(cellUV - particlePos);\n        float size = 0.04 + randX * 0.08;\n        particles += smoothstep(size, size * 0.5, d) * verticalFade;\n      }\n    }\n  }\n\n  return clamp(particles, 0.0, 1.0);\n}\n\n// === Biome color palettes ===\nvec3 getPlainsColor(float depth, float worldY, float baseH) {\n  vec3 dirtColor = vec3(0.278, 0.333, 0.412);\n  vec3 deepColor = vec3(0.059, 0.090, 0.165);\n  vec3 grassColor = vec3(0.133, 0.773, 0.369);\n  vec3 grassLight = vec3(0.525, 0.937, 0.675);\n\n  vec3 color = mix(dirtColor, deepColor, worldY / u_worldSize.y);\n  if (depth >= 0.0 && depth < 15.0) {\n    color = depth < 4.0 ? grassLight : grassColor;\n  }\n  return color;\n}\n\nvec3 getMountainsColor(float depth, float worldY, float baseH) {\n  vec3 rockDark = vec3(0.25, 0.25, 0.28);\n  vec3 rockLight = vec3(0.45, 0.45, 0.5);\n  vec3 snowColor = vec3(0.95, 0.97, 1.0);\n  vec3 snowShadow = vec3(0.75, 0.82, 0.9);\n\n  vec3 color = mix(rockLight, rockDark, worldY / u_worldSize.y);\n\n  // Snow on high peaks\n  if (baseH < SNOW_THRESHOLD) {\n    float snowBlend = smoothstep(SNOW_THRESHOLD, SNOW_THRESHOLD - 50.0, baseH);\n    vec3 snow = depth < 5.0 ? snowColor : snowShadow;\n    color = mix(color, snow, snowBlend);\n  }\n  return color;\n}\n\nvec3 getValleyColor(float depth, float worldY, float baseH) {\n  vec3 grassDark = vec3(0.08, 0.45, 0.22);\n  vec3 grassLight = vec3(0.15, 0.65, 0.35);\n  vec3 dirtColor = vec3(0.35, 0.25, 0.18);\n\n  vec3 color = mix(grassLight, dirtColor, worldY / u_worldSize.y);\n  if (depth >= 0.0 && depth < 12.0) {\n    color = depth < 3.0 ? grassLight : grassDark;\n  }\n  return color;\n}\n\nvec3 getDesertColor(float depth, float worldY, float baseH) {\n  vec3 sandLight = vec3(0.93, 0.85, 0.65);\n  vec3 sandDark = vec3(0.75, 0.60, 0.40);\n  vec3 rockColor = vec3(0.55, 0.45, 0.35);\n\n  vec3 color = mix(sandLight, rockColor, worldY / u_worldSize.y);\n  if (depth >= 0.0 && depth < 8.0) {\n    color = depth < 3.0 ? sandLight : sandDark;\n  }\n  return color;\n}\n\nvec3 getTundraColor(float depth, float worldY, float baseH) {\n  vec3 snowWhite = vec3(0.92, 0.95, 0.98);\n  vec3 iceBluePale = vec3(0.80, 0.88, 0.95);\n  vec3 iceBlue = vec3(0.55, 0.70, 0.85);\n  vec3 frozenGround = vec3(0.45, 0.50, 0.55);\n\n  vec3 color = mix(iceBluePale, frozenGround, worldY / u_worldSize.y);\n  if (depth >= 0.0 && depth < 10.0) {\n    color = depth < 3.0 ? snowWhite : iceBlue;\n  }\n  return color;\n}\n\n// === Terrain Decorations (Trees, Rocks) ===\nvec4 getDecorationColor(float worldX, float worldY, float baseH, int biomeIdx) {\n  float dy_ground = worldY - baseH;\n\n  // Grid-based Large Decorations\n  float decoGrid = 200.0;\n  float cellId = floor(worldX / decoGrid);\n  float cellRand = hash1D(cellId, u_seed * 1.5);\n\n  if (cellRand > 0.4) {\n    float decoX = (cellId + 0.3 + cellRand * 0.4) * decoGrid;\n    float decoH = computeBaseHeight(decoX);\n    float dx = worldX - decoX;\n    float dy = worldY - decoH;\n\n    // Trees (Plains/Valley/Tundra)\n    if (biomeIdx == 0 || biomeIdx == 2 || biomeIdx == 4) {\n      float trunkW = 4.0;\n      float trunkH = 40.0 + cellRand * 30.0;\n      if (biomeIdx == 4) trunkH *= 1.5; // Increased from 0.7 to 1.5\n\n      // Trunk\n      if (abs(dx) < trunkW && dy < 0.0 && dy > -trunkH) {\n        return vec4(0.25, 0.15, 0.08, 1.0);\n      }\n\n      // Foliage\n      float leafY = dy + trunkH * 0.9;\n      if (biomeIdx == 4) { // Pine shape for Tundra\n        float pineW = (dy + trunkH) * 0.5; // Increased width factor to 0.5\n        if (abs(dx) < pineW && dy < 0.0 && dy > -trunkH * 1.1) {\n          float noiseVal = noise(vec2(worldX * 0.2, worldY * 0.2));\n          vec3 leafColor = mix(vec3(0.1, 0.2, 0.15), vec3(0.8, 0.85, 0.9), step(0.6, noiseVal));\n          return vec4(leafColor, 1.0);\n        }\n      } else { // Fluffy trees for Plains/Valley\n        float dLeaf = length(vec2(dx, leafY));\n        float leafRadius = 30.0 + cellRand * 20.0;\n        float leafNoise = noise(vec2(worldX * 0.08, worldY * 0.08 + cellId)) * 12.0;\n        if (dLeaf < leafRadius + leafNoise) {\n          vec3 leafBase = (biomeIdx == 2) ? vec3(0.05, 0.3, 0.1) : vec3(0.15, 0.5, 0.1);\n          vec3 leafTop = leafBase + 0.2;\n          vec3 leafColor = mix(leafBase, leafTop, clamp(-dy/trunkH, 0.0, 1.0));\n          return vec4(leafColor, 1.0);\n        }\n      }\n    }\n    // Large Boulders (Mountains/Desert)\n    else {\n      float rockSize = 15.0 + cellRand * 15.0; // Smaller rocks (was 25+25)\n      float dRock = length(vec2(dx, dy + rockSize * 0.4));\n\n      // Much more irregular rock shape (multiple layers of noise)\n      float rockNoise = noise(vec2(worldX * 0.2, worldY * 0.2 + cellId)) * (rockSize * 0.5);\n      rockNoise += noise(vec2(worldX * 0.5, worldY * 0.5 - cellId)) * (rockSize * 0.2);\n\n      if (dRock < rockSize + rockNoise) {\n        vec3 rockBase = (biomeIdx == 3) ? vec3(0.7, 0.55, 0.35) : vec3(0.4, 0.4, 0.45);\n        vec3 rockHighlight = rockBase + 0.15;\n        float shading = dot(normalize(vec2(dx, dy)), normalize(vec2(-1.0, -1.0)));\n        vec3 rockColor = mix(rockBase, rockHighlight, shading * 0.5 + 0.5);\n        return vec4(rockColor, 1.0);\n      }\n    }\n  }\n\n  // Small Surface Details (Grass/Pebbles) - only rendered if solid is true in main\n  return vec4(0.0);\n}\n\n// Get biome color with smooth blending at boundaries\nvec3 getBiomeColorBlended(float worldX, float worldY, float baseH) {\n  float depth = worldY - baseH;\n\n  // BIOME_SCALE is very small, so we use a reasonable transition width\n  float blendWidth = 500.0;\n\n  // Find current and neighbor biomes for blending\n  int currentBiome = getBiomeIndex(worldX);\n\n  // Check transitions at chunk boundaries (every 256px) or continuous?\n  // CPU uses CHUNK_SIZE/2 offset for getBiomeIndex sampling.\n  // We want to blend between the zones.\n\n  float chunkX = floor(worldX / 256.0) * 256.0 + 128.0;\n  float nextChunkX = chunkX + 256.0;\n  float prevChunkX = chunkX - 256.0;\n\n  int nextBiome = getBiomeIndex(nextChunkX);\n  int prevBiome = getBiomeIndex(prevChunkX);\n\n  vec3 color;\n  if (currentBiome == 0) color = getPlainsColor(depth, worldY, baseH);\n  else if (currentBiome == 1) color = getMountainsColor(depth, worldY, baseH);\n  else if (currentBiome == 2) color = getValleyColor(depth, worldY, baseH);\n  else if (currentBiome == 3) color = getDesertColor(depth, worldY, baseH);\n  else color = getTundraColor(depth, worldY, baseH);\n\n  // Smoothly blend with neighbors\n  float distToNext = nextChunkX - 128.0 - worldX;\n  float distToPrev = worldX - (prevChunkX + 128.0);\n\n  if (distToNext < 128.0 && nextBiome != currentBiome) {\n    float t = smoothstep(128.0, 0.0, distToNext);\n    vec3 nextColor;\n    if (nextBiome == 0) nextColor = getPlainsColor(depth, worldY, baseH);\n    else if (nextBiome == 1) nextColor = getMountainsColor(depth, worldY, baseH);\n    else if (nextBiome == 2) nextColor = getValleyColor(depth, worldY, baseH);\n    else if (nextBiome == 3) nextColor = getDesertColor(depth, worldY, baseH);\n    else nextColor = getTundraColor(depth, worldY, baseH);\n    color = mix(color, nextColor, t * 0.5);\n  }\n\n  if (distToPrev < 128.0 && prevBiome != currentBiome) {\n    float t = smoothstep(128.0, 0.0, distToPrev);\n    vec3 prevColor;\n    if (prevBiome == 0) prevColor = getPlainsColor(depth, worldY, baseH);\n    else if (prevBiome == 1) prevColor = getMountainsColor(depth, worldY, baseH);\n    else if (prevBiome == 2) prevColor = getValleyColor(depth, worldY, baseH);\n    else if (prevBiome == 3) prevColor = getDesertColor(depth, worldY, baseH);\n    else prevColor = getTundraColor(depth, worldY, baseH);\n    color = mix(color, prevColor, t * 0.5);\n  }\n\n  return color;\n}\n\nvoid main() {\n  vec2 screenPos = gl_FragCoord.xy;\n  float worldX = u_cameraPos.x + screenPos.x / u_zoom;\n  float worldY = u_cameraPos.y + (u_viewSize.y - screenPos.y) / u_zoom;\n\n  float baseH = computeBaseHeight(worldX);\n  bool solid = worldY >= baseH;\n  int biomeIdx = getBiomeIndex(worldX);\n\n  float nearestCraterDist = 1000.0;\n  float nearestCraterRadius = 0.0;\n\n  // Track terrain modification masking\n  bool masked = false;\n\n  // Apply modifications\n  for (int i = 0; i < u_modCount; i++) {\n    vec4 data0 = texelFetch(u_modTexture, ivec2(i, 0), 0);\n    float modType = data0.r;\n    float modX = data0.g;\n    float modY = data0.b;\n    float modRadius = data0.a;\n\n    if (modType < 0.5) {\n      float edgeDist;\n      if (isInCrater(worldX, worldY, modX, modY, modRadius, edgeDist)) {\n        solid = false;\n        masked = true;\n      }\n      float dx = worldX - modX;\n      float dy = worldY - modY;\n      float dist = sqrt(dx * dx + dy * dy);\n      if (dist < nearestCraterDist) {\n        nearestCraterDist = dist;\n        nearestCraterRadius = modRadius;\n      }\n    } else if (modType < 1.5) {\n      float dx = worldX - modX;\n      float dy = worldY - modY;\n      if (dx * dx + dy * dy <= modRadius * modRadius) solid = true;\n    } else {\n      vec4 data1 = texelFetch(u_modTexture, ivec2(i, 1), 0);\n      if (isInTunnel(worldX, worldY, modX, modY, data1.r, data1.g, modRadius, data1.b)) {\n        solid = false;\n        masked = true;\n      }\n    }\n  }\n\n  // === New: Popup Decorations check (rendered above terrain, hidden by craters) ===\n  if (!masked) {\n    vec4 deco = getDecorationColor(worldX, worldY, baseH, biomeIdx);\n    if (deco.a > 0.0) {\n      fragColor = vec4(deco.rgb, 1.0);\n      return;\n    }\n  }\n\n  // === Sky rendering (for non-solid pixels) ===\n  if (!solid) {\n    float skyT = screenPos.y / u_viewSize.y;\n    vec3 skyTop = vec3(0.008, 0.024, 0.09);\n    vec3 skyBot = vec3(0.09, 0.145, 0.33);\n    vec3 skyColor = mix(skyBot, skyTop, skyT);\n\n    // Stars\n    vec2 starUV = (screenPos + vec2(u_cameraPos.x, -u_cameraPos.y) * 0.05) / 40.0;\n    float stars = star(starUV, 1.0) * 0.8 + star(starUV * 1.5 + 100.0, 2.0) * 0.5 + star(starUV * 2.0 + 200.0, 3.0) * 0.3;\n    skyColor += vec3(stars);\n\n    // === Weather particles based on biome ===\n    int skyBiomeIdx = getBiomeIndex(worldX);\n\n    // Tundra - falling snow\n    if (skyBiomeIdx == 4) {\n      float snow = weatherParticle(screenPos, u_cameraPos, 20.0, 0.6, 0.2);\n      skyColor = mix(skyColor, vec3(1.0), snow * 0.8);\n    }\n    // Desert - blowing sand/dust\n    else if (skyBiomeIdx == 3) {\n      float sand = weatherParticle(screenPos, u_cameraPos, 25.0, 0.3, 0.7);\n      skyColor = mix(skyColor, vec3(0.9, 0.8, 0.6), sand * 0.3);\n    }\n\n    fragColor = vec4(skyColor, 1.0);\n    return;\n  }\n\n  // === Terrain color with biome blending ===\n  vec3 color = getBiomeColorBlended(worldX, worldY, baseH);\n\n  // Texture noise\n  float texNoise = fract(sin(dot(vec2(worldX, worldY), vec2(12.9898, 78.233))) * 43758.5453);\n  color += (texNoise - 0.5) * 0.04;\n\n  // === Surface Decorations (Grass) ===\n  float depth = worldY - baseH;\n  if (depth >= 0.0 && depth < 25.0) {\n    float grassPattern = noise(vec2(worldX * 0.3, worldY * 1.5 + u_seed));\n    float grassHeight = noise(vec2(worldX * 0.2 + u_seed, 0.0)) * 15.0 + 8.0;\n    float grassBlade = smoothstep(grassHeight, 0.0, depth) * step(0.35, grassPattern);\n\n    if (grassBlade > 0.0) {\n      vec3 gColor;\n      if (biomeIdx == 0) gColor = mix(vec3(0.2, 0.7, 0.2), vec3(0.4, 0.9, 0.3), grassPattern);\n      else if (biomeIdx == 1) gColor = mix(vec3(0.3, 0.4, 0.3), vec3(0.4, 0.5, 0.4), grassPattern);\n      else if (biomeIdx == 2) gColor = mix(vec3(0.1, 0.5, 0.2), vec3(0.2, 0.7, 0.3), grassPattern);\n      else if (biomeIdx == 3) gColor = mix(vec3(0.6, 0.5, 0.3), vec3(0.4, 0.6, 0.2), grassPattern);\n      else gColor = mix(vec3(0.8, 0.9, 1.0), vec3(0.6, 0.7, 0.8), grassPattern);\n      color = mix(color, gColor, grassBlade * 0.9);\n    }\n  }\n\n  // Scorch marks\n  if (nearestCraterRadius > 0.0) {\n    float scorchOuter = nearestCraterRadius * 1.4;\n    if (nearestCraterDist <= scorchOuter) {\n      float scorchT = 1.0 - (nearestCraterDist - nearestCraterRadius * 0.7) / (scorchOuter - nearestCraterRadius * 0.7);\n      scorchT = clamp(scorchT, 0.0, 1.0);\n      float scorchNoise = noise(vec2(worldX * 0.2, worldY * 0.2)) * 0.3;\n      scorchT = clamp(scorchT + scorchNoise - 0.15, 0.0, 1.0);\n      vec3 scorchColor = mix(vec3(0.15, 0.1, 0.05), vec3(0.02, 0.01, 0.01), scorchT * 0.5);\n      color = mix(color, scorchColor, scorchT * 0.7);\n      if (nearestCraterDist <= nearestCraterRadius * 1.1) {\n        float innerT = 1.0 - (nearestCraterDist / (nearestCraterRadius * 1.1));\n        color = mix(color, vec3(0.0), innerT * 0.6);\n      }\n    }\n  }\n\n  fragColor = vec4(color, 1.0);\n}\n`,C=4096;class _{gl=null;program=null;vao=null;modTexture=null;uniforms={seed:null,cameraPos:null,viewSize:null,zoom:null,worldSize:null,modTexture:null,modCount:null,time:null};modTextureData;lastModCount=0;isInitialized=!1;constructor(){this.modTextureData=new Float32Array(32768)}init(e){const t=e.getContext("webgl2",{alpha:!0,antialias:!1,premultipliedAlpha:!1});if(!t)return console.warn("WebGL2 not available, falling back to CPU rendering"),!1;this.gl=t;const n=this.compileShader(t,t.VERTEX_SHADER,"#version 300 es\nprecision highp float;\n\n// Fullscreen quad vertices (2 triangles)\nconst vec2 positions[6] = vec2[](\n  vec2(-1.0, -1.0),\n  vec2( 1.0, -1.0),\n  vec2( 1.0,  1.0),\n  vec2(-1.0, -1.0),\n  vec2( 1.0,  1.0),\n  vec2(-1.0,  1.0)\n);\n\nvoid main() {\n  gl_Position = vec4(positions[gl_VertexID], 0.0, 1.0);\n}\n"),i=this.compileShader(t,t.FRAGMENT_SHADER,w);if(!n||!i)return console.error("Failed to compile shaders"),!1;const a=t.createProgram();return!!a&&(t.attachShader(a,n),t.attachShader(a,i),t.linkProgram(a),t.getProgramParameter(a,t.LINK_STATUS)?(this.program=a,this.uniforms={seed:t.getUniformLocation(a,"u_seed"),cameraPos:t.getUniformLocation(a,"u_cameraPos"),viewSize:t.getUniformLocation(a,"u_viewSize"),zoom:t.getUniformLocation(a,"u_zoom"),worldSize:t.getUniformLocation(a,"u_worldSize"),modTexture:t.getUniformLocation(a,"u_modTexture"),modCount:t.getUniformLocation(a,"u_modCount"),time:t.getUniformLocation(a,"u_time")},this.vao=t.createVertexArray(),this.modTexture=t.createTexture(),t.bindTexture(t.TEXTURE_2D,this.modTexture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),this.isInitialized=!0,!0):(console.error("Program link error:",t.getProgramInfoLog(a)),!1))}resize(e,t){this.gl&&this.gl.viewport(0,0,e,t)}uploadModifications(e){if(!this.gl||!this.modTexture)return;const t=Math.min(e.length,C);this.lastModCount=t;for(let i=0;i<t;i++){const t=e[i],n=4*i;let a=0;"add"===t.type?a=1:"carve"===t.type&&(a=2),this.modTextureData[n+0]=a,this.modTextureData[n+1]=t.x,this.modTextureData[n+2]=t.y,this.modTextureData[n+3]=t.radius;const r=16384+n;this.modTextureData[r+0]=t._nx??0,this.modTextureData[r+1]=t._ny??0,this.modTextureData[r+2]=t.length??0,this.modTextureData[r+3]=0}const n=this.gl;n.bindTexture(n.TEXTURE_2D,this.modTexture),n.texImage2D(n.TEXTURE_2D,0,n.RGBA32F,C,2,0,n.RGBA,n.FLOAT,this.modTextureData)}render(e,i,a,r,o,s){const l=this.gl;l&&this.program&&this.vao&&(l.clearColor(0,0,0,0),l.clear(l.COLOR_BUFFER_BIT),l.useProgram(this.program),l.bindVertexArray(this.vao),l.uniform1f(this.uniforms.seed,e),l.uniform2f(this.uniforms.cameraPos,i,a),l.uniform2f(this.uniforms.viewSize,r,o),l.uniform1f(this.uniforms.zoom,s),l.uniform2f(this.uniforms.worldSize,t,n),l.uniform1i(this.uniforms.modCount,this.lastModCount),l.uniform1f(this.uniforms.time,performance.now()),l.activeTexture(l.TEXTURE0),l.bindTexture(l.TEXTURE_2D,this.modTexture),l.uniform1i(this.uniforms.modTexture,0),l.drawArrays(l.TRIANGLES,0,6))}isReady(){return this.isInitialized}dispose(){const e=this.gl;e&&(this.program&&e.deleteProgram(this.program),this.vao&&e.deleteVertexArray(this.vao),this.modTexture&&e.deleteTexture(this.modTexture),this.isInitialized=!1)}compileShader(e,t,n){const i=e.createShader(t);return i?(e.shaderSource(i,n),e.compileShader(i),e.getShaderParameter(i,e.COMPILE_STATUS)?i:(console.error(t===e.VERTEX_SHADER?"Vertex":"Fragment","shader error:",e.getShaderInfoLog(i)),e.deleteShader(i),null)):null}}class b{gl=null;program=null;vao=null;vbo=null;isInitialized=!1;uniforms={cameraPos:null,viewSize:null,zoom:null,worldSize:null};init(e){this.gl=e;const t=this.compileShader(e,e.VERTEX_SHADER,"#version 300 es\nprecision highp float;\n\nlayout(location = 0) in vec2 a_pos;\nlayout(location = 4) in float a_life;\nlayout(location = 6) in float a_size;\nlayout(location = 7) in float a_type;\nlayout(location = 8) in vec3 a_color;\n\nuniform vec2 u_cameraPos;\nuniform vec2 u_viewSize;\nuniform float u_zoom;\nuniform vec2 u_worldSize;\n\nout float v_life;\nout float v_type;\nout vec3 v_color;\n\nvoid main() {\n  // World to screen transformation\n  vec2 screenPos = (a_pos - u_cameraPos) * u_zoom;\n\n  // Convert to clip space\n  vec2 clipSpace = (screenPos / u_viewSize) * 2.0 - 1.0;\n  gl_Position = vec4(clipSpace.x, -clipSpace.y, 0.0, 1.0);\n\n  gl_PointSize = a_size * u_zoom;\n  v_life = a_life;\n  v_type = a_type;\n  v_color = a_color;\n}\n"),n=this.compileShader(e,e.FRAGMENT_SHADER,"#version 300 es\nprecision highp float;\n\nin float v_life;\nin float v_type;\nin vec3 v_color;\n\nout vec4 fragColor;\n\nvoid main() {\n  float dist = length(gl_PointCoord - 0.5);\n  if (dist > 0.5) discard;\n\n  // Smooth edges\n  float alpha = 1.0 - smoothstep(0.4, 0.5, dist);\n  alpha *= v_life;\n\n  // Different styles based on type\n  if (v_type > 0.5) { // fire, spark, glow\n    // Brighter center\n    float center = 1.0 - smoothstep(0.0, 0.3, dist);\n    vec3 col = mix(v_color, vec3(1.0), center * 0.5);\n    fragColor = vec4(col, alpha);\n  } else { // smoke\n    fragColor = vec4(v_color, alpha * 0.8);\n  }\n}\n");if(!t||!n)return!1;const i=e.createProgram();if(!i)return!1;if(e.attachShader(i,t),e.attachShader(i,n),e.linkProgram(i),!e.getProgramParameter(i,e.LINK_STATUS))return console.error("Particle program link error:",e.getProgramInfoLog(i)),!1;this.program=i,this.uniforms={cameraPos:e.getUniformLocation(i,"u_cameraPos"),viewSize:e.getUniformLocation(i,"u_viewSize"),zoom:e.getUniformLocation(i,"u_zoom"),worldSize:e.getUniformLocation(i,"u_worldSize")},this.vao=e.createVertexArray(),this.vbo=e.createBuffer(),e.bindVertexArray(this.vao),e.bindBuffer(e.ARRAY_BUFFER,this.vbo);const a=4*r;return e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,a,0),e.enableVertexAttribArray(4),e.vertexAttribPointer(4,1,e.FLOAT,!1,a,16),e.enableVertexAttribArray(6),e.vertexAttribPointer(6,1,e.FLOAT,!1,a,24),e.enableVertexAttribArray(7),e.vertexAttribPointer(7,1,e.FLOAT,!1,a,28),e.enableVertexAttribArray(8),e.vertexAttribPointer(8,3,e.FLOAT,!1,a,32),this.isInitialized=!0,!0}render(e,i,a,o,s,l,h){const d=this.gl;d&&this.program&&this.vao&&0!==i&&(d.useProgram(this.program),d.bindVertexArray(this.vao),d.uniform2f(this.uniforms.cameraPos,a,o),d.uniform2f(this.uniforms.viewSize,s,l),d.uniform1f(this.uniforms.zoom,h),d.uniform2f(this.uniforms.worldSize,t,n),d.bindBuffer(d.ARRAY_BUFFER,this.vbo),d.bufferData(d.ARRAY_BUFFER,e.subarray(0,i*r),d.DYNAMIC_DRAW),d.enable(d.BLEND),d.blendFunc(d.SRC_ALPHA,d.ONE_MINUS_SRC_ALPHA),d.drawArrays(d.POINTS,0,i))}isReady(){return this.isInitialized}compileShader(e,t,n){const i=e.createShader(t);return i?(e.shaderSource(i,n),e.compileShader(i),e.getShaderParameter(i,e.COMPILE_STATUS)?i:(console.error(e.getShaderInfoLog(i)),e.deleteShader(i),null)):null}}class P extends e{terrainMap=null;terrainRenderer=null;terrainShaderRenderer=null;lastSyncedModCount=0;_projectiles=[];_particleData=new Float32Array(o*r);_particleCount=0;_particleShaderRenderer=null;get projectiles(){return this._projectiles}get particleData(){return this._particleData}get particleCount(){return this._particleCount}botState={planned:!1,moveTimer:0,moveDir:0,aimTimer:0,targetWeapon:s.BASIC,targetAngle:0,targetPower:0};getInitState(){return{phase:l.WAITING,tanks:[],currentTurnIndex:0,wind:0,winner:null,turnTimeEnd:0,players:this.players.map(e=>({id:e.id||null,username:e.username||null,tankId:null})),terrainSeed:Math.round(1e4*Math.random()),terrainMods:[],isSimulating:!1,isExploration:!1}}initTerrain(){this.terrainMap&&this.terrainMap.getSeed()===this.state.terrainSeed||(this.terrainMap=new S(this.state.terrainSeed),this.terrainRenderer=new I,this.lastSyncedModCount=0),this.syncTerrain()}onStateUpdate(e){super.onStateUpdate(e),this.syncTerrain()}onSocketGameState(e){super.onSocketGameState(e),this.initTerrain()}syncTerrain(){if(!this.terrainMap)return;const e=this.state.terrainMods.length;if(e===this.lastSyncedModCount)return;e<this.lastSyncedModCount&&(this.terrainMap.reset(this.state.terrainSeed),this.terrainRenderer&&this.terrainRenderer.clearCache(),this.lastSyncedModCount=0);const t=this.state.terrainMods.slice(this.lastSyncedModCount);if(t.length>0){if(this.terrainMap.applyModifications(t,!1),this.terrainRenderer)for(const e of t){const t="destroy"===e.type?e.radius*(h[s.BASIC].terrainDamageMultiplier||1.2):e.radius;"carve"===e.type&&void 0!==e.vx&&void 0!==e.vy?this.terrainRenderer.invalidateTunnel(e.x,e.y,e.vx,e.vy,e.radius,e.length||100):this.terrainRenderer.invalidateArea(e.x,e.y,t)}this.terrainShaderRenderer&&this.terrainShaderRenderer.uploadModifications(this.state.terrainMods),this.lastSyncedModCount=e}}checkSolid(e,t){return!!this.terrainMap&&this.terrainMap.isSolid(e,t)}getTerrainHeight(e){return this.terrainMap?this.terrainMap.getTerrainHeight(e):n+100}getTerrainMap(){return this.terrainMap}getTerrainRenderer(){return this.terrainRenderer}getTerrainShaderRenderer(){return this.terrainShaderRenderer}initShaderRenderer(e){this.terrainShaderRenderer||(this.terrainShaderRenderer=new _);const t=this.terrainShaderRenderer.init(e);t&&this.terrainMap&&this.terrainShaderRenderer.uploadModifications(this.state.terrainMods);const n=e.getContext("webgl2");return n&&(this._particleShaderRenderer||(this._particleShaderRenderer=new b),this._particleShaderRenderer.init(n)),t}getParticleShaderRenderer(){return this._particleShaderRenderer}seededRandom(e){const t=1e4*Math.sin(e);return t-Math.floor(t)}onSocketGameAction(e){const t=e.action;switch(console.log("onSocketGameAction",e),t.type){case"FIRE_SHOT":this.fireTank(t.shot);break;case"COMMIT_ANGLE":this.handleCommitAngle(t.angle,t.playerId);break;case"COMMIT_POWER":this.handleCommitPower(t.power,t.playerId);break;case"SELECT_WEAPON":this.handleSelectWeapon(t.weapon,t.playerId);break;case"MOVE_START":this.handleMoveStart(t.direction,t.x,t.playerId);break;case"MOVE_STOP":this.handleMoveStop(t.x,t.y,t.fuel,t.playerId);break;case"REGENERATE_MAP":this.handleRegenerateMap(t.seed);break;default:if(!this.isHost)return;switch(t.type){case"FIRE":this.handleFire(t.playerId);break;case"START_GAME":this.handleStartGame();break;case"RESET_GAME":this.reset();break;case"ADD_BOT":this.addBot();break;case"REMOVE_BOT":this.removeBot();break;case"START_EXPLORATION":this.handleStartExploration()}}}handleCommitAngle(e,t){const n=this.getTankByPlayerId(t);if(!n)return;if(!this.isPlayerTurn(t))return;if(this.state.phase!==l.AIMING)return;n.angle=Math.max(0,Math.min(180,e));const i=this._tankSimulations.get(n.id);i&&(i.angle=n.angle)}handleCommitPower(e,t){const n=this.getTankByPlayerId(t);n&&this.isPlayerTurn(t)&&this.state.phase===l.AIMING&&(n.power=Math.max(0,Math.min(100,e)))}handleSelectWeapon(e,t){const n=this.getTankByPlayerId(t);n&&this.isPlayerTurn(t)&&this.state.phase===l.AIMING&&(n.weapon=e)}handleMoveStart(e,t,n){const i=this.getTankByPlayerId(n);i&&this.isPlayerTurn(n)&&this.state.phase===l.AIMING&&(i.isMoving=!0,i.moveDir=e)}handleMoveStop(e,t,n,i){const a=this.getTankByPlayerId(i);a&&this.isPlayerTurn(i)&&this.state.phase===l.AIMING&&(a.isMoving=!1,a.moveDir=void 0,a.x=e,a.y=t,a.fuel=n,this._tankSimulations.delete(a.id))}handleFire(e){if(!this.isHost)return;if(this.state.phase!==l.AIMING)return;if(!this.isPlayerTurn(e))return;const t=this.getTankByPlayerId(e);if(!t)return;const n={tankId:t.id,x:t.x,y:t.y,angle:t.angle,power:t.power,weapon:t.weapon,wind:this.state.wind,seed:Math.random()};this.makeAction({type:"FIRE_SHOT",shot:n})}_tankSimulations=new Map;update(){if(this.syncTerrain(),!this.terrainMap)return;this.state.phase===l.AIMING&&this.state.tanks.forEach(e=>{if(e.isMoving&&e.moveDir){let t=this._tankSimulations.get(e.id);t||(t={x:e.x,y:e.y,fuel:e.fuel,angle:e.angle,health:e.health,falling:!1},this._tankSimulations.set(e.id,t));const n={...e,...t},i=this.calculateTankMovement(n,e.moveDir);i?(t.x=i.x,t.y=i.y,t.fuel=i.fuel):(e.playerId===this.userId&&this.moveStop(),e.isMoving=!1,e.moveDir=void 0,this._tankSimulations.delete(e.id))}else this._tankSimulations.has(e.id)&&this._tankSimulations.delete(e.id)});const e=this.updateTankPhysics(),t=this.updateProjectilePhysics(),n=this.updateParticlePhysics();this.checkPhaseTransitions(e,t,n)&&this.state.isSimulating&&this.onSimulationEnd()}getVisualTank(e){const t=this._tankSimulations.get(e.id);return t?{...e,...t}:e}gravityTank(e,t,i){const a={x:e,y:t,health:i,moving:!1};if(a.health<=0)return a;if(this.checkSolid(a.x,a.y+1))for(;this.checkSolid(a.x,a.y);)a.y--,a.moving=!0;else a.y+=3,a.moving=!0,a.y>n&&(a.health=0);return a}calculateTankMovement(e,n){if(!this.state.isExploration&&e.fuel<=0)return null;if(!this.terrainMap)return null;let{x:i,y:a,fuel:r,angle:o}=e;const s=Math.max(15,Math.min(t-15,i+n*g));if(this.checkSolid(s,a)){let e=!1;for(let t=1;t<=5;t++)if(!this.checkSolid(s,a-t)){i=s,a-=t,e=!0;break}e&&(this.state.isExploration||(r-=d))}else{i=s,this.state.isExploration||(r-=d);for(let e=1;e<=5;e++)if(this.checkSolid(i,a+e)){a+=e-1;break}}return{x:i,y:a,fuel:Math.max(0,r),angle:o}}fireTank(e){this.state.phase=l.FIRING,this.state.isSimulating=!0;const t=e.angle*Math.PI/180,n=e.power/100*c,i=(i=0,a=0)=>{const r=t+i*Math.PI/180,o=e.x+30*Math.cos(r),l=e.y-10-30*Math.sin(r);return{id:(e.seed+a).toString(36),x:o,y:l,vx:Math.cos(r)*n,vy:-Math.sin(r)*n,radius:5,weapon:e.weapon,ownerId:e.tankId,active:!0,bounces:e.weapon===s.BOUNCY?3:void 0}},a=h[e.weapon],r=a.count,o=a.spread||0;for(let s=0;s<r;s++){let e=0;r>1&&(e=-(r-1)*o/2+s*o),this._projectiles.push(i(e,.001*s))}this.state.phase=l.PROJECTILE_MOVING}updateTankPhysics(){let e=!1;return this.state.tanks.forEach(t=>{if(t.health<=0)return void this._tankSimulations.delete(t.id);let n=this._tankSimulations.get(t.id);n||(n={x:t.x,y:t.y,fuel:t.fuel,angle:t.angle,health:t.health,falling:!1},this._tankSimulations.set(t.id,n)),n.falling||t.isMoving||(n.x=t.x,n.y=t.y,n.health=t.health);const{x:i,y:a,health:r,moving:o}=this.gravityTank(n.x,n.y,n.health);o?(n.x=i,n.y=a,n.health=r,n.falling=!0,e=!0):n.falling&&(n.falling=!1,t.x=n.x,t.y=n.y,t.health=n.health)}),e}updateProjectilePhysics(){let e=!1;return this._projectiles.forEach(i=>{if(i.active){if(e=!0,i.x+=i.vx,i.y+=i.vy,i.vy+=u,i.vx+=this.state.wind,i.weapon===s.METEOR_STRIKE)for(let e=0;e<3;e++)this.createTrailParticle(i);else Math.random()>.3&&this.createTrailParticle(i);if(!this.checkProjectileTankCollision(i))if(i.x<0||i.x>t||i.y>n)i.active=!1;else if(this.checkSolid(i.x,i.y))if(i.weapon===s.BOUNCY&&(i.bounces||0)>0){i.vy=.6*-i.vy,i.vx*=.8,i.bounces=(i.bounces||0)-1;let e=0;for(;this.checkSolid(i.x,i.y)&&e<10;)i.y-=2,e++;this.createParticles(i.x,i.y,5,f.spark,1)}else this.explode(i)}}),this._projectiles=this._projectiles.filter(e=>e.active),e}checkProjectileTankCollision(e){for(const t of this.state.tanks){if(t.health<=0)continue;if(t.id===e.ownerId&&Math.abs(e.x-t.x)<20&&Math.abs(e.y-t.y)<20)continue;const n=t.x-e.x,i=t.y-10-e.y;if(Math.sqrt(n*n+i*i)<15)return this.explode(e),!0}return!1}updateParticlePhysics(){if(0===this._particleCount)return!1;for(let e=0;e<this._particleCount;e++){const t=e*r;this._particleData[t+0]+=this._particleData[t+2],this._particleData[t+1]+=this._particleData[t+3],this._particleData[t+4]-=this._particleData[t+5];if(this._particleData[t+7]===f.smoke&&(this._particleData[t+3]-=.05,this._particleData[t+6]+=.1),this._particleData[t+4]<=0){if(this._particleCount>1){const e=(this._particleCount-1)*r;this._particleData.copyWithin(t,e,e+r)}this._particleCount--,e--}}return this._particleCount>0}checkPhaseTransitions(e,t,n){const i=this.state;return 0===this._projectiles.filter(e=>e.active).length&&i.phase===l.PROJECTILE_MOVING&&(i.phase=l.IMPACT,i.turnTimeEnd=Date.now()+1e3),i.phase===l.IMPACT&&i.turnTimeEnd<=Date.now()&&!e||!(e||t||n||i.tanks.some(e=>e.isMoving)||i.phase===l.IMPACT||i.phase===l.PROJECTILE_MOVING)}explode(e){const t=h[e.weapon]||h[s.BASIC];if(this.isHost)if(t.type===s.BUILDER)this.state.terrainMods.push({type:"add",x:Math.round(e.x),y:Math.round(e.y),radius:Math.round(t.radius)});else if(t.type===s.DRILL)this.state.terrainMods.push({type:"carve",x:Math.round(e.x),y:Math.round(e.y),vx:e.vx,vy:e.vy,radius:Math.round(t.radius),length:150});else if(t.type!==s.TELEPORT&&t.type!==s.AIRSTRIKE&&t.type!==s.HEAL){const n=t.radius*t.terrainDamageMultiplier;this.state.terrainMods.push({type:"destroy",x:Math.round(e.x),y:Math.round(e.y),radius:Math.round(n)})}this.syncTerrain(),this.createExplosionParticles(e.x,e.y,t),this.handleSpecialWeapons(e,t),this.isHost&&t.damage>0&&this.state.tanks.forEach(n=>{const i=n.x-e.x,a=n.y-10-e.y,r=Math.sqrt(i*i+a*a);if(r<t.radius+20){const i=Math.floor(t.damage*(1-r/(t.radius+50)));if(i>0)if(t.type===s.HEAL)n.health=Math.min(n.maxHealth,n.health+i);else if(t.type===s.VAMPIRE){n.health=Math.max(0,n.health-i);const t=this.state.tanks.find(t=>t.id===e.ownerId);t&&(t.health=Math.min(t.maxHealth,t.health+i))}else n.health=Math.max(0,n.health-i)}}),t.damage>0&&this.state.tanks.forEach(n=>{const i=n.x-e.x,a=n.y-10-e.y,r=Math.sqrt(i*i+a*a);if(r<t.radius+20){Math.floor(t.damage*(1-r/(t.radius+50)))>0&&(t.type===s.HEAL?this.createParticles(n.x,n.y-10,8,f.glow,1,"#4ade80"):this.createParticles(n.x,n.y-10,10,f.spark,2))}}),e.active=!1}handleSpecialWeapons(e,t){if(t.type===s.TELEPORT){if(!this.isHost)return;const n=this.state.tanks.find(t=>t.id===e.ownerId);if(n){let i=null,a=t.radius+15;for(const t of this.state.tanks){if(t.id===n.id||t.health<=0)continue;const r=Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-10-e.y,2));r<a&&(a=r,i=t)}if(i){const e=i.x,t=i.y;i.x=n.x,i.y=n.y,n.x=e,n.y=t}else{n.x=e.x,n.y=e.y;let t=0;for(;this.checkSolid(n.x,n.y)&&t<50;)n.y--,t++}}}if(t.type===s.AIRSTRIKE){const t=Number(e.id)||0;for(let n=0;n<8;n++){const i=t+.1*n,a=100*(this.seededRandom(i)-.5),r=200*-this.seededRandom(i+.05);this._projectiles.push({id:(t+1+.1*n).toString(),x:e.x+a,y:r,vx:0,vy:5+5*this.seededRandom(i+.07),radius:5,weapon:s.AIRSTRIKE_BOMB,ownerId:e.ownerId,active:!0})}}if(t.type===s.MIRV){const t=Number(e.id)||e.x;for(let n=0;n<5;n++){const i=t+.13*n,a=12*(this.seededRandom(i)-.5),r=-3-8*this.seededRandom(i+.05);this._projectiles.push({id:(t+n+100).toString(36),x:e.x,y:e.y-10,vx:a,vy:r,radius:5,weapon:s.MIRV_MINI,ownerId:e.ownerId,active:!0})}}t.type===s.METEOR&&this._projectiles.push({id:(Number(e.id)+1e3).toString(),x:e.x,y:-1e3,vx:.1*e.vx+10*this.state.wind,vy:6,radius:40,weapon:s.METEOR_STRIKE,ownerId:e.ownerId,active:!0})}createExplosionParticles(e,t,n){n.type===s.NUKE?(this.createParticles(e,t,100,f.smoke,3),this.createParticles(e,t,50,f.smoke,2),this.createParticles(e,t,30,f.glow,4,"#d946ef")):n.type===s.TELEPORT?(this.createParticles(e,t,30,f.glow,2,"#c084fc"),this.createParticles(e,t,20,f.spark,3,"#ffffff")):n.type===s.METEOR_STRIKE?(this.createParticles(e,t,150,f.fire,6,void 0,.3),this.createParticles(e,t,50,f.smoke,3,void 0,.3),this.createParticles(e,t,50,f.glow,8,"#ff4500",.4)):n.type===s.BUILDER?this.createParticles(e,t,20,f.smoke,1,"#64748b"):n.type===s.HEAL?(this.createParticles(e,t,20,f.glow,2,"#4ade80"),this.createParticles(e,t,15,f.spark,1.5,"#ffffff")):(this.createParticles(e,t,20,f.fire,1.5),this.createParticles(e,t,20,f.smoke,1))}createTrailParticle(e){const t={[s.NUKE]:"#d946ef",[s.DRILL]:"#94a3b8",[s.TELEPORT]:"#c084fc",[s.AIRSTRIKE]:"#ef4444",[s.AIRSTRIKE_BOMB]:"#ef4444",[s.BUILDER]:"#60a5fa",[s.HEAL]:"#4ade80",[s.METEOR_STRIKE]:"#fb923c"}[e.weapon];t?this.createParticles(e.x,e.y,1,f.glow,.3,t):this.createParticles(e.x,e.y,1,f.smoke,0,"rgba(255,255,255,0.5)",5)}createParticles(e,t,n,i,a=1,s,l=1){const h=Math.min(n,100);for(let d=0;d<h&&!(this._particleCount>=o);d++){const n=Math.random()*Math.PI*2,o=2*Math.random()*a;let h="#fff",d=.02,c=3*Math.random()+1,u=f.smoke,m=0;i===f.fire?(h=s||(Math.random()>.5?"#fbbf24":"#ef4444"),d=.04*l,c=6*Math.random()+4,u=f.fire,m=1):i===f.smoke?(h=s||"#64748b",d=.02*l,c=8*Math.random()+4,u=f.smoke):i===f.spark?(h=s||"#facc15",d=.08*l,c=2*Math.random()+1,u=f.spark,m=1):i===f.glow&&(h=s||"#22c55e",d=.05*l,c=5*Math.random()+2,u=f.glow,m=1);const p=parseInt(h.slice(1,3),16)/255||1,y=parseInt(h.slice(3,5),16)/255||1,g=parseInt(h.slice(5,7),16)/255||1,v=this._particleCount*r;this._particleData[v+0]=e,this._particleData[v+1]=t,this._particleData[v+2]=Math.cos(n)*o,this._particleData[v+3]=Math.sin(n)*o,this._particleData[v+4]=1,this._particleData[v+5]=d,this._particleData[v+6]=c,this._particleData[v+7]=u,this._particleData[v+8]=p,this._particleData[v+9]=y,this._particleData[v+10]=g,this._particleData[v+11]=m,this._particleCount++}}onSimulationEnd(){if(this.state.isSimulating){if(this.state.isSimulating=!1,!this.state.isExploration){const e=this.state.tanks.filter(e=>e.health>0);if(e.length<=1){if(this.state.phase=l.GAME_OVER,1===e.length){const t=e[0],n=this.state.players.find(e=>e.id===t.playerId);this.state.winner=n?.username||(t.isBot?"Bot":"Player")}else this.state.winner="Draw";return}}this.nextTurn(),this.checkBotTurn()}}nextTurn(){const e=this.state;if(e.isExploration)return e.phase=l.AIMING,void(e.turnTimeEnd=0);for(e.currentTurnIndex=(e.currentTurnIndex+1)%e.tanks.length;e.tanks[e.currentTurnIndex].health<=0;)e.currentTurnIndex=(e.currentTurnIndex+1)%e.tanks.length;e.tanks[e.currentTurnIndex].fuel=m,this.botState.planned=!1,e.phase=l.AIMING,e.wind=.05*Math.random()-.025}checkBotTurn(){if(!this.isHost||this.state.isExploration)return;if(this.state.phase!==l.AIMING)return;if(this.state.isSimulating)return;const e=this.state.tanks[this.state.currentTurnIndex];e?.isBot&&setTimeout(()=>this.runBotTurn(),500)}runBotTurn(){const e=this.state.tanks[this.state.currentTurnIndex];e&&e.isBot&&this.state.phase===l.AIMING&&(this.botState.planned||(this.planBotMove(e),this.botState.planned=!0),this.executeBotPlan(e))}planBotMove(e){this.botState.moveDir=Math.random()>.5?1:-1,this.botState.moveTimer=Math.floor(30*Math.random()),this.botState.aimTimer=1;const i=this.state.tanks.find(t=>t.id!==e.id&&t.health>0);if(i)if(e.health<35)this.botState.targetWeapon=s.HEAL,this.botState.targetAngle=90,this.botState.targetPower=15;else if(e.y>n-300){this.botState.targetWeapon=s.TELEPORT;const n=t/2-e.x;this.botState.targetAngle=n>0?60:120,this.botState.targetPower=80}else{const t=i.x-e.x,n=Math.abs(t),a=t>0?1:-1;if(n<400)this.botState.targetWeapon=Math.random()>.5?s.SCATTER:s.DRILL;else if(n>800)this.botState.targetWeapon=Math.random()>.6?s.NUKE:s.BASIC;else{const e=[s.BASIC,s.BARRAGE];this.botState.targetWeapon=e[Math.floor(Math.random()*e.length)]}const r=a>0?45:135;this.botState.targetAngle=r+(10*Math.random()-5);const o=Math.sqrt(n*u)/c*100,l=.1*(i.y-e.y);this.botState.targetPower=Math.max(10,Math.min(100,o+l+(10*Math.random()-5)))}}executeBotPlan(e){const t={moveTimer:this.botState.moveTimer,moveDir:this.botState.moveDir,aimTimer:this.botState.aimTimer,targetAngle:this.botState.targetAngle,targetPower:this.botState.targetPower,targetWeapon:this.botState.targetWeapon};t.moveTimer>0&&!e.isMoving&&(e.isMoving=!0,e.moveDir=t.moveDir,-1===t.moveDir?e.angle=Math.max(90,Math.min(180,e.angle)):e.angle=Math.max(0,Math.min(90,e.angle)));const n=e.id,i=e.playerId,a=()=>{const r=this.state.tanks[this.state.currentTurnIndex];if(!r||r.id!==n||this.state.phase!==l.AIMING)return e.isMoving=!1,void(e.moveDir=void 0);if(t.moveTimer>0)return t.moveTimer--,t.moveTimer<=0&&(e.isMoving=!1,e.moveDir=void 0),void requestAnimationFrame(a);if(t.aimTimer>0){e.weapon=t.targetWeapon;const n=t.targetAngle-e.angle;e.angle+=.4*n;const i=t.targetPower-e.power;return e.power+=.4*i,t.aimTimer--,void requestAnimationFrame(a)}e.angle=t.targetAngle,e.power=t.targetPower,this.handleFire(i||"BOT")};requestAnimationFrame(a)}startGame(){this.handleStartGame()}handleStartExploration(){if(this.state.phase!==l.WAITING)return;this.initTerrain();const e=this.state.players[0]||{id:"ME",username:"Explorer"},n=Math.floor(t/2),i=this.getTerrainHeight(n);this.state.tanks=[{id:"tank-explorer",name:e.username||"Explorer",playerId:e.id,isBot:!1,x:n,y:i,angle:45,power:50,health:y,maxHealth:y,color:p[0],weapon:s.BASIC,fuel:m}],this.state.isExploration=!0,this.state.phase=l.AIMING}handleStartGame(){if(this.state.phase!==l.WAITING)return;this.initTerrain();const e=this.state.players.length,n=t/(e+1);this.state.tanks=this.state.players.map((e,t)=>{const i=`tank-${t+1}`;e.tankId=i;const a=Math.floor(n*(t+1)),r=this.getTerrainHeight(a);return{id:i,name:e.username||(e.isBot?"Bot":"Player"),playerId:e.id,isBot:!!e.isBot,x:a,y:r,angle:45,power:50,health:y,maxHealth:y,color:p[t%p.length],weapon:s.BASIC,fuel:m}}),this.state.phase=l.AIMING,this.state.wind=.05*Math.random()-.025,this.state.currentTurnIndex=0,this.checkBotTurn()}reset(){this.state.phase=l.WAITING,this.state.tanks=[],this.state.currentTurnIndex=0,this.state.wind=0,this.state.winner=null,this.state.turnTimeEnd=0,this.state.isExploration=!1,this.state.players.forEach(e=>{e.tankId=null}),this.state.terrainSeed=Math.round(1e4*Math.random()),this.state.terrainMods=[],this.state.isSimulating=!1,this._tankSimulations.clear(),this.initTerrain()}addBot(){if(!this.isHost)return;if(this.state.phase!==l.WAITING)return;const e=this.state.players.filter(e=>e.isBot).length,t=`BOT_${Math.random().toString(36).substr(2,5).toUpperCase()}`;this.state.players.push({id:t,username:`Bot ${e+1}`,tankId:null,isBot:!0})}removeBot(){if(!this.isHost)return;if(this.state.phase!==l.WAITING)return;const e=[...this.state.players].reverse().findIndex(e=>e.isBot);if(-1!==e){const t=this.state.players.length-1-e;this.state.players.splice(t,1)}}requestAddBot(){this.makeAction({type:"ADD_BOT"})}requestStartExploration(){this.makeAction({type:"START_EXPLORATION"})}requestRemoveBot(){this.makeAction({type:"REMOVE_BOT"})}requestReset(){this.makeAction({type:"RESET_GAME"})}requestRegenerateMap(){const e=Math.round(1e4*Math.random());this.makeAction({type:"REGENERATE_MAP",seed:e})}handleRegenerateMap(e){this.state.terrainSeed=e,this.state.terrainMods=[],this._tankSimulations.clear(),this.initTerrain(),console.log("Map regenerated with seed:",e)}commitAngle(e){const t={type:"COMMIT_ANGLE",angle:e,playerId:this.userId};this.makeAction(t)}commitPower(e){const t={type:"COMMIT_POWER",power:e,playerId:this.userId};this.makeAction(t)}selectWeapon(e){const t={type:"SELECT_WEAPON",weapon:e,playerId:this.userId};this.makeAction(t)}moveStart(e){const t=this.getMyTank();if(!t||t.fuel<=0)return;const n={type:"MOVE_START",direction:e,x:t.x,playerId:this.userId};this.makeAction(n)}moveStop(){const e=this.getMyTank();if(!e)return;const t=this._tankSimulations.get(e.id),n={type:"MOVE_STOP",x:t?.x??e.x,y:t?.y??e.y,fuel:t?.fuel??e.fuel,playerId:this.userId};this.makeAction(n)}fire(){const e={type:"FIRE",playerId:this.userId};this.makeAction(e)}getTankByPlayerId(e){return this.state.tanks.find(t=>t.playerId===e)}isPlayerTurn(e){const t=this.state.tanks[this.state.currentTurnIndex];return t?.playerId===e}getMyTank(){return this.state.tanks.find(e=>e.playerId===this.userId)}isMyTurn(){return this.isPlayerTurn(this.userId)}getCurrentTank(){return this.state.tanks[this.state.currentTurnIndex]}canStartGame(){return this.state.players.length>1&&this.state.phase===l.WAITING}updatePlayers(e){if(!(this.players[0]?.id===this.userId))return;const t=[...this.state.players],n=t.filter(e=>"BOT"===e.id),i=e.map(e=>{const n=t.find(t=>t.id===e.id);return{id:e.id,username:e.username,tankId:n?.tankId||null}});i.push(...n),this.state.players=i}destroy(){super.destroy()}}export{P as default};
