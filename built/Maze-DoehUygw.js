import{B as t}from"./BaseGame-DA-imOKx.js";import"./socket-DRbsQkF5.js";import"./index-BO_2Oa9W.js";import"./react-vendor-CFBbA8Qg.js";import"./zustand-0-40VJZq.js";class s{seed;constructor(t){this.seed=t}next(){return this.seed=(1664525*this.seed+1013904223)%4294967295,this.seed/4294967295}nextInt(t,s){return Math.floor(this.next()*(s-t+1))+t}shuffle(t){for(let s=t.length-1;s>0;s--){const e=this.nextInt(0,s);[t[s],t[e]]=[t[e],t[s]]}return t}}class e{grid=[];random;rows;cols;constructor(t,e,i){this.rows=t,this.cols=e,this.random=new s(i),this.initGrid()}initGrid(){this.grid=Array.from({length:this.rows},(t,s)=>Array.from({length:this.cols},(t,e)=>({x:e,y:s,walls:{top:!0,right:!0,bottom:!0,left:!0},visited:!1})))}generate(){return this.generateDFS(),this.addLoops(.03),this.addPortals(2),this.resetVisited(),this.grid}addPortals(t){const s=["#f472b6","#a78bfa","#34d399","#fbbf24"];for(let e=0;e<t;e++){const t=s[e%s.length];let i=null,r=null,o=0;for(;!i&&o<100;){const t=this.random.nextInt(0,this.cols-1),s=this.random.nextInt(0,this.rows-1),e=0===t&&0===s,r=t===this.cols-1&&s===this.rows-1;e||r||this.grid[s][t].portalTo||(i=this.grid[s][t]),o++}for(o=0;!r&&o<100;){const t=this.random.nextInt(0,this.cols-1),s=this.random.nextInt(0,this.rows-1),e=0===t&&0===s,a=t===this.cols-1&&s===this.rows-1,n=i&&t===i.x&&s===i.y;e||a||n||this.grid[s][t].portalTo||(r=this.grid[s][t]),o++}i&&r&&(i.portalTo={x:r.x,y:r.y,color:t},r.portalTo={x:i.x,y:i.y,color:t})}}generateDFS(){const t=[],s=this.grid[0][0];for(s.visited=!0,t.push(s);t.length;){const s=t[t.length-1],e=this.getUnvisitedNeighbors(s);if(0===e.length){t.pop();continue}const i=e[this.random.nextInt(0,e.length-1)];this.removeWalls(s,i),i.visited=!0,t.push(i)}}getUnvisitedNeighbors(t){const{x:s,y:e}=t,i=[];return e>0&&!this.grid[e-1][s].visited&&i.push(this.grid[e-1][s]),s<this.cols-1&&!this.grid[e][s+1].visited&&i.push(this.grid[e][s+1]),e<this.rows-1&&!this.grid[e+1][s].visited&&i.push(this.grid[e+1][s]),s>0&&!this.grid[e][s-1].visited&&i.push(this.grid[e][s-1]),this.random.shuffle(i)}removeWalls(t,s){const e=s.x-t.x,i=s.y-t.y;1===e?(t.walls.right=!1,s.walls.left=!1):-1===e&&(t.walls.left=!1,s.walls.right=!1),1===i?(t.walls.bottom=!1,s.walls.top=!1):-1===i&&(t.walls.top=!1,s.walls.bottom=!1)}addLoops(t){for(let s=0;s<this.rows;s++)for(let e=0;e<this.cols;e++){const i=this.grid[s][e];e<this.cols-1&&i.walls.right&&this.random.next()<t&&this.removeWalls(i,this.grid[s][e+1]),s<this.rows-1&&i.walls.bottom&&this.random.next()<t&&this.removeWalls(i,this.grid[s+1][e])}}resetVisited(){for(const t of this.grid)for(const s of t)s.visited=!1}}class i{static canMove(t,s,e,i,r){if(e<0||i<0||e>=s.cols||i>=s.rows||!t[i]||!t[i][e])return!1;const o=t[i][e],{rows:a,cols:n}=s;switch(r){case"UP":return!o.walls.top&&i>0;case"DOWN":return!o.walls.bottom&&i<a-1;case"LEFT":return!o.walls.left&&e>0;case"RIGHT":return!o.walls.right&&e<n-1}return!1}static getOppositeDir(t){switch(t){case"UP":return"DOWN";case"DOWN":return"UP";case"LEFT":return"RIGHT";case"RIGHT":return"LEFT"}}static getDirDelta(t){switch(t){case"UP":return{dx:0,dy:-1};case"DOWN":return{dx:0,dy:1};case"LEFT":return{dx:-1,dy:0};case"RIGHT":return{dx:1,dy:0}}}static getAvailableExits(t,s,e,i,r){const o=[],a=this.getOppositeDir(r);return this.canMove(t,s,e,i,"UP")&&"UP"!==a&&o.push("UP"),this.canMove(t,s,e,i,"DOWN")&&"DOWN"!==a&&o.push("DOWN"),this.canMove(t,s,e,i,"LEFT")&&"LEFT"!==a&&o.push("LEFT"),this.canMove(t,s,e,i,"RIGHT")&&"RIGHT"!==a&&o.push("RIGHT"),o}static getMazePath(t,s,e,i,r){const o=[];let a=e,n=i,l=r;if(!this.canMove(t,s,a,n,l))return o;const h=s.rows*s.cols;let c=0;for(;c<h;){const{dx:e,dy:i}=this.getDirDelta(l);if(a+=e,n+=i,c++,o.push({x:a,y:n}),t[n][a].portalTo)break;if(a===s.cols-1&&n===s.rows-1)break;const r=this.getAvailableExits(t,s,a,n,l);if(1!==r.length)break;l=r[0]}return o}}const r={EASY:{rows:10,cols:10},MEDIUM:{rows:20,cols:20},HARD:{rows:30,cols:30}};class o extends t{mazeGrid=null;seed=null;constructor(t,s,e,i){super(t,s,e,i),this.setGameName("maze")}getInitState(){return{config:{rows:10,cols:10,difficulty:"EASY"},level:1,seed:this.isHost?Math.floor(1e6*Math.random()):null,status:"WAITING",players:{[this.players[0].id]:{...this.players[0],x:0,y:0,color:this.getPlayerColor(this.players[0].username)}},winners:[]}}onStateUpdate(t){super.onStateUpdate(t),this.seed!==t.seed&&(this.mazeGrid=null,this.seed=t.seed)}getMazeGrid(){if(!this.mazeGrid&&this.state.seed){const{rows:t,cols:s}=this.state.config,i=new e(t,s,this.state.seed);this.mazeGrid=i.generate()}return this.mazeGrid??null}onSocketGameAction(t){if(!this.isHost)return;const s=t.action;switch(s.type){case"MOVE":s.direction&&s.playerId&&this.handleMove({type:"MOVE",direction:s.direction,playerId:s.playerId});break;case"TELEPORT":s.playerId&&this.handleTeleport(s.playerId);break;case"START_GAME":this.state.status="PLAYING",this.state.startTime=Date.now(),this.resetPlayers();break;case"NEXT_LEVEL":this.nextLevel();break;case"RESET_GAME":this.resetGame();break;case"UPDATE_SETTINGS":if(s.difficulty&&["EASY","MEDIUM","HARD"].includes(s.difficulty)){const t=r[s.difficulty];t&&(this.state.config.rows=t.rows,this.state.config.cols=t.cols,this.state.config.difficulty=s.difficulty,this.state.seed=Math.floor(1e6*Math.random()),this.mazeGrid=null)}}}updatePlayers(t){super.updatePlayers(t);const s={};t.forEach(t=>{this.state.players[t.id]?s[t.id]=this.state.players[t.id]:s[t.id]={isHost:!1,id:t.id,username:t.username,x:0,y:0,color:this.getPlayerColor(t.username)}}),this.state.players=s}handleMove(t){if("PLAYING"!==this.state.status)return;const s=this.state.players[t.playerId];if(!s||this.state.winners.includes(s.id))return;if(s.moveEnd&&Date.now()<s.moveEnd)return;const{x:e,y:r}=s,o=t.direction,a=this.getMazeGrid();if(!a)return;const n=i.getMazePath(a,this.state.config,e,r,o);if(0===n.length)return;const l=n[n.length-1],h=n.length/10*1e3;s.x=l.x,s.y=l.y,s.currentPath=[{x:e,y:r},...n],s.moveStart=Date.now(),s.moveEnd=Date.now()+h,l.x===this.state.config.cols-1&&l.y===this.state.config.rows-1&&this.finishPlayer(s,l.x,l.y)}finishPlayer(t,s,e){t.x=s,t.y=e,this.state.winners.push(t.id);Object.keys(this.state.players).every(t=>this.state.winners.includes(t))&&(this.state.status="FINISHED")}handleTeleport(t){if("PLAYING"!==this.state.status)return;const s=this.state.players[t];if(!s)return;if(s.moveEnd&&Date.now()<s.moveEnd)return;const e=this.getMazeGrid();if(!e)return;const i=e[s.y][s.x];if(i.portalTo){const t=i.portalTo;s.x=t.x,s.y=t.y}}nextLevel(){this.state.level++;const t=["EASY","MEDIUM","HARD"],s=t[Math.min(Math.floor((this.state.level-1)/3),t.length-1)],e=r[s];this.state.config.rows=e.rows,this.state.config.cols=e.cols,this.state.config.difficulty=s,this.state.seed=Math.floor(1e6*Math.random()),this.state.winners=[],this.state.status="WAITING",this.state.startTime=Date.now(),this.mazeGrid=null,this.resetPlayers()}resetGame(){this.state.level=1,this.state.config.rows=r.EASY.rows,this.state.config.cols=r.EASY.cols,this.state.config.difficulty="EASY",this.state.seed=Math.floor(1e6*Math.random()),this.state.winners=[],this.state.status="WAITING",this.mazeGrid=null,this.resetPlayers()}resetPlayers(){Object.values(this.state.players).forEach(t=>{t.x=0,t.y=0,t.currentPath=void 0,t.moveStart=void 0,t.moveEnd=void 0})}getPlayerColor(t){const s=["#ef4444","#3b82f6","#22c55e","#eab308","#a855f7","#ec4899"];let e=0;for(let i=0;i<t.length;i++)e=t.charCodeAt(i)+((e<<5)-e);return s[Math.abs(e)%s.length]}}export{r as DIFFICULTY_CONFIG,o as default};
