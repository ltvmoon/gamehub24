import{B as t}from"./BaseGame-B7FOWFqv.js";class s{seed;constructor(t){this.seed=t}next(){return this.seed=(9301*this.seed+49297)%233280,this.seed/233280}nextInt(t,s){return Math.floor(this.next()*(s-t+1))+t}}class e{random;rows;cols;grid;constructor(t,e,i){this.rows=t,this.cols=e,this.random=new s(i),this.grid=this.initGrid()}initGrid(){const t=[];for(let s=0;s<this.rows;s++){const e=[];for(let t=0;t<this.cols;t++)e.push({x:t,y:s,walls:{top:!0,right:!0,bottom:!0,left:!0},visited:!1});t.push(e)}return t}generate(){const t=this.grid[0][0];return this.visit(t),this.grid}visit(t){t.visited=!0;const s=this.getUnvisitedNeighbors(t);for(;s.length>0;){const e=s[this.random.nextInt(0,s.length-1)];this.removeWalls(t,e),this.visit(e),s.splice(0,s.length,...this.getUnvisitedNeighbors(t))}}getUnvisitedNeighbors(t){const s=[],{x:e,y:i}=t;return i>0&&!this.grid[i-1][e].visited&&s.push(this.grid[i-1][e]),e<this.cols-1&&!this.grid[i][e+1].visited&&s.push(this.grid[i][e+1]),i<this.rows-1&&!this.grid[i+1][e].visited&&s.push(this.grid[i+1][e]),e>0&&!this.grid[i][e-1].visited&&s.push(this.grid[i][e-1]),s}removeWalls(t,s){const e=t.x-s.x,i=t.y-s.y;1===e?(t.walls.left=!1,s.walls.right=!1):-1===e&&(t.walls.right=!1,s.walls.left=!1),1===i?(t.walls.top=!1,s.walls.bottom=!1):-1===i&&(t.walls.bottom=!1,s.walls.top=!1)}}class i{static canMove(t,s,e,i,r){if(e<0||i<0||e>=s.cols||i>=s.rows||!t[i]||!t[i][e])return!1;const a=t[i][e],{rows:o,cols:n}=s;switch(r){case"UP":return!a.walls.top&&i>0;case"DOWN":return!a.walls.bottom&&i<o-1;case"LEFT":return!a.walls.left&&e>0;case"RIGHT":return!a.walls.right&&e<n-1}return!1}static getOppositeDir(t){switch(t){case"UP":return"DOWN";case"DOWN":return"UP";case"LEFT":return"RIGHT";case"RIGHT":return"LEFT"}}static getDirDelta(t){switch(t){case"UP":return{dx:0,dy:-1};case"DOWN":return{dx:0,dy:1};case"LEFT":return{dx:-1,dy:0};case"RIGHT":return{dx:1,dy:0}}}static getAvailableExits(t,s,e,i,r){const a=[],o=this.getOppositeDir(r);return this.canMove(t,s,e,i,"UP")&&"UP"!==o&&a.push("UP"),this.canMove(t,s,e,i,"DOWN")&&"DOWN"!==o&&a.push("DOWN"),this.canMove(t,s,e,i,"LEFT")&&"LEFT"!==o&&a.push("LEFT"),this.canMove(t,s,e,i,"RIGHT")&&"RIGHT"!==o&&a.push("RIGHT"),a}static getMazePath(t,s,e,i,r){const a=[];let o=e,n=i,l=r;if(!this.canMove(t,s,o,n,l))return a;const h=s.rows*s.cols;let c=0;for(;c<h;){const{dx:e,dy:i}=this.getDirDelta(l);if(o+=e,n+=i,c++,a.push({x:o,y:n}),o===s.cols-1&&n===s.rows-1)break;const r=this.getAvailableExits(t,s,o,n,l);if(1!==r.length)break;l=r[0]}return a}}const r={EASY:{rows:10,cols:10},MEDIUM:{rows:20,cols:20},HARD:{rows:30,cols:30}};const a=Object.freeze(Object.defineProperty({__proto__:null,DIFFICULTY_CONFIG:r,default:class extends t{mazeGrid=null;constructor(t,s,e,i){super(t,s,e,i),this.setGameName("maze")}getInitState(){return{config:{rows:10,cols:10,difficulty:"EASY"},level:1,seed:Math.floor(1e6*Math.random()),status:"WAITING",players:{[this.players[0].id]:{...this.players[0],x:0,y:0,color:this.getPlayerColor(this.players[0].username)}},winners:[]}}getMazeGrid(){if(!this.mazeGrid){const{rows:t,cols:s}=this.state.config,i=new e(t,s,this.state.seed);this.mazeGrid=i.generate()}return this.mazeGrid}onSocketGameAction(t){if(!this.isHost)return;const s=t.action;switch(s.type){case"MOVE":s.direction&&s.playerId&&this.handleMove({type:"MOVE",direction:s.direction,playerId:s.playerId});break;case"START_GAME":this.state.status="PLAYING",this.state.startTime=Date.now(),this.resetPlayers();break;case"NEXT_LEVEL":this.nextLevel();break;case"RESET_GAME":this.resetGame();break;case"UPDATE_SETTINGS":if(s.difficulty&&["EASY","MEDIUM","HARD"].includes(s.difficulty)){const t=r[s.difficulty];t&&(this.state.config={...this.state.config,...t,difficulty:s.difficulty},this.state.seed=Math.floor(1e6*Math.random()),this.mazeGrid=null)}}}updatePlayers(t){super.updatePlayers(t),console.log(t);const s={};t.forEach(t=>{this.state.players[t.id]?s[t.id]=this.state.players[t.id]:s[t.id]={isHost:!1,id:t.id,username:t.username,x:0,y:0,color:this.getPlayerColor(t.username)}}),this.state.players=s}handleMove(t){if("PLAYING"!==this.state.status)return;const s=this.state.players[t.playerId];if(!s||this.state.winners.includes(s.id))return;if(s.moveEnd&&Date.now()<s.moveEnd)return;const{x:e,y:r}=s,a=t.direction,o=this.getMazeGrid(),n=i.getMazePath(o,this.state.config,e,r,a);if(0===n.length)return;const l=n[n.length-1],h=n.length/10*1e3;s.x=l.x,s.y=l.y,s.currentPath=[{x:e,y:r},...n],s.moveStart=Date.now(),s.moveEnd=Date.now()+h,l.x===this.state.config.cols-1&&l.y===this.state.config.rows-1&&this.finishPlayer(s,l.x,l.y)}finishPlayer(t,s,e){t.x=s,t.y=e,this.state.winners.push(t.id);Object.keys(this.state.players).every(t=>this.state.winners.includes(t))&&(this.state.status="FINISHED")}nextLevel(){this.state.level++;const t=["EASY","MEDIUM","HARD"][Math.min(Math.floor((this.state.level-1)/2),2)];this.state.config={...r[t],difficulty:t},this.state.level>6&&(this.state.config.rows+=5,this.state.config.cols+=5),this.state.seed=Math.floor(1e6*Math.random()),this.state.winners=[],this.state.status="WAITING",this.state.startTime=Date.now(),this.mazeGrid=null,this.resetPlayers()}resetGame(){this.state.level=1,this.state.config={...r.EASY,difficulty:"EASY"},this.state.seed=Math.floor(1e6*Math.random()),this.state.winners=[],this.state.status="WAITING",this.mazeGrid=null,this.resetPlayers()}resetPlayers(){Object.values(this.state.players).forEach(t=>{t.x=0,t.y=0,t.currentPath=void 0,t.moveStart=void 0,t.moveEnd=void 0})}getPlayerColor(t){const s=["#ef4444","#3b82f6","#22c55e","#eab308","#a855f7","#ec4899"];let e=0;for(let r=0;r<t.length;r++)e=t.charCodeAt(r)+((e<<5)-e);const i=s[Math.abs(e)%s.length];return console.log(t,i),i}}},Symbol.toStringTag,{value:"Module"}));export{r as D,e as M,a};
