import{B as t}from"./BaseGame-IZyxFPA5.js";import{R as e,H as s,S as i}from"./types-l73mk7qx.js";import"./socket-DRbsQkF5.js";import"./index-D0eX7lY_.js";import"./react-vendor-BbNWoFff.js";import"./zustand-ClrqN2jy.js";class a extends t{deck=[];getMyPlayerIndex(){return this.state.players.findIndex(t=>t.id===this.userId)}getUserId(){return this.userId}getInitState(){const t=Array(6).fill(null).map((t,e)=>({id:null,username:`Seat ${e+1}`,hand:[],chips:1e3,currentBet:0,isBot:!1,isGuest:!1,isHost:!1,hasFolded:!1,isAllIn:!1,isDealer:!1,isSmallBlind:!1,isBigBlind:!1,isActive:!1,hasActed:!1}));return this.players&&this.players.length>0&&this.players.forEach(e=>{const s=t.findIndex(t=>null===t.id);-1!==s&&(t[s]={...t[s],id:e.id,username:e.username||`Player ${e.id.substr(0,4)}`,isHost:e.id===this.userId,chips:1e3})}),{players:t,communityCards:[],pot:0,currentBet:0,dealerIndex:0,currentTurnIndex:0,smallBlindAmount:10,bigBlindAmount:20,gamePhase:"waiting",winnerIds:[],minRaise:20}}onSocketGameAction(t){if(!this.isHost)return;const e=t.action;switch(e.type){case"START_GAME":this.startGame();break;case"ADD_BOT":this.addBot(e.slotIndex);break;case"RESET_GAME":this.resetGame();break;case"JOIN_SLOT":this.joinSlot(e.slotIndex,e.playerId,e.playerName);break;case"REMOVE_PLAYER":this.removePlayer(e.slotIndex);break;case"FOLD":this.handleFold(e.playerId);break;case"CHECK":this.handleCheck(e.playerId);break;case"CALL":this.handleCall(e.playerId);break;case"RAISE":this.handleRaise(e.playerId,e.amount);break;case"ALL_IN":this.handleAllIn(e.playerId)}}updatePlayers(t){super.updatePlayers(t),this.isHost&&(this.state.players.forEach((e,s)=>{if(e.id&&!e.isBot){t.find(t=>t.id===e.id)||this.removePlayer(s)}}),t.forEach(t=>{if(!this.state.players.some(e=>e.id===t.id)){const e=this.state.players.findIndex(t=>null===t.id);-1!==e&&(this.joinSlot(e,t.id,t.username||"Player"),t.id===this.userId&&this.isHost&&(this.state.players[e].isHost=!0))}}))}startGame(){if(this.state.players.filter(t=>null!==t.id).length<2)return;this.deck=this.createDeck(),this.shuffleDeck(this.deck),this.state.communityCards=[],this.state.pot=0,this.state.winnerIds=[],this.state.winningHand=void 0,this.state.gamePhase="pre_flop",this.state.lastAction=void 0,this.state.players.forEach(t=>{null!==t.id?(t.isActive=!0,t.hand=[],t.hasFolded=!1,t.isAllIn=!1,t.currentBet=0,t.isSmallBlind=!1,t.isBigBlind=!1,t.hasActed=!1,t.chips<=0&&(t.chips=1e3)):t.isActive=!1}),this.moveButton(),this.postBlinds(),this.dealHoleCards();const t=this.getActivePlayerIndices(),e=t.indexOf(this.state.dealerIndex);let s;s=2===t.length?e:(e+3)%t.length,this.state.currentTurnIndex=t[s],this.state.minRaise=this.state.bigBlindAmount,this.syncState(),this.checkBotTurn()}moveButton(){const t=this.getActivePlayerIndices();if(0===t.length)return;let e=t.indexOf(this.state.dealerIndex);-1===e&&(e=0);const s=(e+1)%t.length;this.state.dealerIndex=t[s],this.state.players.forEach(t=>t.isDealer=!1),this.state.players[this.state.dealerIndex].isDealer=!0}postBlinds(){const t=this.getActivePlayerIndices(),e=t.indexOf(this.state.dealerIndex);let s,i;2===t.length?(s=e,i=(e+1)%2):(s=(e+1)%t.length,i=(e+2)%t.length);const a=t[s],n=this.state.players[a],r=Math.min(n.chips,this.state.smallBlindAmount);n.chips-=r,n.currentBet=r,n.isSmallBlind=!0,this.state.pot+=r;const h=t[i],l=this.state.players[h],d=Math.min(l.chips,this.state.bigBlindAmount);l.chips-=d,l.currentBet=d,l.isBigBlind=!0,this.state.pot+=d,this.state.currentBet=this.state.bigBlindAmount}dealHoleCards(){this.state.players.forEach(t=>{t.isActive&&(t.hand=[this.deck.pop(),this.deck.pop()])})}nextPhase(){switch(this.state.players.forEach(t=>{t.currentBet=0,t.hasActed=!1}),this.state.currentBet=0,this.state.minRaise=this.state.bigBlindAmount,this.state.lastAction=void 0,this.state.gamePhase){case"pre_flop":this.dealCommunityCards(3),this.state.gamePhase="flop";break;case"flop":this.dealCommunityCards(1),this.state.gamePhase="turn";break;case"turn":this.dealCommunityCards(1),this.state.gamePhase="river";break;case"river":return void this.showdown()}if(0===this.getActivePlayerIndices().filter(t=>!this.state.players[t].hasFolded&&!this.state.players[t].isAllIn).length)return void this.runRemainingPhases();let t=(this.state.dealerIndex+1)%6;for(;(!this.state.players[t].isActive||this.state.players[t].hasFolded||this.state.players[t].isAllIn)&&(t=(t+1)%6,t!==this.state.dealerIndex););this.state.currentTurnIndex=t,this.syncState(),this.checkBotTurn()}runRemainingPhases(){for(;"ended"!==this.state.gamePhase;){if("pre_flop"===this.state.gamePhase)this.dealCommunityCards(3),this.state.gamePhase="flop";else if("flop"===this.state.gamePhase)this.dealCommunityCards(1),this.state.gamePhase="turn";else if("turn"===this.state.gamePhase)this.dealCommunityCards(1),this.state.gamePhase="river";else if("river"===this.state.gamePhase)return void this.showdown();this.syncState()}}dealCommunityCards(t){for(let e=0;e<t;e++)this.deck.length>0&&this.state.communityCards.push(this.deck.pop())}showdown(){this.state.gamePhase="showdown";const t=this.state.players.filter(t=>t.isActive&&!t.hasFolded);if(0===t.length)return;if(1===t.length){const e=t[0];return this.state.winnerIds=[e.id],e.chips+=this.state.pot,this.state.pot=0,this.state.gamePhase="ended",void this.syncState()}let e,s=-1,i=[];for(const r of t){const t=this.evaluateHand(r.hand,this.state.communityCards),a=this.getHandValue(t);a>s?(s=a,i=[r],e=t):a===s&&i.push(r)}this.state.winnerIds=i.map(t=>t.id),this.state.winningHand=e;const a=Math.floor(this.state.pot/i.length);i.forEach(t=>t.chips+=a);const n=this.state.pot%i.length;n>0&&i.length>0&&(i[0].chips+=n),this.state.pot=0,this.state.gamePhase="ended",this.syncState()}evaluateHand(t,i){const a=[...t,...i];a.sort((t,e)=>e.rank-t.rank);const n={};a.forEach(t=>{n[t.suit]||(n[t.suit]=[]),n[t.suit].push(t)});let r=-1;Object.keys(n).forEach(t=>{n[Number(t)].length>=5&&(r=Number(t))});const h=Array.from(new Set(a.map(t=>t.rank))).sort((t,e)=>e-t);let l=-1;for(let e=0;e<=h.length-5;e++)if(h[e]-h[e+4]===4){l=h[e];break}if(-1===l&&h.includes(e.ACE)&&h.includes(e.TWO)&&h.includes(e.THREE)&&h.includes(e.FOUR)&&h.includes(e.FIVE)&&(l=5),-1!==r){const t=n[r],i=Array.from(new Set(t.map(t=>t.rank))).sort((t,e)=>e-t);for(let a=0;a<=i.length-5;a++)if(i[a]-i[a+4]===4)return i[a]===e.ACE?{rank:s.ROYAL_FLUSH,cards:t.slice(a,a+5),kickers:[],name:"Royal Flush"}:{rank:s.STRAIGHT_FLUSH,cards:t.slice(a,a+5),kickers:[],name:"Straight Flush"};if(i.includes(e.ACE)&&i.includes(e.TWO)&&i.includes(e.THREE)&&i.includes(e.FOUR)&&i.includes(e.FIVE)){const e=t.filter(t=>[14,2,3,4,5].includes(t.rank)).slice(0,5);return{rank:s.STRAIGHT_FLUSH,cards:e,kickers:[],name:"Straight Flush (Low)"}}}const d={};a.forEach(t=>{d[t.rank]||(d[t.rank]=[]),d[t.rank].push(t)});const c=Object.keys(d).map(Number).sort((t,e)=>e-t),o=c.filter(t=>4===d[t].length),u=c.filter(t=>3===d[t].length),p=c.filter(t=>2===d[t].length);if(o.length>0){const t=o[0],e=d[t],i=a.find(e=>e.rank!==t);return{rank:s.FOUR_OF_A_KIND,cards:[...e,i],kickers:[i],name:"Four of a Kind"}}if(u.length>0&&p.length>0||u.length>1){const t=u[0],e=u.length>1?u[1]:p[0];return{rank:s.FULL_HOUSE,cards:[...d[t],...d[e].slice(0,2)],kickers:[],name:"Full House"}}if(-1!==r){const t=n[r];return{rank:s.FLUSH,cards:t.slice(0,5),kickers:[],name:"Flush"}}if(-1!==l){let t=[];if(5===l){t=[5,4,3,2,e.ACE].map(t=>a.find(e=>e.rank===t))}else for(let e=0;e<5;e++)t.push(a.find(t=>t.rank===l-e));return{rank:s.STRAIGHT,cards:t,kickers:[],name:"Straight"}}if(u.length>0){const t=u[0],e=a.filter(e=>e.rank!==t).slice(0,2);return{rank:s.THREE_OF_A_KIND,cards:[...d[t],...e],kickers:e,name:"Three of a Kind"}}if(p.length>0){if(p.length>=2){const t=p[0],e=p[1],i=a.find(s=>s.rank!==t&&s.rank!==e);return{rank:s.TWO_PAIR,cards:[...d[t],...d[e],i],kickers:[i],name:"Two Pair"}}{const t=p[0],e=a.filter(e=>e.rank!==t).slice(0,3);return{rank:s.PAIR,cards:[...d[t],...e],kickers:e,name:"Pair"}}}return{rank:s.HIGH_CARD,cards:a.slice(0,5),kickers:a.slice(1,5),name:"High Card"}}getHandValue(t){let e=1e10*t.rank;return t.cards.forEach((t,s)=>{e+=t.rank*Math.pow(15,4-s)}),e}createDeck(){const t=[];for(const s of[i.SPADE,i.CLUB,i.DIAMOND,i.HEART])for(let i=e.TWO;i<=e.ACE;i++)t.push({suit:s,rank:i});return t}shuffleDeck(t){for(let e=t.length-1;e>0;e--){const s=Math.floor(Math.random()*(e+1));[t[e],t[s]]=[t[s],t[e]]}return t}addBot(t){null===this.state.players[t].id&&(this.state.players[t]={...this.state.players[t],id:`BOT_${Date.now()}_${t}`,username:`Bot ${t+1}`,isBot:!0,chips:1e3},this.state.players=[...this.state.players],this.syncState())}resetGame(){this.state.gamePhase="waiting",this.state.communityCards=[],this.state.pot=0,this.state.currentBet=0,this.state.winnerIds=[],this.state.winningHand=void 0,this.state.lastAction=void 0,this.state.players.forEach(t=>{t.hand=[],t.isActive=!1,t.hasFolded=!1,t.isAllIn=!1,t.currentBet=0,t.hasActed=!1,t.isDealer=!1,t.isSmallBlind=!1,t.isBigBlind=!1,null!==t.id&&(t.chips=1e3)}),this.state.players=[...this.state.players],this.syncState()}joinSlot(t,e,s){if(null!==this.state.players[t].id)return;const i=this.state.players.findIndex(t=>t.id===e);-1!==i&&this.removePlayer(i),this.state.players[t]={...this.state.players[t],id:e,username:s,isBot:!1,isGuest:!1,chips:1e3},this.state.players=[...this.state.players],this.syncState()}removePlayer(t){this.state.players[t]={id:null,username:`Seat ${t+1}`,hand:[],chips:1e3,currentBet:0,isBot:!1,isGuest:!1,isHost:!1,hasFolded:!1,isAllIn:!1,isDealer:!1,isSmallBlind:!1,isBigBlind:!1,isActive:!1,hasActed:!1},this.state.players=[...this.state.players],this.syncState()}requestStartGame(){this.makeAction({type:"START_GAME"})}requestResetGame(){this.makeAction({type:"RESET_GAME"})}requestAddBot(t){this.makeAction({type:"ADD_BOT",slotIndex:t})}requestJoinSlot(t,e){this.makeAction({type:"JOIN_SLOT",slotIndex:t,playerId:this.userId,playerName:e})}requestRemovePlayer(t){this.makeAction({type:"REMOVE_PLAYER",slotIndex:t})}requestFold(){this.makeAction({type:"FOLD",playerId:this.userId})}requestCheck(){this.makeAction({type:"CHECK",playerId:this.userId})}requestCall(){this.makeAction({type:"CALL",playerId:this.userId})}requestRaise(t){this.makeAction({type:"RAISE",playerId:this.userId,amount:t})}requestAllIn(){this.makeAction({type:"ALL_IN",playerId:this.userId})}handleFold(t){if(!this.isPlayerTurn(t))return;const e=this.state.players[this.state.currentTurnIndex];e.hasFolded=!0,e.hasActed=!0,e.isActive=!1;const s=this.state.players.filter(t=>t.isActive&&!t.hasFolded);1===s.length?this.endHandWithWinner(s[0]):this.advanceTurn()}handleCheck(t){if(!this.isPlayerTurn(t))return;const e=this.state.players[this.state.currentTurnIndex];this.state.currentBet>e.currentBet||(e.hasActed=!0,this.advanceTurn())}handleCall(t){if(!this.isPlayerTurn(t))return;const e=this.state.players[this.state.currentTurnIndex],s=this.state.currentBet-e.currentBet;s>e.chips?this.handleAllIn(t):(e.chips-=s,e.currentBet+=s,this.state.pot+=s,e.hasActed=!0,this.advanceTurn())}handleRaise(t,e){if(!this.isPlayerTurn(t))return;const s=this.state.players[this.state.currentTurnIndex];if(e<this.state.currentBet+this.state.minRaise)return;if(e>s.chips+s.currentBet)return;const i=e-s.currentBet;s.chips-=i,s.currentBet=e,this.state.pot+=i;const a=e-this.state.currentBet;a>=this.state.minRaise&&(this.state.minRaise=a),this.state.currentBet=e,this.state.lastAction={playerId:t,action:"Raise",amount:e},s.hasActed=!0,this.advanceTurn()}handleAllIn(t){if(!this.isPlayerTurn(t))return;const e=this.state.players[this.state.currentTurnIndex],s=e.chips;if(e.chips=0,e.currentBet+=s,this.state.pot+=s,e.isAllIn=!0,e.currentBet>this.state.currentBet){const s=e.currentBet-this.state.currentBet;s>this.state.minRaise&&(this.state.minRaise=s),this.state.currentBet=e.currentBet,this.state.lastAction={playerId:t,action:"All In",amount:e.currentBet}}e.hasActed=!0,this.advanceTurn()}advanceTurn(){if(this.checkBettingRoundComplete())return void this.nextPhase();let t=(this.state.currentTurnIndex+1)%6,e=0;for(;(null===this.state.players[t].id||this.state.players[t].hasFolded||this.state.players[t].isAllIn)&&e<6;)t=(t+1)%6,e++;this.state.currentTurnIndex=t,this.syncState(),this.checkBotTurn()}checkBettingRoundComplete(){const t=this.state.players.filter(t=>t.isActive&&!t.hasFolded);return!!t.every(t=>t.currentBet===this.state.currentBet||t.isAllIn)&&t.every(t=>(t.currentBet===this.state.currentBet||t.isAllIn)&&this.hasPlayerActed(t))}hasPlayerActed(t){return t.isActive&&(t.hasFolded||t.isAllIn||t.hasActed)}isPlayerTurn(t){const e=this.state.players[this.state.currentTurnIndex];return e&&e.id===t}getActivePlayerIndices(){return this.state.players.map((t,e)=>({p:t,i:e})).filter(t=>null!==t.p.id).map(t=>t.i)}endHandWithWinner(t){this.state.winnerIds=[t.id],t.chips+=this.state.pot,this.state.pot=0,this.state.gamePhase="ended",this.syncState()}checkBotTurn(){if(!this.isHost)return;const t=this.state.players[this.state.currentTurnIndex];t&&t.isBot&&t.isActive&&!t.hasFolded&&!t.isAllIn&&setTimeout(()=>{this.handleBotMove(t)},1e3)}handleBotMove(t){if("ended"===this.state.gamePhase)return;const e=this.evaluateHand(t.hand,this.state.communityCards),i=this.state.currentBet-t.currentBet;if(0===i)return void this.handleCheck(t.id);const a=i/t.chips;if(e.rank>=s.TWO_PAIR){if(t.chips>2*i){const e=this.state.currentBet+Math.min(t.chips,this.state.minRaise);return void this.handleRaise(t.id,e)}this.handleAllIn(t.id)}else e.rank>=s.PAIR||"pre_flop"===this.state.gamePhase&&t.hand[0].rank+t.hand[1].rank>20?this.handleCall(t.id):a>.02?this.handleFold(t.id):this.handleCall(t.id)}}export{a as default};
