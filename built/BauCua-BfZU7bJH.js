import{B as t}from"./BaseGame-BoHpQUK3.js";import{I as e,P as s,M as a,A as r,J as i,a as n}from"./types-CZtBwmuW.js";import{r as o}from"./index-BLcGWsmB.js";import"./socket-DRbsQkF5.js";import"./react-vendor-DeJ0i39y.js";import"./zustand-ie0NTbcC.js";class l extends t{botMoveTimeout=null;getInitState(){const t={},s={};return this.players.forEach(a=>{t[a.id]={playerId:a.id,username:a.username,currentBalance:e,balanceHistory:[e],totalBet:0,isBot:a.isBot||!1},s[a.id]=this.initializePowerUps()}),{gamePhase:"waiting",playerBalances:t,currentBets:{},diceRoll:null,currentRound:0,playersReady:{},winners:[],playerPowerUps:s,activePowerUps:{},powerUpPredictions:{},recentRolls:{},isMegaRound:!1,jackpotPool:0,minBalanceToWin:0}}initializePowerUps(){const t={};for(const[e,a]of Object.entries(s))t[e]={type:e,cooldown:0,lastUsedRound:-1};return t}onSocketGameAction(t){const e=t.action;if(this.isHost)switch(e.type){case"PLACE_BET":this.handlePlaceBet(e.playerId,e.symbol,e.amount);break;case"CLEAR_BETS":this.handleClearBets(e.playerId);break;case"SYNC_BETS":this.handleSyncBets(e.playerId,e.bets);break;case"TOGGLE_READY":this.handleToggleReady(e.playerId);break;case"ROLL_DICE":this.handleRollDice();break;case"START_NEW_ROUND":this.handleStartNewRound();break;case"RESET_GAME":this.handleResetGame();break;case"SET_GAME_MODE":this.handleSetGameMode(e.minBalance);break;case"ADD_BOT":this.handleAddBot();break;case"REMOVE_BOT":this.handleRemoveBot(e.playerId);break;case"ACTIVATE_POWERUP":this.handleActivatePowerUp(e.playerId,e.powerUpType);break;case"DEACTIVATE_POWERUP":this.handleDeactivatePowerUp(e.playerId)}}handlePlaceBet(t,e,s){if("betting"!==this.state.gamePhase)return;const r=this.state.playerBalances[t];if(!r)return;const i=this.state.currentBets[t]||[],n=i.reduce((t,e)=>t+e.amount,0),o=r.currentBalance-n,l=Math.min(s,o);if(l<a)return;const c=i.findIndex(t=>t.symbol===e);c>=0?i[c].amount+=l:i.push({symbol:e,amount:l}),this.state.currentBets[t]=i,this.state.playerBalances[t].totalBet=n+l}handleClearBets(t){"betting"===this.state.gamePhase&&(this.state.currentBets[t]=[],this.state.playerBalances[t].totalBet=0,this.state.playersReady[t]=!1)}handleSyncBets(t,e){if("betting"!==this.state.gamePhase)return;const s=this.state.playerBalances[t];if(!s)return;const a=e.reduce((t,e)=>t+e.amount,0);a>s.currentBalance||(this.state.currentBets[t]=e,this.state.playerBalances[t].totalBet=a)}handleToggleReady(t){if("betting"!==this.state.gamePhase)return;((this.state.currentBets[t]||[]).length>0||this.state.playersReady[t])&&(this.state.playersReady[t]=!this.state.playersReady[t])}handleRollDice(){if("betting"!==this.state.gamePhase)return;if(0===Object.keys(this.state.currentBets).filter(t=>(this.state.currentBets[t]||[]).length>0).length)return void this.handleStartNewRound();this.state.gamePhase="rolling";const t=[r[Math.floor(Math.random()*r.length)],r[Math.floor(Math.random()*r.length)],r[Math.floor(Math.random()*r.length)]];Object.keys(this.state.powerUpPredictions).forEach(e=>{const s=this.state.powerUpPredictions[e];if("reveal_one"===this.state.activePowerUps[e]){const e=t.includes(s.symbol),a=Math.random()<s.accuracy;if(s.actuallyCorrect=a,a&&!e){const e=Math.floor(3*Math.random());t[e]=s.symbol}else if(!a&&e){const e=t.map((t,e)=>t===s.symbol?e:-1).filter(t=>t>=0);if(e.length>0){const a=r.filter(t=>t!==s.symbol),i=e[Math.floor(Math.random()*e.length)];t[i]=a[Math.floor(Math.random()*a.length)]}}}}),this.state.diceRoll=[t[0],t[1],t[2]];const e=`${Date.now()}_${Math.random().toString(36).substr(2,5)}`;this.state.recentRolls[e]=[t[0],t[1],t[2]];const s=Object.keys(this.state.recentRolls);if(s.length>100){const t=s.sort(),e=t.length-100;for(let s=0;s<e;s++)delete this.state.recentRolls[t[s]]}setTimeout(()=>{this.calculateResults()},3500)}calculateResults(){if(!this.state.diceRoll)return;const t=this.state.diceRoll,e={gourd:0,crab:0,shrimp:0,fish:0,chicken:0,deer:0};t.forEach(t=>{e[t]++});const a=t[0]===t[1]&&t[1]===t[2],r=a?t[0]:null;let n=0;this.state.isMegaRound&&r&&(n=Object.values(this.state.currentBets).filter(t=>t.some(t=>t.symbol===r)).length);let l=0;Object.keys(this.state.currentBets).forEach(t=>{const a=this.state.currentBets[t]||[],i=this.state.playerBalances[t];if(!i)return;let c=0,h=0,d=0;const u=this.state.activePowerUps[t];if(a.forEach(t=>{h+=t.amount;const s=e[t.symbol];if(s>0){let e=t.amount,a=t.amount*s;"double_down"===u?a*=2:"insurance"===u&&(a=Math.floor(.5*a)),e+=a,c+=e,this.state.isMegaRound&&r===t.symbol&&n>0&&(c+=Math.floor(this.state.jackpotPool/n))}else d+=t.amount,"double_down"===u&&(h+=t.amount)}),l+=h,"insurance"===u&&d>0&&(c+=Math.floor(.5*d)),"lucky_star"===u&&c>0){const e=o(s.lucky_star?.luckyMultiplier?.[0],s.lucky_star?.luckyMultiplier?.[1]);c=Math.floor(c*e),this.state.playerPowerUps[t]?.lucky_star&&(this.state.playerPowerUps[t].lucky_star.lastMultiplier=e)}const p=i.currentBalance-h+c;i.currentBalance=Math.max(0,p),i.balanceHistory.push(i.currentBalance)}),this.state.jackpotPool+=Math.floor(l*i),this.state.isMegaRound&&a&&(this.state.jackpotPool=0),Object.keys(this.state.playerPowerUps).forEach(t=>{const e=this.state.playerPowerUps[t];e&&Object.values(e).forEach(t=>{t.cooldown>0&&t.cooldown--})}),this.state.activePowerUps={},this.state.powerUpPredictions={},this.state.gamePhase="results",this.checkGameOver()}checkGameOver(){const t=Object.values(this.state.playerBalances).filter(t=>t.currentBalance>0);if(0===this.state.minBalanceToWin)1===t.length&&Object.keys(this.state.playerBalances).length>1?(this.state.gamePhase="ended",this.state.winners=[t[0].playerId]):0===t.length&&Object.keys(this.state.playerBalances).length>0&&(this.state.gamePhase="ended",this.state.winners=[]);else{const e=t.filter(t=>t.currentBalance>=this.state.minBalanceToWin);if(e.length>0){e.sort((t,e)=>e.currentBalance-t.currentBalance);const t=e[0].currentBalance,s=e.filter(e=>e.currentBalance===t);return this.state.gamePhase="ended",void(this.state.winners=s.map(t=>t.playerId))}1===t.length&&Object.keys(this.state.playerBalances).length>1?(this.state.gamePhase="ended",this.state.winners=[t[0].playerId]):0===t.length&&Object.keys(this.state.playerBalances).length>0&&(this.state.gamePhase="ended",this.state.winners=[])}}handleStartNewRound(){this.state.gamePhase="betting",this.state.currentBets={},this.state.diceRoll=null,this.state.playersReady={},this.state.currentRound++,this.state.isMegaRound=this.state.currentRound>0&&this.state.currentRound%n===0,this.state.powerUpPredictions={},Object.keys(this.state.playerBalances).forEach(t=>{this.state.playerBalances[t].totalBet=0}),this.checkBotTurn()}handleResetGame(){Object.keys(this.state.playerBalances).forEach(t=>{const s=this.state.playerBalances[t];s.currentBalance=e,s.balanceHistory=[e],s.totalBet=0,this.state.playerPowerUps[t]=this.initializePowerUps()}),this.state.gamePhase="waiting",this.state.currentBets={},this.state.diceRoll=null,this.state.currentRound=0,this.state.playersReady={},this.state.winners=[],this.state.activePowerUps={},this.state.powerUpPredictions={},this.state.recentRolls={},this.state.isMegaRound=!1,this.state.jackpotPool=0,this.state.minBalanceToWin=0,this.checkBotTurn()}handleSetGameMode(t){"waiting"===this.state.gamePhase&&(this.state.minBalanceToWin=t)}handleAddBot(){const t=`BOT_${Date.now()}`,s=`Bot ${Object.keys(this.state.playerBalances).length+1}`;this.state.playerBalances[t]={playerId:t,username:s,currentBalance:e,balanceHistory:[e],totalBet:0,isBot:!0},this.state.playerPowerUps[t]=this.initializePowerUps(),this.checkBotTurn()}handleRemoveBot(t){const e=this.state.playerBalances[t];e&&e.isBot&&(delete this.state.playerBalances[t],delete this.state.currentBets[t],delete this.state.playersReady[t],delete this.state.playerPowerUps[t],delete this.state.activePowerUps[t])}checkBotTurn(){this.isHost&&"betting"===this.state.gamePhase&&(this.botMoveTimeout&&clearTimeout(this.botMoveTimeout),this.botMoveTimeout=setTimeout(()=>{this.executeBotActions()},800))}executeBotActions(){Object.values(this.state.playerBalances).filter(t=>t.isBot).forEach(t=>{if(this.state.playersReady[t.playerId])return;const e=this.state.playerPowerUps[t.playerId];if(e&&Math.random()<.3){const s=[];if(0===e.double_down.cooldown&&s.push("double_down"),0===e.insurance.cooldown&&s.push("insurance"),s.length>0){const e=t.currentBalance>500&&s.includes("double_down")?"double_down":s[Math.floor(Math.random()*s.length)];this.handleActivatePowerUp(t.playerId,e)}}const s=Math.random();let i=1;i=s<.5?Math.random()<.5?1:2:Math.random()<.5?2:3;const n=s<.3?o(.05,.1):s<.7?o(.1,.25):o(.25,.5),l=Math.max(a,Math.floor(t.currentBalance*n)),c=Math.max(a,Math.floor(l/i)),h=[...r];for(let a=0;a<i&&h.length>0;a++){const e=Math.floor(Math.random()*h.length),s=h[e];h.splice(e,1),this.handlePlaceBet(t.playerId,s,c)}this.state.playersReady[t.playerId]=!0})}requestPlaceBet(t,e){this.makeAction({type:"PLACE_BET",playerId:this.userId,symbol:t,amount:e})}requestClearBets(){this.makeAction({type:"CLEAR_BETS",playerId:this.userId})}requestSyncBets(t){this.makeAction({type:"SYNC_BETS",playerId:this.userId,bets:t})}requestToggleReady(){this.makeAction({type:"TOGGLE_READY",playerId:this.userId})}requestRollDice(){this.makeAction({type:"ROLL_DICE"})}requestStartNewRound(){this.makeAction({type:"START_NEW_ROUND"})}requestResetGame(){this.makeAction({type:"RESET_GAME"})}requestSetGameMode(t){this.makeAction({type:"SET_GAME_MODE",minBalance:t})}requestAddBot(){this.makeAction({type:"ADD_BOT"})}requestRemoveBot(t){this.makeAction({type:"REMOVE_BOT",playerId:t})}requestActivatePowerUp(t){this.makeAction({type:"ACTIVATE_POWERUP",playerId:this.userId,powerUpType:t})}requestDeactivatePowerUp(){this.makeAction({type:"DEACTIVATE_POWERUP",playerId:this.userId})}handleActivatePowerUp(t,e){if("betting"!==this.state.gamePhase)return;const a=this.state.playerPowerUps[t];if(!a)return;const i=a[e];if(!i||i.cooldown>0)return;const n=s[e];if("pre_roll"===n.timing&&"reveal_one"===e){const e=r[o(0,5,!0)],s=o(n.accuracy?.[0]||.6,n.accuracy?.[1]||.9);this.state.powerUpPredictions[t]={symbol:e,accuracy:s}}this.state.activePowerUps[t]=e,i.cooldown=n.cooldown,i.lastUsedRound=this.state.currentRound}handleDeactivatePowerUp(t){if("betting"!==this.state.gamePhase)return;const e=this.state.activePowerUps[t];if(!e)return;if("post_roll"!==s[e].timing)return;const a=this.state.playerPowerUps[t];if(!a)return;const r=a[e];r&&(r.cooldown=0,r.lastUsedRound=-1,this.state.activePowerUps[t]=null)}updatePlayers(t){super.updatePlayers(t),t.forEach(t=>{this.state.playerBalances[t.id]||(this.state.playerBalances[t.id]={playerId:t.id,username:t.username,currentBalance:e,balanceHistory:[e],totalBet:0,isBot:t.isBot||!1},this.state.playerPowerUps[t.id]=this.initializePowerUps())});const s=new Set(t.map(t=>t.id));Object.keys(this.state.playerBalances).forEach(t=>{const e=this.state.playerBalances[t].isBot;s.has(t)||e||(delete this.state.playerBalances[t],delete this.state.currentBets[t],delete this.state.playersReady[t],delete this.state.playerPowerUps[t],delete this.state.activePowerUps[t])})}destroy(){this.botMoveTimeout&&clearTimeout(this.botMoveTimeout),super.destroy()}}export{l as default};
