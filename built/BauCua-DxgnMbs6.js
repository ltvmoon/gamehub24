import{B as t}from"./BaseGame-D8z93T-B.js";import{G as e,I as s,P as a,M as r,a as i,A as n,b as o,J as l,c as h,d as c,B as d}from"./types-8lSJioTM.js";import{d as p,r as u}from"./index-7ewwbQld.js";import"./socket-DRbsQkF5.js";import"./react-vendor-BLBa7-IT.js";import"./zustand-BEg5S8SY.js";class y extends t{isGameOver(t){return t.gamePhase===e.ENDED}botMoveTimeout=null;getInitState(){const t={},a={};return this.players.forEach(e=>{t[e.id]={playerId:e.id,username:e.username,currentBalance:s,balanceHistory:[s],totalBet:0,isBot:e.isBot||!1},a[e.id]=this.initializePowerUps()}),{gamePhase:e.WAITING,playerBalances:t,currentBets:{},diceRoll:null,currentRound:0,playersReady:{},winners:[],playerPowerUps:a,activePowerUps:{},powerUpPredictions:{},recentRolls:{},isMegaRound:!1,jackpotPool:0,minBalanceToWin:0}}initializePowerUps(){const t={};for(const e of Object.keys(a)){const s=Number(e);t[s]={type:s,cooldown:0,lastUsedRound:-1}}return t}onSocketGameAction(t){const e=t.action;if(this.isHost)switch(e.type){case"PLACE_BET":this.handlePlaceBet(e.playerId,e.symbol,e.amount);break;case"CLEAR_BETS":this.handleClearBets(e.playerId);break;case"SYNC_BETS":this.handleSyncBets(e.playerId,e.bets);break;case"TOGGLE_READY":this.handleToggleReady(e.playerId);break;case"ROLL_DICE":this.handleRollDice();break;case"START_NEW_ROUND":this.handleStartNewRound();break;case"RESET_GAME":this.handleResetGame();break;case"SET_GAME_MODE":this.handleSetGameMode(e.minBalance);break;case"ADD_BOT":this.handleAddBot();break;case"REMOVE_BOT":this.handleRemoveBot(e.playerId);break;case"ACTIVATE_POWERUP":this.handleActivatePowerUp(e.playerId,e.powerUpType);break;case"DEACTIVATE_POWERUP":this.handleDeactivatePowerUp(e.playerId)}}handlePlaceBet(t,s,a){if(this.state.gamePhase!==e.BETTING)return;const i=this.state.playerBalances[t];if(!i)return;const n=this.state.currentBets[t]||[],o=n.reduce((t,e)=>t+e[1],0),l=i.currentBalance-o,h=Math.min(a,l);if(h<r)return;const c=n.findIndex(t=>t[0]===s);c>=0?n[c][1]+=h:n.push([s,h]),this.state.currentBets[t]=n,this.state.playerBalances[t].totalBet=o+h}handleClearBets(t){this.state.gamePhase===e.BETTING&&(this.state.currentBets[t]=[],this.state.playerBalances[t].totalBet=0,this.state.playersReady[t]=!1)}handleSyncBets(t,s){if(this.state.gamePhase!==e.BETTING)return;const a=this.state.playerBalances[t];if(!a)return;const r=s.reduce((t,e)=>t+e[1],0);r>a.currentBalance||(this.state.currentBets[t]=s,this.state.playerBalances[t].totalBet=r)}handleToggleReady(t){if(this.state.gamePhase!==e.BETTING)return;((this.state.currentBets[t]||[]).length>0||this.state.playersReady[t])&&(this.state.playersReady[t]=!this.state.playersReady[t])}handleRollDice(){if(this.state.gamePhase!==e.BETTING)return;if(0===Object.keys(this.state.currentBets).filter(t=>(this.state.currentBets[t]||[]).length>0).length)return void this.handleStartNewRound();this.state.gamePhase=e.ROLLING;const t=[n[Math.floor(Math.random()*n.length)],n[Math.floor(Math.random()*n.length)],n[Math.floor(Math.random()*n.length)]];Object.keys(this.state.powerUpPredictions).forEach(e=>{const s=this.state.powerUpPredictions[e];if(this.state.activePowerUps[e]===i.REVEAL_ONE){const e=t.includes(s.symbol),a=Math.random()<s.accuracy;if(s.actuallyCorrect=a,a&&!e){const e=Math.floor(3*Math.random());t[e]=s.symbol}else if(!a&&e){const e=t.map((t,e)=>t===s.symbol?e:-1).filter(t=>t>=0);if(e.length>0){const a=n.filter(t=>t!==s.symbol),r=e[Math.floor(Math.random()*e.length)];t[r]=a[Math.floor(Math.random()*a.length)]}}}}),this.state.diceRoll=[t[0],t[1],t[2]];const s=`R${this.state.currentRound}`;this.state.recentRolls[s]=[t[0],t[1],t[2]];const a=Object.keys(this.state.recentRolls);if(a.length>o){const t=a.sort((t,e)=>parseInt(t.substring(1))-parseInt(e.substring(1))),e=t.length-o;for(let s=0;s<e;s++)delete this.state.recentRolls[t[s]]}setTimeout(()=>{this.calculateResults()},3500)}calculateResults(){if(!this.state.diceRoll)return;const t=this.state.diceRoll,s={[d.GOURD]:0,[d.CRAB]:0,[d.SHRIMP]:0,[d.FISH]:0,[d.CHICKEN]:0,[d.DEER]:0};t.forEach(t=>{s[t]++});const r=t[0]===t[1]&&t[1]===t[2],n=r?t[0]:null;let h=0;this.state.isMegaRound&&n&&(h=Object.values(this.state.currentBets).filter(t=>t.some(t=>t[0]===n)).length);let c=0;Object.keys(this.state.currentBets).forEach(t=>{const e=this.state.currentBets[t]||[],r=this.state.playerBalances[t];if(!r)return;let l=0,d=0,p=0;const y=this.state.activePowerUps[t];if(e.forEach(t=>{const e=t[0],a=t[1];d+=a;const r=s[e];if(r>0){let t=a,s=a*r;y===i.DOUBLE_DOWN?s*=2:y===i.INSURANCE&&(s=Math.floor(.5*s)),t+=s,l+=t,this.state.isMegaRound&&n===e&&h>0&&(l+=Math.floor(this.state.jackpotPool/h))}else p+=a,y===i.DOUBLE_DOWN&&(d+=a)}),c+=d,y===i.INSURANCE&&p>0&&(l+=Math.floor(.5*p)),y===i.LUCKY_STAR&&l>0){const e=u(a[i.LUCKY_STAR]?.luckyMultiplier?.[0],a[i.LUCKY_STAR]?.luckyMultiplier?.[1]);l=Math.floor(l*e),this.state.playerPowerUps[t]?.[i.LUCKY_STAR]&&(this.state.playerPowerUps[t][i.LUCKY_STAR].lastMultiplier=Math.round(10*e)/10)}const B=r.currentBalance-d+l;r.currentBalance=Math.max(0,B),r.balanceHistory.push(r.currentBalance),r.balanceHistory.length>o&&r.balanceHistory.shift()}),this.state.jackpotPool+=Math.floor(c*l),this.state.isMegaRound&&r&&(this.state.jackpotPool=0),Object.keys(this.state.playerPowerUps).forEach(t=>{const e=this.state.playerPowerUps[t];e&&Object.values(e).forEach(t=>{t.cooldown>0&&t.cooldown--})}),this.state.activePowerUps={},this.state.powerUpPredictions={},this.state.gamePhase=e.RESULTS,this.checkGameOver()}checkGameOver(){const t=Object.values(this.state.playerBalances).filter(t=>t.currentBalance>0);if(0===this.state.minBalanceToWin)1===t.length&&Object.keys(this.state.playerBalances).length>1?(this.state.gamePhase=e.ENDED,this.state.winners=[t[0].playerId]):0===t.length&&Object.keys(this.state.playerBalances).length>0&&(this.state.gamePhase=e.ENDED,this.state.winners=[]);else{const s=t.filter(t=>t.currentBalance>=this.state.minBalanceToWin);if(s.length>0){s.sort((t,e)=>e.currentBalance-t.currentBalance);const t=s[0].currentBalance,a=s.filter(e=>e.currentBalance===t);return this.state.gamePhase=e.ENDED,void(this.state.winners=a.map(t=>t.playerId))}1===t.length&&Object.keys(this.state.playerBalances).length>1?(this.state.gamePhase=e.ENDED,this.state.winners=[t[0].playerId]):0===t.length&&Object.keys(this.state.playerBalances).length>0&&(this.state.gamePhase=e.ENDED,this.state.winners=[])}}handleStartNewRound(){this.state.gamePhase=e.BETTING,this.state.currentBets={},this.state.diceRoll=null,this.state.playersReady={},this.state.currentRound++,this.state.isMegaRound=this.state.currentRound>0&&this.state.currentRound%h===0,this.state.powerUpPredictions={},Object.keys(this.state.playerBalances).forEach(t=>{this.state.playerBalances[t].totalBet=0}),this.checkBotTurn()}handleResetGame(){Object.keys(this.state.playerBalances).forEach(t=>{const e=this.state.playerBalances[t];e.currentBalance=s,e.balanceHistory=[s],e.totalBet=0,this.state.playerPowerUps[t]=this.initializePowerUps()}),this.state.gamePhase=e.WAITING,this.state.currentBets={},this.state.diceRoll=null,this.state.currentRound=0,this.state.playersReady={},this.state.winners=[],this.state.activePowerUps={},this.state.powerUpPredictions={},this.state.recentRolls={},this.state.isMegaRound=!1,this.state.jackpotPool=0,this.state.minBalanceToWin=0,this.checkBotTurn()}handleSetGameMode(t){this.state.gamePhase===e.WAITING&&(this.state.minBalanceToWin=t)}handleAddBot(){const t=`BOT_${p()}`,e=`Bot ${Object.keys(this.state.playerBalances).length+1}`;this.state.playerBalances[t]={playerId:t,username:e,currentBalance:s,balanceHistory:[s],totalBet:0,isBot:!0},this.state.playerPowerUps[t]=this.initializePowerUps(),this.checkBotTurn()}handleRemoveBot(t){const e=this.state.playerBalances[t];e&&e.isBot&&(delete this.state.playerBalances[t],delete this.state.currentBets[t],delete this.state.playersReady[t],delete this.state.playerPowerUps[t],delete this.state.activePowerUps[t])}checkBotTurn(){this.isHost&&this.state.gamePhase===e.BETTING&&(this.botMoveTimeout&&clearTimeout(this.botMoveTimeout),this.botMoveTimeout=setTimeout(()=>{this.executeBotActions()},800))}executeBotActions(){Object.values(this.state.playerBalances).filter(t=>t.isBot).forEach(t=>{if(this.state.playersReady[t.playerId])return;const e=this.state.playerPowerUps[t.playerId];if(e&&Math.random()<.3){const s=[];if(0===e[i.DOUBLE_DOWN].cooldown&&s.push(i.DOUBLE_DOWN),0===e[i.INSURANCE].cooldown&&s.push(i.INSURANCE),s.length>0){const e=t.currentBalance>500&&s.includes(i.DOUBLE_DOWN)?i.DOUBLE_DOWN:s[Math.floor(Math.random()*s.length)];this.handleActivatePowerUp(t.playerId,e)}}const s=Math.random();let a=1;a=s<.5?Math.random()<.5?1:2:Math.random()<.5?2:3;const o=s<.3?u(.05,.1):s<.7?u(.1,.25):u(.25,.5),l=Math.max(r,Math.floor(t.currentBalance*o)),h=Math.max(r,Math.floor(l/a)),c=[...n];for(let r=0;r<a&&c.length>0;r++){const e=Math.floor(Math.random()*c.length),s=c[e];c.splice(e,1),this.handlePlaceBet(t.playerId,s,h)}this.state.playersReady[t.playerId]=!0})}requestPlaceBet(t,e){this.makeAction({type:"PLACE_BET",playerId:this.userId,symbol:t,amount:e})}requestClearBets(){this.makeAction({type:"CLEAR_BETS",playerId:this.userId})}requestSyncBets(t){this.makeAction({type:"SYNC_BETS",playerId:this.userId,bets:t})}requestToggleReady(){this.makeAction({type:"TOGGLE_READY",playerId:this.userId})}requestRollDice(){this.makeAction({type:"ROLL_DICE"})}requestStartNewRound(){this.makeAction({type:"START_NEW_ROUND"})}requestResetGame(){this.makeAction({type:"RESET_GAME"})}requestSetGameMode(t){this.makeAction({type:"SET_GAME_MODE",minBalance:t})}requestAddBot(){this.makeAction({type:"ADD_BOT"})}requestRemoveBot(t){this.makeAction({type:"REMOVE_BOT",playerId:t})}requestActivatePowerUp(t){this.makeAction({type:"ACTIVATE_POWERUP",playerId:this.userId,powerUpType:t})}requestDeactivatePowerUp(){this.makeAction({type:"DEACTIVATE_POWERUP",playerId:this.userId})}handleActivatePowerUp(t,s){if(this.state.gamePhase!==e.BETTING)return;const r=this.state.playerPowerUps[t];if(!r)return;const o=r[s];if(!o||o.cooldown>0)return;const l=a[s];if(l.timing===c.PRE_ROLL&&s===i.REVEAL_ONE){const e=n[u(0,5,!0)],s=u(l.accuracy?.[0]||.6,l.accuracy?.[1]||.9);this.state.powerUpPredictions[t]={symbol:e,accuracy:s}}this.state.activePowerUps[t]=s,o.cooldown=l.cooldown,o.lastUsedRound=this.state.currentRound}handleDeactivatePowerUp(t){if(this.state.gamePhase!==e.BETTING)return;const s=this.state.activePowerUps[t];if(!s)return;if(a[s].timing!==c.POST_ROLL)return;const r=this.state.playerPowerUps[t];if(!r)return;const i=r[s];i&&(i.cooldown=0,i.lastUsedRound=-1,this.state.activePowerUps[t]=null)}updatePlayers(t){super.updatePlayers(t),t.forEach(t=>{this.state.playerBalances[t.id]||(this.state.playerBalances[t.id]={playerId:t.id,username:t.username,currentBalance:s,balanceHistory:[s],totalBet:0,isBot:t.isBot||!1},this.state.playerPowerUps[t.id]=this.initializePowerUps())});const e=new Set(t.map(t=>t.id));Object.keys(this.state.playerBalances).forEach(t=>{const s=this.state.playerBalances[t].isBot;e.has(t)||s||(delete this.state.playerBalances[t],delete this.state.currentBets[t],delete this.state.playersReady[t],delete this.state.playerPowerUps[t],delete this.state.activePowerUps[t])})}destroy(){this.botMoveTimeout&&clearTimeout(this.botMoveTimeout),super.destroy()}}export{y as default};
