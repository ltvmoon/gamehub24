import{B as t}from"./BaseGame-BjLvdXwv.js";import{S as e,R as s,C as a}from"./types-B7pdz5Vg.js";import"./socket-DRbsQkF5.js";class i extends t{state;onStateChange;constructor(t,e,s,a,i){super(t,e,s,a);const n=Array(4).fill(null).map((t,e)=>{const s=i[e];return{id:s?.id||null,username:s?.username||`Slot ${e+1}`,hand:[],isBot:!1,isGuest:!1,isHost:s?.id===this.userId,passed:!1}});this.state={players:n,currentTrick:[],currentTurnIndex:0,lastPlayedBy:null,lastCombination:null,winner:null,gamePhase:"waiting",newGameRequest:null},this.init()}init(){this.isHost&&this.broadcastState()}onUpdate(t){this.onStateChange=t}getState(){return{...this.state}}setState(t){this.state=t,this.onStateChange?.(this.state)}handleAction(t){const e=t.action;if(this.isHost)switch(e.type){case"PLAY_CARDS":this.handlePlayCards(e.playerId,e.cards);break;case"PASS":this.handlePass(e.playerId);break;case"ADD_BOT":this.handleAddBot(e.slotIndex);break;case"JOIN_SLOT":this.handleJoinSlot(e.slotIndex,e.playerId,e.playerName);break;case"REMOVE_PLAYER":this.handleRemovePlayer(e.slotIndex);break;case"START_GAME":this.handleStartGame();break;case"NEW_GAME":case"ACCEPT_NEW_GAME":this.reset();break;case"REQUEST_NEW_GAME":this.handleNewGameRequest(e.playerId,e.playerName);break;case"DECLINE_NEW_GAME":this.state.newGameRequest=null,this.broadcastState(),this.setState({...this.state})}}makeMove(t){this.handleAction({action:t})}createDeck(){const t=[];for(const a of[e.SPADE,e.CLUB,e.DIAMOND,e.HEART])for(let e=s.THREE;e<=s.TWO;e++)t.push({suit:a,rank:e});return t}shuffleDeck(t){const e=[...t];for(let s=e.length-1;s>0;s--){const t=Math.floor(Math.random()*(s+1));[e[s],e[t]]=[e[t],e[s]]}return e}dealCards(){const t=this.shuffleDeck(this.createDeck());let e=0;for(const s of this.state.players)null!==s.id&&(s.hand=t.slice(e,e+13),this.sortHand(s.hand),e+=13)}sortHand(t){t.sort((t,e)=>t.rank!==e.rank?t.rank-e.rank:t.suit-e.suit)}getCardValue(t){return 10*t.rank+t.suit}getCombination(t){if(0===t.length)return null;const e=[...t].sort((t,e)=>this.getCardValue(t)-this.getCardValue(e));if(1===t.length)return{type:a.SINGLE,cards:e,value:this.getCardValue(e[0])};if(t.every(e=>e.rank===t[0].rank)){if(2===t.length)return{type:a.PAIR,cards:e,value:this.getCardValue(e[e.length-1])};if(3===t.length)return{type:a.TRIPLE,cards:e,value:this.getCardValue(e[e.length-1])};if(4===t.length)return{type:a.FOUR_OF_KIND,cards:e,value:this.getCardValue(e[e.length-1])}}if(t.length>=3){if(this.isStraight(e))return{type:a.STRAIGHT,cards:e,value:100*this.getCardValue(e[e.length-1])+t.length}}if(6===t.length){if(this.isThreeConsecutivePairs(e))return{type:a.THREE_CONSECUTIVE_PAIRS,cards:e,value:this.getCardValue(e[e.length-1])}}return null}isThreeConsecutivePairs(t){if(6!==t.length)return!1;if(t.some(t=>t.rank===s.TWO))return!1;const e=new Map;for(const s of t)e.set(s.rank,(e.get(s.rank)||0)+1);const a=Array.from(e.keys()).sort((t,e)=>t-e);return 3===a.length&&(!!Array.from(e.values()).every(t=>2===t)&&(a[1]===a[0]+1&&a[2]===a[1]+1))}isStraight(t){if(t.some(t=>t.rank===s.TWO))return!1;for(let e=1;e<t.length;e++)if(t[e].rank!==t[e-1].rank+1)return!1;return!0}canBeat(t,e){return!e||(t.type===a.FOUR_OF_KIND&&e.type===a.SINGLE&&e.cards[0].rank===s.TWO||(t.type===a.THREE_CONSECUTIVE_PAIRS&&e.type===a.SINGLE&&e.cards[0].rank===s.TWO||t.type===e.type&&((t.type!==a.STRAIGHT||t.cards.length===e.cards.length)&&t.value>e.value)))}handlePlayCards(t,e){if("playing"!==this.state.gamePhase)return;const s=this.state.players.findIndex(e=>e.id===t);if(-1===s||s!==this.state.currentTurnIndex)return;const a=this.state.players[s];if(!this.playerHasCards(a,e))return;const i=this.getCombination(e);if(i&&this.canBeat(i,this.state.lastCombination)){if(this.removeCardsFromHand(a,e),this.state.currentTrick.push({playerId:t,cards:e}),this.state.lastPlayedBy=t,this.state.lastCombination=i,0==this.state.currentTrick.length&&this.state.players.forEach(e=>{e.id!==t&&(e.passed=!1)}),0===a.hand.length)return this.state.winner=t,this.state.gamePhase="ended",this.broadcastState(),this.setState({...this.state}),void this.broadcastGameEnd({winner:t});this.advanceTurn(),this.broadcastState(),this.setState({...this.state}),this.checkBotTurn()}}handlePass(t){if("playing"!==this.state.gamePhase)return;const e=this.state.players.findIndex(e=>e.id===t);if(-1===e||e!==this.state.currentTurnIndex)return;if(!this.state.lastCombination)return;this.state.players[e].passed=!0;if(this.state.players.filter(t=>null!==t.id&&t.hand.length>0).every(t=>t.id===this.state.lastPlayedBy||t.passed)&&this.state.lastPlayedBy){this.state.currentTrick=[],this.state.lastCombination=null,this.state.players.forEach(t=>t.passed=!1);const t=this.state.players.findIndex(t=>t.id===this.state.lastPlayedBy);this.state.currentTurnIndex=t}else this.advanceTurn();this.broadcastState(),this.setState({...this.state}),this.checkBotTurn()}advanceTurn(){let t=(this.state.currentTurnIndex+1)%4,e=0;for(;e<4;){const s=this.state.players[t];if(null!==s.id&&s.hand.length>0&&!s.passed)break;t=(t+1)%4,e++}this.state.currentTurnIndex=t}playerHasCards(t,e){return e.every(e=>t.hand.some(t=>t.rank===e.rank&&t.suit===e.suit))}removeCardsFromHand(t,e){for(const s of e){const e=t.hand.findIndex(t=>t.rank===s.rank&&t.suit===s.suit);-1!==e&&t.hand.splice(e,1)}}handleAddBot(t){if(t<0||t>=4)return;if("waiting"!==this.state.gamePhase)return;if(null!==this.state.players[t].id)return;const e=`BOT_${t}_${Date.now()}`,s=[...this.state.players];s[t]={id:e,username:`Bot ${t+1}`,hand:[],isBot:!0,isGuest:!1,isHost:!1,passed:!1},this.state={...this.state,players:s},this.broadcastState(),this.onStateChange?.(this.state)}handleJoinSlot(t,e,s){if(t<0||t>=4)return;if("waiting"!==this.state.gamePhase)return;if(null!==this.state.players[t].id)return;if(this.state.players.some(t=>t.id===e))return;const a=[...this.state.players];a[t]={id:e,username:s,hand:[],isBot:!1,isGuest:!1,isHost:!1,passed:!1},this.state={...this.state,players:a},this.broadcastState(),this.onStateChange?.(this.state)}handleRemovePlayer(t){if(t<0||t>=4)return;if("waiting"!==this.state.gamePhase)return;const e=this.state.players[t];if(!e.isBot&&!e.isGuest)return;const s=[...this.state.players];s[t]={id:null,username:`Slot ${t+1}`,hand:[],isBot:!1,isGuest:!1,isHost:!1,passed:!1},this.state={...this.state,players:s},this.broadcastState(),this.onStateChange?.(this.state)}handleStartGame(){if("waiting"!==this.state.gamePhase)return;this.state.players.filter(t=>null!==t.id).length<2||(this.dealCards(),this.state.gamePhase="playing",this.state.currentTurnIndex=this.findStartingPlayer(),this.state.currentTrick=[],this.state.lastCombination=null,this.state.lastPlayedBy=null,this.broadcastState(),this.setState({...this.state}),this.checkBotTurn())}findStartingPlayer(){for(let t=0;t<4;t++){const a=this.state.players[t];if(a.id&&a.hand.some(t=>t.rank===s.THREE&&t.suit===e.SPADE))return t}return this.state.players.findIndex(t=>null!==t.id)}handleNewGameRequest(t,e){this.state.newGameRequest={fromId:t,fromName:e},this.broadcastState(),this.setState({...this.state})}reset(){const t=this.state.players.map((t,e)=>({id:t.id,username:t.username,hand:[],isBot:t.isBot,isGuest:t.isGuest,isHost:t.isHost,passed:!1}));this.state={players:t,currentTrick:[],currentTurnIndex:0,lastPlayedBy:null,lastCombination:null,winner:null,gamePhase:"waiting",newGameRequest:null},this.broadcastState(),this.setState({...this.state})}checkGameEnd(){return this.state.winner?{winner:this.state.winner}:null}updatePlayers(t){for(let e=0;e<Math.min(t.length,4);e++){const s=this.state.players[e];s.isBot||s.isGuest||(s.id=t[e]?.id||null,s.username=t[e]?.username||`Slot ${e+1}`)}this.broadcastState(),this.setState({...this.state})}checkBotTurn(){if(!this.isHost)return;if("playing"!==this.state.gamePhase)return;const t=this.state.players[this.state.currentTurnIndex];t.isBot&&t.id&&setTimeout(()=>this.makeBotMove(t),800)}makeBotMove(t){if("playing"!==this.state.gamePhase)return;if(!t.id)return;const e=this.findValidPlay(t.hand);e?this.handlePlayCards(t.id,e):this.state.lastCombination?this.handlePass(t.id):this.handlePlayCards(t.id,[t.hand[0]])}findValidPlay(t){const e=this.state.lastCombination;if(!e)return[t[0]];switch(e.type){case a.SINGLE:return this.findBeatingSingle(t,e);case a.PAIR:return this.findBeatingPair(t,e);case a.TRIPLE:return this.findBeatingTriple(t,e);case a.STRAIGHT:return this.findBeatingStraight(t,e);default:return null}}findBeatingSingle(t,e){const s=this.getCardValue(e.cards[0]);for(const a of t)if(this.getCardValue(a)>s)return[a];return null}findBeatingPair(t,e){const s=e.value,a=this.groupByRank(t);for(const i of Object.values(a))if(i.length>=2){const t=i.slice(0,2),e=this.getCombination(t);if(e&&e.value>s)return t}return null}findBeatingTriple(t,e){const s=e.value,a=this.groupByRank(t);for(const i of Object.values(a))if(i.length>=3){const t=i.slice(0,3),e=this.getCombination(t);if(e&&e.value>s)return t}return null}findBeatingStraight(t,e){const s=e.cards.length,i=e.value;for(let n=0;n<=t.length-s;n++){const e=t.slice(n,n+s),r=this.getCombination(e);if(r&&r.type===a.STRAIGHT&&r.value>i)return e}return null}groupByRank(t){const e={};for(const s of t)e[s.rank]||(e[s.rank]=[]),e[s.rank].push(s);return e}requestPlayCards(t){const e={type:"PLAY_CARDS",playerId:this.userId,cards:t};this.isHost?this.handleAction({action:e}):this.sendAction(e)}requestPass(){const t={type:"PASS",playerId:this.userId};this.isHost?this.handleAction({action:t}):this.sendAction(t)}requestAddBot(t){const e={type:"ADD_BOT",slotIndex:t};this.isHost?this.handleAction({action:e}):this.sendAction(e)}requestJoinSlot(t,e){const s={type:"JOIN_SLOT",slotIndex:t,playerId:this.userId,playerName:e};this.isHost?this.handleAction({action:s}):this.sendAction(s)}requestRemovePlayer(t){const e={type:"REMOVE_PLAYER",slotIndex:t};this.isHost?this.handleAction({action:e}):this.sendAction(e)}requestStartGame(){const t={type:"START_GAME"};this.isHost?this.handleAction({action:t}):this.sendAction(t)}requestNewGame(){if(this.isHost)this.handleAction({action:{type:"NEW_GAME"}});else{const t=this.state.players.find(t=>t.id===this.userId),e={type:"REQUEST_NEW_GAME",playerId:this.userId,playerName:t?.username||"Guest"};this.sendAction(e)}}acceptNewGame(){this.isHost&&this.handleAction({action:{type:"ACCEPT_NEW_GAME"}})}declineNewGame(){this.isHost&&this.handleAction({action:{type:"DECLINE_NEW_GAME"}})}getMyPlayerIndex(){return this.state.players.findIndex(t=>t.id===this.userId)}getUserId(){return this.userId}canStartGame(){if("waiting"!==this.state.gamePhase)return!1;return this.state.players.filter(t=>null!==t.id).length>=2}validateSelectedCards(t){if(0===t.length)return{valid:!1,error:"Select cards to play"};const e=this.getCombination(t);if(!e)return 2===t.length?{valid:!1,error:"Cards must be a pair (same rank)"}:3===t.length?{valid:!1,error:"Cards must be a triple or straight"}:t.length>=4?{valid:!1,error:"Invalid combination (try straight or four-of-a-kind)"}:{valid:!1,error:"Invalid card selection"};const i=this.state.lastCombination;return i?e.type!==i.type?e.type===a.FOUR_OF_KIND&&i.type===a.SINGLE&&i.cards[0].rank===s.TWO||e.type===a.THREE_CONSECUTIVE_PAIRS&&i.type===a.SINGLE&&i.cards[0].rank===s.TWO?{valid:!0}:{valid:!1,error:`Must play ${i.type.replace("_"," ")}`}:e.type===a.STRAIGHT&&e.cards.length!==i.cards.length?{valid:!1,error:`Straight must have ${i.cards.length} cards`}:e.value<=i.value?{valid:!1,error:"Your cards are too low"}:{valid:!0}:{valid:!0}}}export{i as default};
